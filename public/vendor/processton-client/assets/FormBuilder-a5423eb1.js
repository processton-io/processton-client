import { r as reactExports, R as React, b as reactDomExports, d as React$1, j as jsxRuntimeExports, g as getDefaultExportFromCjs, W as W$2, Q as Q$1, f as axios, y as yt$1 } from "./app-7ef8dedc.js";
import { p as postHeight } from "./iframewapper_helper-4a327444.js";
import { o as o$7, e as I$5, f as a$8, y as y$4, n as n$3, H as H$3, p as p$2, E as E$1, u as u$8, O as O$3, g as u$9, w as w$2, h as s$6, i as d$6, j as j$3, k as n$4, m as m$5, G as G$3, $ as $f7dceffc5ad7768b$export$4e328f61c538687f, l as $6179b936705e76d3$export$ae780daf29e6d456, D as D$4, q as w$3, T as T$4, r as u$a, t as m$6, v as u$b, x as T$5, z as te$1, B as s$7, C as o$8, F as o$9, J as t$3, L as n$5, M as _$3, N as T$6, P as u$c, U as U$3, A as AppIcon, Q as PropTypes, c as classNames, K as Ke$1, S as ActionButton, W as WidgetFormElementType, V as WidgetFormRowType, R as RowElement, s as st$1 } from "./AppLayout-d617927c.js";
import { e as evaluate, g as getPaddingObject, r as rectToClientRect, a as getSide, b as getOppositePlacement, c as getExpandedPlacements, d as getOppositeAxisPlacements, f as getAlignmentSides, h as getSideAxis, i as clamp, j as getAlignment, m as max, k as getOppositeAxis, l as min, n as getAlignmentAxis, o as getAxisLength, p as getOverflowAncestors, q as isElement, s as createCoords, t as getWindow, u as getComputedStyle$1, v as getDocumentElement, w as isHTMLElement, x as round, y as isWebKit, z as floor, A as getNodeName, B as isOverflowElement, C as getNodeScroll, D as getParentNode, E as isLastTraversableNode, F as isTableElement, G as isContainingBlock, H as getContainingBlock, _ as _objectWithoutProperties$9, I as _slicedToArray$3, J as handleInputChange, K as _objectSpread2, L as _defineProperty$8, M as useStateManager, S as Select, N as _extends$9, O as InputLabel, T as TextInput, P as SelectInput$1 } from "./SimpleSelectInput-8e6a6914.js";
/* empty css              */function T$3(l2, r4, c4) {
  let [i2, s4] = reactExports.useState(c4), e2 = l2 !== void 0, t2 = reactExports.useRef(e2), u3 = reactExports.useRef(false), d4 = reactExports.useRef(false);
  return e2 && !t2.current && !u3.current ? (u3.current = true, t2.current = e2, console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.")) : !e2 && t2.current && !d4.current && (d4.current = true, t2.current = e2, console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")), [e2 ? l2 : i2, o$7((n3) => (e2 || s4(n3), r4 == null ? void 0 : r4(n3)))];
}
function l$5(e2) {
  let [t2] = reactExports.useState(e2);
  return t2;
}
let e$1 = reactExports.createContext(void 0);
function u$7() {
  return reactExports.useContext(e$1);
}
function r$5(n3) {
  let e2 = n3.parentElement, l2 = null;
  for (; e2 && !(e2 instanceof HTMLFieldSetElement); )
    e2 instanceof HTMLLegendElement && (l2 = e2), e2 = e2.parentElement;
  let t2 = (e2 == null ? void 0 : e2.getAttribute("disabled")) === "";
  return t2 && i$3(l2) ? false : t2;
}
function i$3(n3) {
  if (!n3)
    return false;
  let e2 = n3.previousElementSibling;
  for (; e2 !== null; ) {
    if (e2 instanceof HTMLLegendElement)
      return false;
    e2 = e2.previousElementSibling;
  }
  return true;
}
let c$7 = reactExports.createContext(null);
c$7.displayName = "LabelContext";
function P$4() {
  let r4 = reactExports.useContext(c$7);
  if (r4 === null) {
    let l2 = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(l2, P$4), l2;
  }
  return r4;
}
function I$4(r4) {
  var a3, e2, o3;
  let l2 = (e2 = (a3 = reactExports.useContext(c$7)) == null ? void 0 : a3.value) != null ? e2 : void 0;
  return ((o3 = r4 == null ? void 0 : r4.length) != null ? o3 : 0) > 0 ? [l2, ...r4].filter(Boolean).join(" ") : l2;
}
function z$2({ inherit: r4 = false } = {}) {
  let l2 = I$4(), [a3, e2] = reactExports.useState([]), o3 = r4 ? [l2, ...a3].filter(Boolean) : a3;
  return [o3.length > 0 ? o3.join(" ") : void 0, reactExports.useMemo(() => function(t2) {
    let s4 = o$7((i2) => (e2((p2) => [...p2, i2]), () => e2((p2) => {
      let u3 = p2.slice(), d4 = u3.indexOf(i2);
      return d4 !== -1 && u3.splice(d4, 1), u3;
    }))), m3 = reactExports.useMemo(() => ({ register: s4, slot: t2.slot, name: t2.name, props: t2.props, value: t2.value }), [s4, t2.slot, t2.name, t2.props, t2.value]);
    return React.createElement(c$7.Provider, { value: m3 }, t2.children);
  }, [e2])];
}
let N$2 = "label";
function G$2(r4, l2) {
  var y3;
  let a3 = reactExports.useId(), e2 = P$4(), o3 = u$7(), g2 = a$8(), { id: t2 = `headlessui-label-${a3}`, htmlFor: s4 = o3 != null ? o3 : (y3 = e2.props) == null ? void 0 : y3.htmlFor, passive: m3 = false, ...i2 } = r4, p2 = y$4(l2);
  n$3(() => e2.register(t2), [t2, e2.register]);
  let u3 = o$7((L2) => {
    let b3 = L2.currentTarget;
    if (b3 instanceof HTMLLabelElement && L2.preventDefault(), e2.props && "onClick" in e2.props && typeof e2.props.onClick == "function" && e2.props.onClick(L2), b3 instanceof HTMLLabelElement) {
      let n3 = document.getElementById(b3.htmlFor);
      if (n3) {
        let E2 = n3.getAttribute("disabled");
        if (E2 === "true" || E2 === "")
          return;
        let x2 = n3.getAttribute("aria-disabled");
        if (x2 === "true" || x2 === "")
          return;
        (n3 instanceof HTMLInputElement && (n3.type === "radio" || n3.type === "checkbox") || n3.role === "radio" || n3.role === "checkbox" || n3.role === "switch") && n3.click(), n3.focus({ preventScroll: true });
      }
    }
  }), d4 = g2 || false, C2 = reactExports.useMemo(() => ({ ...e2.slot, disabled: d4 }), [e2.slot, d4]), f2 = { ref: p2, ...e2.props, id: t2, htmlFor: s4, onClick: u3 };
  return m3 && ("onClick" in f2 && (delete f2.htmlFor, delete f2.onClick), "onClick" in i2 && delete i2.onClick), H$3({ ourProps: f2, theirProps: i2, slot: C2, defaultTag: s4 ? N$2 : "div", name: e2.name || "Label" });
}
let U$2 = I$5(G$2), K$1 = Object.assign(U$2, {});
function memo(getDeps, fn, opts) {
  let deps = opts.initialDeps ?? [];
  let result2;
  return () => {
    var _a, _b, _c, _d;
    let depTime;
    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts)))
      depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index2) => deps[index2] !== dep);
    if (!depsChanged) {
      return result2;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts)))
      resultTime = Date.now();
    result2 = fn(...newDeps);
    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {
      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
      const resultFpsPercentage = resultEndTime / 16;
      const pad = (str, num) => {
        str = String(str);
        while (str.length < num) {
          str = " " + str;
        }
        return str;
      };
      console.info(
        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
          0,
          Math.min(120 - 120 * resultFpsPercentage, 120)
        )}deg 100% 31%);`,
        opts == null ? void 0 : opts.key
      );
    }
    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result2);
    return result2;
  };
}
function notUndefined(value, msg) {
  if (value === void 0) {
    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ""}`);
  } else {
    return value;
  }
}
const approxEqual = (a3, b3) => Math.abs(a3 - b3) < 1;
const debounce = (fn, ms) => {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), ms);
  };
};
const defaultKeyExtractor = (index2) => index2;
const defaultRangeExtractor = (range) => {
  const start = Math.max(range.startIndex - range.overscan, 0);
  const end = Math.min(range.endIndex + range.overscan, range.count - 1);
  const arr = [];
  for (let i2 = start; i2 <= end; i2++) {
    arr.push(i2);
  }
  return arr;
};
const observeElementRect = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const handler = (rect) => {
    const { width, height } = rect;
    cb({ width: Math.round(width), height: Math.round(height) });
  };
  handler(element.getBoundingClientRect());
  if (typeof ResizeObserver === "undefined") {
    return () => {
    };
  }
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    if (entry == null ? void 0 : entry.borderBoxSize) {
      const box = entry.borderBoxSize[0];
      if (box) {
        handler({ width: box.inlineSize, height: box.blockSize });
        return;
      }
    }
    handler(element.getBoundingClientRect());
  });
  observer.observe(element, { box: "border-box" });
  return () => {
    observer.unobserve(element);
  };
};
const addEventListenerOptions = {
  passive: true
};
const supportsScrollend = typeof window == "undefined" ? true : "onscrollend" in window;
const observeElementOffset = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  let offset2 = 0;
  const fallback = supportsScrollend ? () => void 0 : debounce(() => {
    cb(offset2, false);
  }, instance.options.isScrollingResetDelay);
  const createHandler = (isScrolling) => () => {
    offset2 = element[instance.options.horizontal ? "scrollLeft" : "scrollTop"];
    fallback();
    cb(offset2, isScrolling);
  };
  const handler = createHandler(true);
  const endHandler = createHandler(false);
  endHandler();
  element.addEventListener("scroll", handler, addEventListenerOptions);
  element.addEventListener("scrollend", endHandler, addEventListenerOptions);
  return () => {
    element.removeEventListener("scroll", handler);
    element.removeEventListener("scrollend", endHandler);
  };
};
const measureElement = (element, entry, instance) => {
  if (entry == null ? void 0 : entry.borderBoxSize) {
    const box = entry.borderBoxSize[0];
    if (box) {
      const size2 = Math.round(
        box[instance.options.horizontal ? "inlineSize" : "blockSize"]
      );
      return size2;
    }
  }
  return Math.round(
    element.getBoundingClientRect()[instance.options.horizontal ? "width" : "height"]
  );
};
const elementScroll = (offset2, {
  adjustments = 0,
  behavior
}, instance) => {
  var _a, _b;
  const toOffset = offset2 + adjustments;
  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {
    [instance.options.horizontal ? "left" : "top"]: toOffset,
    behavior
  });
};
class Virtualizer {
  constructor(opts) {
    this.unsubs = [];
    this.scrollElement = null;
    this.isScrolling = false;
    this.scrollToIndexTimeoutId = null;
    this.measurementsCache = [];
    this.itemSizeCache = /* @__PURE__ */ new Map();
    this.pendingMeasuredCacheIndexes = [];
    this.scrollDirection = null;
    this.scrollAdjustments = 0;
    this.measureElementCache = /* @__PURE__ */ new Map();
    this.observer = /* @__PURE__ */ (() => {
      let _ro = null;
      const get = () => {
        if (_ro) {
          return _ro;
        } else if (typeof ResizeObserver !== "undefined") {
          return _ro = new ResizeObserver((entries) => {
            entries.forEach((entry) => {
              this._measureElement(entry.target, entry);
            });
          });
        } else {
          return null;
        }
      };
      return {
        disconnect: () => {
          var _a;
          return (_a = get()) == null ? void 0 : _a.disconnect();
        },
        observe: (target) => {
          var _a;
          return (_a = get()) == null ? void 0 : _a.observe(target, { box: "border-box" });
        },
        unobserve: (target) => {
          var _a;
          return (_a = get()) == null ? void 0 : _a.unobserve(target);
        }
      };
    })();
    this.range = null;
    this.setOptions = (opts2) => {
      Object.entries(opts2).forEach(([key, value]) => {
        if (typeof value === "undefined")
          delete opts2[key];
      });
      this.options = {
        debug: false,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: false,
        getItemKey: defaultKeyExtractor,
        rangeExtractor: defaultRangeExtractor,
        onChange: () => {
        },
        measureElement,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        ...opts2
      };
    };
    this.notify = (force, sync) => {
      var _a, _b;
      const { startIndex, endIndex } = this.range ?? {
        startIndex: void 0,
        endIndex: void 0
      };
      const range = this.calculateRange();
      if (force || startIndex !== (range == null ? void 0 : range.startIndex) || endIndex !== (range == null ? void 0 : range.endIndex)) {
        (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);
      }
    };
    this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((d4) => d4());
      this.unsubs = [];
      this.scrollElement = null;
    };
    this._didMount = () => {
      this.measureElementCache.forEach(this.observer.observe);
      return () => {
        this.observer.disconnect();
        this.cleanup();
      };
    };
    this._willUpdate = () => {
      const scrollElement = this.options.getScrollElement();
      if (this.scrollElement !== scrollElement) {
        this.cleanup();
        this.scrollElement = scrollElement;
        this._scrollToOffset(this.scrollOffset, {
          adjustments: void 0,
          behavior: void 0
        });
        this.unsubs.push(
          this.options.observeElementRect(this, (rect) => {
            this.scrollRect = rect;
            this.notify(false, false);
          })
        );
        this.unsubs.push(
          this.options.observeElementOffset(this, (offset2, isScrolling) => {
            this.scrollAdjustments = 0;
            this.scrollDirection = isScrolling ? this.scrollOffset < offset2 ? "forward" : "backward" : null;
            this.scrollOffset = offset2;
            const prevIsScrolling = this.isScrolling;
            this.isScrolling = isScrolling;
            this.notify(prevIsScrolling !== isScrolling, isScrolling);
          })
        );
      }
    };
    this.getSize = () => {
      return this.scrollRect[this.options.horizontal ? "width" : "height"];
    };
    this.getMeasurementOptions = memo(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey
      ],
      (count2, paddingStart, scrollMargin, getItemKey) => {
        this.pendingMeasuredCacheIndexes = [];
        return {
          count: count2,
          paddingStart,
          scrollMargin,
          getItemKey
        };
      },
      {
        key: false
      }
    );
    this.getFurthestMeasurement = (measurements, index2) => {
      const furthestMeasurementsFound = /* @__PURE__ */ new Map();
      const furthestMeasurements = /* @__PURE__ */ new Map();
      for (let m3 = index2 - 1; m3 >= 0; m3--) {
        const measurement = measurements[m3];
        if (furthestMeasurementsFound.has(measurement.lane)) {
          continue;
        }
        const previousFurthestMeasurement = furthestMeasurements.get(
          measurement.lane
        );
        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
          furthestMeasurements.set(measurement.lane, measurement);
        } else if (measurement.end < previousFurthestMeasurement.end) {
          furthestMeasurementsFound.set(measurement.lane, true);
        }
        if (furthestMeasurementsFound.size === this.options.lanes) {
          break;
        }
      }
      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a3, b3) => {
        if (a3.end === b3.end) {
          return a3.index - b3.index;
        }
        return a3.end - b3.end;
      })[0] : void 0;
    };
    this.getMeasurements = memo(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count: count2, paddingStart, scrollMargin, getItemKey }, itemSizeCache) => {
        const min2 = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const measurements = this.measurementsCache.slice(0, min2);
        for (let i2 = min2; i2 < count2; i2++) {
          const key = getItemKey(i2);
          const furthestMeasurement = this.options.lanes === 1 ? measurements[i2 - 1] : this.getFurthestMeasurement(measurements, i2);
          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;
          const measuredSize = itemSizeCache.get(key);
          const size2 = typeof measuredSize === "number" ? measuredSize : this.options.estimateSize(i2);
          const end = start + size2;
          const lane = furthestMeasurement ? furthestMeasurement.lane : i2 % this.options.lanes;
          measurements[i2] = {
            index: i2,
            start,
            size: size2,
            end,
            key,
            lane
          };
        }
        this.measurementsCache = measurements;
        return measurements;
      },
      {
        key: false,
        debug: () => this.options.debug
      }
    );
    this.calculateRange = memo(
      () => [this.getMeasurements(), this.getSize(), this.scrollOffset],
      (measurements, outerSize, scrollOffset) => {
        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({
          measurements,
          outerSize,
          scrollOffset
        }) : null;
      },
      {
        key: false,
        debug: () => this.options.debug
      }
    );
    this.getIndexes = memo(
      () => [
        this.options.rangeExtractor,
        this.calculateRange(),
        this.options.overscan,
        this.options.count
      ],
      (rangeExtractor, range, overscan, count2) => {
        return range === null ? [] : rangeExtractor({
          startIndex: range.startIndex,
          endIndex: range.endIndex,
          overscan,
          count: count2
        });
      },
      {
        key: false,
        debug: () => this.options.debug
      }
    );
    this.indexFromElement = (node) => {
      const attributeName = this.options.indexAttribute;
      const indexStr = node.getAttribute(attributeName);
      if (!indexStr) {
        console.warn(
          `Missing attribute name '${attributeName}={index}' on measured element.`
        );
        return -1;
      }
      return parseInt(indexStr, 10);
    };
    this._measureElement = (node, entry) => {
      const item = this.measurementsCache[this.indexFromElement(node)];
      if (!item || !node.isConnected) {
        this.measureElementCache.forEach((cached, key) => {
          if (cached === node) {
            this.observer.unobserve(node);
            this.measureElementCache.delete(key);
          }
        });
        return;
      }
      const prevNode = this.measureElementCache.get(item.key);
      if (prevNode !== node) {
        if (prevNode) {
          this.observer.unobserve(prevNode);
        }
        this.observer.observe(node);
        this.measureElementCache.set(item.key, node);
      }
      const measuredItemSize = this.options.measureElement(node, entry, this);
      this.resizeItem(item, measuredItemSize);
    };
    this.resizeItem = (item, size2) => {
      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;
      const delta = size2 - itemSize;
      if (delta !== 0) {
        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.scrollOffset + this.scrollAdjustments) {
          this._scrollToOffset(this.scrollOffset, {
            adjustments: this.scrollAdjustments += delta,
            behavior: void 0
          });
        }
        this.pendingMeasuredCacheIndexes.push(item.index);
        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size2));
        this.notify(true, false);
      }
    };
    this.measureElement = (node) => {
      if (!node) {
        return;
      }
      this._measureElement(node, void 0);
    };
    this.getVirtualItems = memo(
      () => [this.getIndexes(), this.getMeasurements()],
      (indexes, measurements) => {
        const virtualItems = [];
        for (let k2 = 0, len = indexes.length; k2 < len; k2++) {
          const i2 = indexes[k2];
          const measurement = measurements[i2];
          virtualItems.push(measurement);
        }
        return virtualItems;
      },
      {
        key: false,
        debug: () => this.options.debug
      }
    );
    this.getVirtualItemForOffset = (offset2) => {
      const measurements = this.getMeasurements();
      return notUndefined(
        measurements[findNearestBinarySearch(
          0,
          measurements.length - 1,
          (index2) => notUndefined(measurements[index2]).start,
          offset2
        )]
      );
    };
    this.getOffsetForAlignment = (toOffset, align) => {
      const size2 = this.getSize();
      if (align === "auto") {
        if (toOffset <= this.scrollOffset) {
          align = "start";
        } else if (toOffset >= this.scrollOffset + size2) {
          align = "end";
        } else {
          align = "start";
        }
      }
      if (align === "start") {
        toOffset = toOffset;
      } else if (align === "end") {
        toOffset = toOffset - size2;
      } else if (align === "center") {
        toOffset = toOffset - size2 / 2;
      }
      const scrollSizeProp = this.options.horizontal ? "scrollWidth" : "scrollHeight";
      const scrollSize = this.scrollElement ? "document" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;
      const maxOffset = scrollSize - this.getSize();
      return Math.max(Math.min(maxOffset, toOffset), 0);
    };
    this.getOffsetForIndex = (index2, align = "auto") => {
      index2 = Math.max(0, Math.min(index2, this.options.count - 1));
      const measurement = notUndefined(this.getMeasurements()[index2]);
      if (align === "auto") {
        if (measurement.end >= this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd) {
          align = "end";
        } else if (measurement.start <= this.scrollOffset + this.options.scrollPaddingStart) {
          align = "start";
        } else {
          return [this.scrollOffset, align];
        }
      }
      const toOffset = align === "end" ? measurement.end + this.options.scrollPaddingEnd : measurement.start - this.options.scrollPaddingStart;
      return [this.getOffsetForAlignment(toOffset, align), align];
    };
    this.isDynamicMode = () => this.measureElementCache.size > 0;
    this.cancelScrollToIndex = () => {
      if (this.scrollToIndexTimeoutId !== null) {
        clearTimeout(this.scrollToIndexTimeoutId);
        this.scrollToIndexTimeoutId = null;
      }
    };
    this.scrollToOffset = (toOffset, { align = "start", behavior } = {}) => {
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {
        adjustments: void 0,
        behavior
      });
    };
    this.scrollToIndex = (index2, { align: initialAlign = "auto", behavior } = {}) => {
      index2 = Math.max(0, Math.min(index2, this.options.count - 1));
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      const [toOffset, align] = this.getOffsetForIndex(index2, initialAlign);
      this._scrollToOffset(toOffset, { adjustments: void 0, behavior });
      if (behavior !== "smooth" && this.isDynamicMode()) {
        this.scrollToIndexTimeoutId = setTimeout(() => {
          this.scrollToIndexTimeoutId = null;
          const elementInDOM = this.measureElementCache.has(
            this.options.getItemKey(index2)
          );
          if (elementInDOM) {
            const [toOffset2] = this.getOffsetForIndex(index2, align);
            if (!approxEqual(toOffset2, this.scrollOffset)) {
              this.scrollToIndex(index2, { align, behavior });
            }
          } else {
            this.scrollToIndex(index2, { align, behavior });
          }
        });
      }
    };
    this.scrollBy = (delta, { behavior } = {}) => {
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.scrollOffset + delta, {
        adjustments: void 0,
        behavior
      });
    };
    this.getTotalSize = () => {
      var _a;
      const measurements = this.getMeasurements();
      let end;
      if (measurements.length === 0) {
        end = this.options.paddingStart;
      } else {
        end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(
          ...measurements.slice(-this.options.lanes).map((m3) => m3.end)
        );
      }
      return end - this.options.scrollMargin + this.options.paddingEnd;
    };
    this._scrollToOffset = (offset2, {
      adjustments,
      behavior
    }) => {
      this.options.scrollToFn(offset2, { behavior, adjustments }, this);
    };
    this.measure = () => {
      var _a, _b;
      this.itemSizeCache = /* @__PURE__ */ new Map();
      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, false);
    };
    this.setOptions(opts);
    this.scrollRect = this.options.initialRect;
    this.scrollOffset = typeof this.options.initialOffset === "function" ? this.options.initialOffset() : this.options.initialOffset;
    this.measurementsCache = this.options.initialMeasurementsCache;
    this.measurementsCache.forEach((item) => {
      this.itemSizeCache.set(item.key, item.size);
    });
    this.notify(false, false);
  }
}
const findNearestBinarySearch = (low, high, getCurrentValue, value) => {
  while (low <= high) {
    const middle = (low + high) / 2 | 0;
    const currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange({
  measurements,
  outerSize,
  scrollOffset
}) {
  const count2 = measurements.length - 1;
  const getOffset = (index2) => measurements[index2].start;
  const startIndex = findNearestBinarySearch(0, count2, getOffset, scrollOffset);
  let endIndex = startIndex;
  while (endIndex < count2 && measurements[endIndex].end < scrollOffset + outerSize) {
    endIndex++;
  }
  return { startIndex, endIndex };
}
const useIsomorphicLayoutEffect = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useVirtualizerBase(options) {
  const rerender = reactExports.useReducer(() => ({}), {})[1];
  const resolvedOptions = {
    ...options,
    onChange: (instance2, sync) => {
      var _a;
      if (sync) {
        reactDomExports.flushSync(rerender);
      } else {
        rerender();
      }
      (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);
    }
  };
  const [instance] = reactExports.useState(
    () => new Virtualizer(resolvedOptions)
  );
  instance.setOptions(resolvedOptions);
  reactExports.useEffect(() => {
    return instance._didMount();
  }, []);
  useIsomorphicLayoutEffect(() => {
    return instance._willUpdate();
  });
  return instance;
}
function useVirtualizer(options) {
  return useVirtualizerBase({
    observeElementRect,
    observeElementOffset,
    scrollToFn: elementScroll,
    ...options
  });
}
function l$4(e2, r4) {
  return e2 !== null && r4 !== null && typeof e2 == "object" && typeof r4 == "object" && "id" in e2 && "id" in r4 ? e2.id === r4.id : e2 === r4;
}
function u$6(e2 = l$4) {
  return reactExports.useCallback((r4, t2) => {
    if (typeof e2 == "string") {
      let o3 = e2;
      return (r4 == null ? void 0 : r4[o3]) === (t2 == null ? void 0 : t2[o3]);
    }
    return e2(r4, t2);
  }, [e2]);
}
function s$5(e2) {
  if (e2 === null)
    return { width: 0, height: 0 };
  let { width: n3, height: t2 } = e2.getBoundingClientRect();
  return { width: n3, height: t2 };
}
function f$5(e2, n3 = false) {
  let t2 = e2 === null ? null : "current" in e2 ? e2.current : e2, [l2, u3] = reactExports.useReducer(() => ({}), {}), r4 = reactExports.useMemo(() => s$5(t2), [t2, l2]);
  return n$3(() => {
    if (!t2)
      return;
    let i2 = new ResizeObserver(u3);
    return i2.observe(t2), () => {
      i2.disconnect();
    };
  }, [t2]), n3 ? { width: `${r4.width}px`, height: `${r4.height}px` } : r4;
}
function m$4() {
  let e2 = p$2();
  return o$7((o3) => {
    e2.dispose(), e2.nextFrame(o3);
  });
}
function f$4(l2) {
  let n3 = reactExports.useRef({ value: "", selectionStart: null, selectionEnd: null });
  return E$1(l2.current, "blur", (e2) => {
    let t2 = e2.target;
    t2 instanceof HTMLInputElement && (n3.current = { value: t2.value, selectionStart: t2.selectionStart, selectionEnd: t2.selectionEnd });
  }), o$7(() => {
    let e2 = l2.current;
    if (document.activeElement !== e2 && e2 instanceof HTMLInputElement && e2.isConnected) {
      if (e2.focus({ preventScroll: true }), e2.value !== n3.current.value)
        e2.setSelectionRange(e2.value.length, e2.value.length);
      else {
        let { selectionStart: t2, selectionEnd: u3 } = n3.current;
        t2 !== null && u3 !== null && e2.setSelectionRange(t2, u3);
      }
      n3.current = { value: "", selectionStart: null, selectionEnd: null };
    }
  });
}
function t$2(e2) {
  return [e2.screenX, e2.screenY];
}
function u$5() {
  let e2 = reactExports.useRef([-1, -1]);
  return { wasMoved(r4) {
    let n3 = t$2(r4);
    return e2.current[0] === n3[0] && e2.current[1] === n3[1] ? false : (e2.current = n3, true);
  }, update(r4) {
    e2.current = t$2(r4);
  } };
}
function F$4({ container: e2, accept: t2, walk: r4, enabled: c4 = true }) {
  let o3 = reactExports.useRef(t2), l2 = reactExports.useRef(r4);
  reactExports.useEffect(() => {
    o3.current = t2, l2.current = r4;
  }, [t2, r4]), n$3(() => {
    if (!e2 || !c4)
      return;
    let n3 = u$8(e2);
    if (!n3)
      return;
    let f2 = o3.current, p2 = l2.current, d4 = Object.assign((i2) => f2(i2), { acceptNode: f2 }), u3 = n3.createTreeWalker(e2, NodeFilter.SHOW_ELEMENT, d4, false);
    for (; u3.nextNode(); )
      p2(u3.currentNode);
  }, [e2, c4, o3, l2]);
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref) => {
      let {
        brand,
        version
      } = _ref;
      return brand + "/" + version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y3
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y3,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y3 = nextY != null ? nextY : y3;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y3
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x: x2,
    y: y3,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow$1(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y3,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x2,
    y: y3
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d4) => d4.overflows[0] <= 0).sort((a3, b3) => a3.overflows[1] - b3.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d4) => [d4.placement, d4.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a3, b3) => a3[1] - b3[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y3,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y3 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y3,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y4
            } = _ref;
            return {
              x: x3,
              y: y4
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y3
      };
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y3
        }
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y3 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y3 || !Number.isFinite(y3)) {
    y3 = 1;
  }
  return {
    x: x2,
    y: y3
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y3 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y3 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y3 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y3
  });
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (e2) {
      return false;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y3 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y3
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y3
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y3 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y3
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result2 = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result2 = result2.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result2);
  return result2;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x2 = rect.left + scroll.scrollLeft - offsets.x;
  const y3 = rect.top + scroll.scrollTop - offsets.y;
  return {
    x: x2,
    y: y3,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io2 = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io2) == null || _io.disconnect();
    io2 = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io2 = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e2) {
      io2 = new IntersectionObserver(handleObserve, options);
    }
    io2.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const detectOverflow = detectOverflow$1;
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index$1 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual(a3, b3) {
  if (a3 === b3) {
    return true;
  }
  if (typeof a3 !== typeof b3) {
    return false;
  }
  if (typeof a3 === "function" && a3.toString() === b3.toString()) {
    return true;
  }
  let length;
  let i2;
  let keys;
  if (a3 && b3 && typeof a3 === "object") {
    if (Array.isArray(a3)) {
      length = a3.length;
      if (length !== b3.length)
        return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual(a3[i2], b3[i2])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a3);
    length = keys.length;
    if (length !== Object.keys(b3).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b3, keys[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys[i2];
      if (key === "_owner" && a3.$$typeof) {
        continue;
      }
      if (!deepEqual(a3[key], b3[key])) {
        return false;
      }
    }
    return true;
  }
  return a3 !== a3 && b3 !== b3;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index$1(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index$1(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$1(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y3 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y3 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y3
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const SafeReact = {
  ...React$1
};
const useInsertionEffect = SafeReact.useInsertionEffect;
const useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = reactExports.useRef(() => {
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return reactExports.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var index = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
let serverHandoffComplete = false;
let count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id, setId] = reactExports.useState(() => serverHandoffComplete ? genId() : void 0);
  index(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  reactExports.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id;
}
const useReactId = SafeReact.useId;
const useId = useReactId || useFloatingId;
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l2) => l2 !== listener)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ reactExports.createContext(null);
const FloatingTreeContext = /* @__PURE__ */ reactExports.createContext(null);
const useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = reactExports.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
const useFloatingTree = () => reactExports.useContext(FloatingTreeContext);
function useFloatingRootContext(options) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId();
  const dataRef = reactExports.useRef({});
  const [events] = reactExports.useState(() => createPubSub());
  const nested = useFloatingParentNodeId() != null;
  const [positionReference, setPositionReference] = reactExports.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0;
    events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = reactExports.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = reactExports.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return reactExports.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = reactExports.useState(null);
  const [positionReference, _setPositionReference] = reactExports.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.reference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = reactExports.useRef(null);
  const tree = useFloatingTree();
  index(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position = useFloating$1({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = reactExports.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference);
    position.refs.setReference(computedPositionReference);
  }, [position.refs]);
  const setReference = reactExports.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = reactExports.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = reactExports.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const context = reactExports.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  index(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return reactExports.useMemo(() => ({
    ...position,
    context,
    refs,
    elements
  }), [position, refs, elements, context]);
}
const ACTIVE_KEY = "active";
const SELECTED_KEY = "selected";
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _3,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map.get(key)) == null || _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const deps = propsList;
  const getReferenceProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  const getFloatingProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  const getItemProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // Granularly check for `item` changes, because the `getItemProps` getter
    // should be as referentially stable as possible since it may be passed as
    // a prop to many components. All `item` key values must therefore be
    // memoized.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    propsList.map((key) => key == null ? void 0 : key.item)
  );
  return reactExports.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
function getArgsWithCustomFloatingHeight(state, height) {
  return {
    ...state,
    rects: {
      ...state.rects,
      floating: {
        ...state.rects.floating,
        height
      }
    }
  };
}
const inner = (props) => ({
  name: "inner",
  options: props,
  async fn(state) {
    const {
      listRef,
      overflowRef,
      onFallbackChange,
      offset: innerOffset = 0,
      index: index2 = 0,
      minItemsVisible = 4,
      referenceOverflowThreshold = 0,
      scrollRef,
      ...detectOverflowOptions
    } = props;
    const {
      rects,
      elements: {
        floating
      }
    } = state;
    const item = listRef.current[index2];
    if (!item) {
      return {};
    }
    const nextArgs = {
      ...state,
      ...await offset(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)
    };
    const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;
    const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);
    const refOverflow = await detectOverflow(nextArgs, {
      ...detectOverflowOptions,
      elementContext: "reference"
    });
    const diffY = Math.max(0, overflow.top);
    const nextY = nextArgs.y + diffY;
    const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));
    el.style.maxHeight = maxHeight + "px";
    el.scrollTop = diffY;
    if (onFallbackChange) {
      if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {
        reactDomExports.flushSync(() => onFallbackChange(true));
      } else {
        reactDomExports.flushSync(() => onFallbackChange(false));
      }
    }
    if (overflowRef) {
      overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({
        ...nextArgs,
        y: nextY
      }, el.offsetHeight), detectOverflowOptions);
    }
    return {
      y: nextY
    };
  }
});
function useInnerOffset(context, props) {
  const {
    open,
    elements
  } = context;
  const {
    enabled = true,
    overflowRef,
    scrollRef,
    onChange: unstable_onChange
  } = props;
  const onChange2 = useEffectEvent(unstable_onChange);
  const controlledScrollingRef = reactExports.useRef(false);
  const prevScrollTopRef = reactExports.useRef(null);
  const initialOverflowRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!enabled) {
      return;
    }
    function onWheel(e2) {
      if (e2.ctrlKey || !el || overflowRef.current == null) {
        return;
      }
      const dY = e2.deltaY;
      const isAtTop = overflowRef.current.top >= -0.5;
      const isAtBottom = overflowRef.current.bottom >= -0.5;
      const remainingScroll = el.scrollHeight - el.clientHeight;
      const sign = dY < 0 ? -1 : 1;
      const method = dY < 0 ? "max" : "min";
      if (el.scrollHeight <= el.clientHeight) {
        return;
      }
      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {
        e2.preventDefault();
        reactDomExports.flushSync(() => {
          onChange2((d4) => d4 + Math[method](dY, remainingScroll * sign));
        });
      } else if (/firefox/i.test(getUserAgent())) {
        el.scrollTop += dY;
      }
    }
    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
    if (open && el) {
      el.addEventListener("wheel", onWheel);
      requestAnimationFrame(() => {
        prevScrollTopRef.current = el.scrollTop;
        if (overflowRef.current != null) {
          initialOverflowRef.current = {
            ...overflowRef.current
          };
        }
      });
      return () => {
        prevScrollTopRef.current = null;
        initialOverflowRef.current = null;
        el.removeEventListener("wheel", onWheel);
      };
    }
  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange2]);
  return reactExports.useMemo(() => {
    if (!enabled) {
      return {};
    }
    return {
      floating: {
        onKeyDown() {
          controlledScrollingRef.current = true;
        },
        onWheel() {
          controlledScrollingRef.current = false;
        },
        onPointerMove() {
          controlledScrollingRef.current = false;
        },
        onScroll() {
          const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
          if (!overflowRef.current || !el || !controlledScrollingRef.current) {
            return;
          }
          if (prevScrollTopRef.current !== null) {
            const scrollDiff = el.scrollTop - prevScrollTopRef.current;
            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {
              reactDomExports.flushSync(() => onChange2((d4) => d4 + scrollDiff));
            }
          }
          requestAnimationFrame(() => {
            prevScrollTopRef.current = el.scrollTop;
          });
        }
      }
    };
  }, [enabled, overflowRef, elements.floating, scrollRef, onChange2]);
}
let y$3 = reactExports.createContext({ styles: void 0, setReference: () => {
}, setFloating: () => {
}, getReferenceProps: () => ({}), getFloatingProps: () => ({}), slot: {} });
y$3.displayName = "FloatingContext";
let S$2 = reactExports.createContext(null);
S$2.displayName = "PlacementContext";
function xe$1(e2) {
  return reactExports.useMemo(() => e2 ? typeof e2 == "string" ? { to: e2 } : e2 : null, [e2]);
}
function ye$2() {
  return reactExports.useContext(y$3).setReference;
}
function be$2() {
  let { getFloatingProps: e2, slot: t2 } = reactExports.useContext(y$3);
  return reactExports.useCallback((...n3) => Object.assign({}, e2(...n3), { "data-anchor": t2.anchor }), [e2, t2]);
}
function Re$2(e2 = null) {
  e2 === false && (e2 = null), typeof e2 == "string" && (e2 = { to: e2 });
  let t2 = reactExports.useContext(S$2), n3 = reactExports.useMemo(() => e2, [JSON.stringify(e2, typeof HTMLElement != "undefined" ? (a3, r4) => r4 instanceof HTMLElement ? r4.outerHTML : r4 : void 0)]);
  n$3(() => {
    t2 == null || t2(n3 != null ? n3 : null);
  }, [t2, n3]);
  let l2 = reactExports.useContext(y$3);
  return reactExports.useMemo(() => [l2.setFloating, e2 ? l2.styles : {}], [l2.setFloating, e2, l2.styles]);
}
let q$2 = 4;
function ve$1({ children: e2, enabled: t2 = true }) {
  let [n3, l2] = reactExports.useState(null), [a3, r4] = reactExports.useState(0), c4 = reactExports.useRef(null), [u3, i2] = reactExports.useState(null);
  pe$2(u3);
  let o3 = t2 && n3 !== null && u3 !== null, { to: F2 = "bottom", gap: C2 = 0, offset: M2 = 0, padding: p2 = 0, inner: P3 } = ce$1(n3, u3), [s4, f2 = "center"] = F2.split(" ");
  n$3(() => {
    o3 && r4(0);
  }, [o3]);
  let { refs: b3, floatingStyles: $2, context: g2 } = useFloating({ open: o3, placement: s4 === "selection" ? f2 === "center" ? "bottom" : `bottom-${f2}` : f2 === "center" ? `${s4}` : `${s4}-${f2}`, strategy: "absolute", transform: false, middleware: [offset({ mainAxis: s4 === "selection" ? 0 : C2, crossAxis: M2 }), shift({ padding: p2 }), s4 !== "selection" && flip({ padding: p2 }), s4 === "selection" && P3 ? inner({ ...P3, padding: p2, overflowRef: c4, offset: a3, minItemsVisible: q$2, referenceOverflowThreshold: p2, onFallbackChange(h2) {
    var W2, k2;
    if (!h2)
      return;
    let d4 = g2.elements.floating;
    if (!d4)
      return;
    let T2 = parseFloat(getComputedStyle(d4).scrollPaddingBottom) || 0, w2 = Math.min(q$2, d4.childElementCount), B2 = 0, O2 = 0;
    for (let m3 of (k2 = (W2 = g2.elements.floating) == null ? void 0 : W2.childNodes) != null ? k2 : [])
      if (m3 instanceof HTMLElement) {
        let x2 = m3.offsetTop, N2 = x2 + m3.clientHeight + T2, H2 = d4.scrollTop, U2 = H2 + d4.clientHeight;
        if (x2 >= H2 && N2 <= U2)
          w2--;
        else {
          O2 = Math.max(0, Math.min(N2, U2) - Math.max(x2, H2)), B2 = m3.clientHeight;
          break;
        }
      }
    w2 >= 1 && r4((m3) => {
      let x2 = B2 * w2 - O2 + T2;
      return m3 >= x2 ? m3 : x2;
    });
  } }) : null, size({ padding: p2, apply({ availableWidth: h2, availableHeight: d4, elements: T2 }) {
    Object.assign(T2.floating.style, { overflow: "auto", maxWidth: `${h2}px`, maxHeight: `min(var(--anchor-max-height, 100vh), ${d4}px)` });
  } })].filter(Boolean), whileElementsMounted: autoUpdate }), [I4 = s4, V2 = f2] = g2.placement.split("-");
  s4 === "selection" && (I4 = "selection");
  let G2 = reactExports.useMemo(() => ({ anchor: [I4, V2].filter(Boolean).join(" ") }), [I4, V2]), K2 = useInnerOffset(g2, { overflowRef: c4, onChange: r4 }), { getReferenceProps: Q2, getFloatingProps: X2 } = useInteractions([K2]), Y2 = o$7((h2) => {
    i2(h2), b3.setFloating(h2);
  });
  return reactExports.createElement(S$2.Provider, { value: l2 }, reactExports.createElement(y$3.Provider, { value: { setFloating: Y2, setReference: b3.setReference, styles: $2, getReferenceProps: Q2, getFloatingProps: X2, slot: G2 } }, e2));
}
function pe$2(e2) {
  n$3(() => {
    if (!e2)
      return;
    let t2 = new MutationObserver(() => {
      let n3 = e2.style.maxHeight;
      parseFloat(n3) !== parseInt(n3) && (e2.style.maxHeight = `${Math.ceil(parseFloat(n3))}px`);
    });
    return t2.observe(e2, { attributes: true, attributeFilter: ["style"] }), () => {
      t2.disconnect();
    };
  }, [e2]);
}
function ce$1(e2, t2) {
  var r4, c4, u3;
  let n3 = L$3((r4 = e2 == null ? void 0 : e2.gap) != null ? r4 : "var(--anchor-gap, 0)", t2), l2 = L$3((c4 = e2 == null ? void 0 : e2.offset) != null ? c4 : "var(--anchor-offset, 0)", t2), a3 = L$3((u3 = e2 == null ? void 0 : e2.padding) != null ? u3 : "var(--anchor-padding, 0)", t2);
  return { ...e2, gap: n3, offset: l2, padding: a3 };
}
function L$3(e2, t2, n3 = void 0) {
  let l2 = p$2(), a3 = o$7((i2, o3) => {
    if (i2 == null)
      return [n3, null];
    if (typeof i2 == "number")
      return [i2, null];
    if (typeof i2 == "string") {
      if (!o3)
        return [n3, null];
      let F2 = J$1(i2, o3);
      return [F2, (C2) => {
        let M2 = D$3(i2);
        {
          let p2 = M2.map((P3) => window.getComputedStyle(o3).getPropertyValue(P3));
          l2.requestAnimationFrame(function P3() {
            l2.nextFrame(P3);
            let s4 = false;
            for (let [b3, $2] of M2.entries()) {
              let g2 = window.getComputedStyle(o3).getPropertyValue($2);
              if (p2[b3] !== g2) {
                p2[b3] = g2, s4 = true;
                break;
              }
            }
            if (!s4)
              return;
            let f2 = J$1(i2, o3);
            F2 !== f2 && (C2(f2), F2 = f2);
          });
        }
        return l2.dispose;
      }];
    }
    return [n3, null];
  }), r4 = reactExports.useMemo(() => a3(e2, t2)[0], [e2, t2]), [c4 = r4, u3] = reactExports.useState();
  return n$3(() => {
    let [i2, o3] = a3(e2, t2);
    if (u3(i2), !!o3)
      return o3(u3);
  }, [e2, t2]), c4;
}
function D$3(e2) {
  let t2 = /var\((.*)\)/.exec(e2);
  if (t2) {
    let n3 = t2[1].indexOf(",");
    if (n3 === -1)
      return [t2[1]];
    let l2 = t2[1].slice(0, n3).trim(), a3 = t2[1].slice(n3 + 1).trim();
    return a3 ? [l2, ...D$3(a3)] : [l2];
  }
  return [];
}
function J$1(e2, t2) {
  let n3 = document.createElement("div");
  t2.appendChild(n3), n3.style.setProperty("margin-top", "0px", "important"), n3.style.setProperty("margin-top", e2, "important");
  let l2 = parseFloat(window.getComputedStyle(n3).marginTop) || 0;
  return t2.removeChild(n3), l2;
}
function u$4(l2) {
  throw new Error("Unexpected object: " + l2);
}
var c$6 = ((i2) => (i2[i2.First = 0] = "First", i2[i2.Previous = 1] = "Previous", i2[i2.Next = 2] = "Next", i2[i2.Last = 3] = "Last", i2[i2.Specific = 4] = "Specific", i2[i2.Nothing = 5] = "Nothing", i2))(c$6 || {});
function f$3(l2, n3) {
  let t2 = n3.resolveItems();
  if (t2.length <= 0)
    return null;
  let r4 = n3.resolveActiveIndex(), s4 = r4 != null ? r4 : -1;
  switch (l2.focus) {
    case 0: {
      for (let e2 = 0; e2 < t2.length; ++e2)
        if (!n3.resolveDisabled(t2[e2], e2, t2))
          return e2;
      return r4;
    }
    case 1: {
      s4 === -1 && (s4 = t2.length);
      for (let e2 = s4 - 1; e2 >= 0; --e2)
        if (!n3.resolveDisabled(t2[e2], e2, t2))
          return e2;
      return r4;
    }
    case 2: {
      for (let e2 = s4 + 1; e2 < t2.length; ++e2)
        if (!n3.resolveDisabled(t2[e2], e2, t2))
          return e2;
      return r4;
    }
    case 3: {
      for (let e2 = t2.length - 1; e2 >= 0; --e2)
        if (!n3.resolveDisabled(t2[e2], e2, t2))
          return e2;
      return r4;
    }
    case 4: {
      for (let e2 = 0; e2 < t2.length; ++e2)
        if (n3.resolveId(t2[e2], e2, t2) === l2.id)
          return e2;
      return r4;
    }
    case 5:
      return null;
    default:
      u$4(l2);
  }
}
var g$4 = ((f2) => (f2[f2.Left = 0] = "Left", f2[f2.Right = 2] = "Right", f2))(g$4 || {});
var xo$1 = ((e2) => (e2[e2.Open = 0] = "Open", e2[e2.Closed = 1] = "Closed", e2))(xo$1 || {}), To$1 = ((e2) => (e2[e2.Single = 0] = "Single", e2[e2.Multi = 1] = "Multi", e2))(To$1 || {}), go$1 = ((t2) => (t2[t2.Pointer = 0] = "Pointer", t2[t2.Focus = 1] = "Focus", t2[t2.Other = 2] = "Other", t2))(go$1 || {}), vo$1 = ((i2) => (i2[i2.OpenCombobox = 0] = "OpenCombobox", i2[i2.CloseCombobox = 1] = "CloseCombobox", i2[i2.GoToOption = 2] = "GoToOption", i2[i2.RegisterOption = 3] = "RegisterOption", i2[i2.UnregisterOption = 4] = "UnregisterOption", i2[i2.SetActivationTrigger = 5] = "SetActivationTrigger", i2[i2.UpdateVirtualConfiguration = 6] = "UpdateVirtualConfiguration", i2))(vo$1 || {});
function Te$2(o3, r4 = (e2) => e2) {
  let e2 = o3.activeOptionIndex !== null ? o3.options[o3.activeOptionIndex] : null, t2 = r4(o3.options.slice()), c4 = t2.length > 0 && t2[0].dataRef.current.order !== null ? t2.sort((d4, i2) => d4.dataRef.current.order - i2.dataRef.current.order) : _$3(t2, (d4) => d4.dataRef.current.domRef.current), s4 = e2 ? c4.indexOf(e2) : null;
  return s4 === -1 && (s4 = null), { options: c4, activeOptionIndex: s4 };
}
let Oo$1 = { [1](o3) {
  var r4;
  return (r4 = o3.dataRef.current) != null && r4.disabled || o3.comboboxState === 1 ? o3 : { ...o3, activeOptionIndex: null, comboboxState: 1, activationTrigger: 2, __demoMode: false };
}, [0](o3) {
  var r4, e2;
  if ((r4 = o3.dataRef.current) != null && r4.disabled || o3.comboboxState === 0)
    return o3;
  if ((e2 = o3.dataRef.current) != null && e2.value) {
    let t2 = o3.dataRef.current.calculateIndex(o3.dataRef.current.value);
    if (t2 !== -1)
      return { ...o3, activeOptionIndex: t2, comboboxState: 0, __demoMode: false };
  }
  return { ...o3, comboboxState: 0, __demoMode: false };
}, [2](o3, r4) {
  var s4, d4, i2, m3, n3;
  if ((s4 = o3.dataRef.current) != null && s4.disabled || (d4 = o3.dataRef.current) != null && d4.optionsRef.current && !((i2 = o3.dataRef.current) != null && i2.optionsPropsRef.current.static) && o3.comboboxState === 1)
    return o3;
  if (o3.virtual) {
    let { options: p2, disabled: f2 } = o3.virtual, _3 = r4.focus === c$6.Specific ? r4.idx : f$3(r4, { resolveItems: () => p2, resolveActiveIndex: () => {
      var u3, x2;
      return (x2 = (u3 = o3.activeOptionIndex) != null ? u3 : p2.findIndex((V2) => !f2(V2))) != null ? x2 : null;
    }, resolveDisabled: f2, resolveId() {
      throw new Error("Function not implemented.");
    } }), F2 = (m3 = r4.trigger) != null ? m3 : 2;
    return o3.activeOptionIndex === _3 && o3.activationTrigger === F2 ? o3 : { ...o3, activeOptionIndex: _3, activationTrigger: F2, __demoMode: false };
  }
  let e2 = Te$2(o3);
  if (e2.activeOptionIndex === null) {
    let p2 = e2.options.findIndex((f2) => !f2.dataRef.current.disabled);
    p2 !== -1 && (e2.activeOptionIndex = p2);
  }
  let t2 = r4.focus === c$6.Specific ? r4.idx : f$3(r4, { resolveItems: () => e2.options, resolveActiveIndex: () => e2.activeOptionIndex, resolveId: (p2) => p2.id, resolveDisabled: (p2) => p2.dataRef.current.disabled }), c4 = (n3 = r4.trigger) != null ? n3 : 2;
  return o3.activeOptionIndex === t2 && o3.activationTrigger === c4 ? o3 : { ...o3, ...e2, activeOptionIndex: t2, activationTrigger: c4, __demoMode: false };
}, [3]: (o3, r4) => {
  var s4, d4, i2;
  if ((s4 = o3.dataRef.current) != null && s4.virtual)
    return { ...o3, options: [...o3.options, r4.payload] };
  let e2 = r4.payload, t2 = Te$2(o3, (m3) => (m3.push(e2), m3));
  o3.activeOptionIndex === null && (d4 = o3.dataRef.current) != null && d4.isSelected(r4.payload.dataRef.current.value) && (t2.activeOptionIndex = t2.options.indexOf(e2));
  let c4 = { ...o3, ...t2, activationTrigger: 2 };
  return (i2 = o3.dataRef.current) != null && i2.__demoMode && o3.dataRef.current.value === void 0 && (c4.activeOptionIndex = 0), c4;
}, [4]: (o3, r4) => {
  var t2;
  if ((t2 = o3.dataRef.current) != null && t2.virtual)
    return { ...o3, options: o3.options.filter((c4) => c4.id !== r4.id) };
  let e2 = Te$2(o3, (c4) => {
    let s4 = c4.findIndex((d4) => d4.id === r4.id);
    return s4 !== -1 && c4.splice(s4, 1), c4;
  });
  return { ...o3, ...e2, activationTrigger: 2 };
}, [5]: (o3, r4) => o3.activationTrigger === r4.trigger ? o3 : { ...o3, activationTrigger: r4.trigger }, [6]: (o3, r4) => {
  var t2, c4;
  if (o3.virtual === null)
    return { ...o3, virtual: { options: r4.options, disabled: (t2 = r4.disabled) != null ? t2 : () => false } };
  if (o3.virtual.options === r4.options && o3.virtual.disabled === r4.disabled)
    return o3;
  let e2 = o3.activeOptionIndex;
  if (o3.activeOptionIndex !== null) {
    let s4 = r4.options.indexOf(o3.virtual.options[o3.activeOptionIndex]);
    s4 !== -1 ? e2 = s4 : e2 = null;
  }
  return { ...o3, activeOptionIndex: e2, virtual: { options: r4.options, disabled: (c4 = r4.disabled) != null ? c4 : () => false } };
} }, ge$2 = reactExports.createContext(null);
ge$2.displayName = "ComboboxActionsContext";
function oe$1(o3) {
  let r4 = reactExports.useContext(ge$2);
  if (r4 === null) {
    let e2 = new Error(`<${o3} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e2, oe$1), e2;
  }
  return r4;
}
let Le$1 = reactExports.createContext(null);
function Co$1(o3) {
  let r4 = Q("VirtualProvider"), { options: e2 } = r4.virtual, [t2, c4] = reactExports.useMemo(() => {
    let n3 = r4.optionsRef.current;
    if (!n3)
      return [0, 0];
    let p2 = window.getComputedStyle(n3);
    return [parseFloat(p2.paddingBlockStart || p2.paddingTop), parseFloat(p2.paddingBlockEnd || p2.paddingBottom)];
  }, [r4.optionsRef.current]), s4 = useVirtualizer({ scrollPaddingStart: t2, scrollPaddingEnd: c4, count: e2.length, estimateSize() {
    return 40;
  }, getScrollElement() {
    var n3;
    return (n3 = r4.optionsRef.current) != null ? n3 : null;
  }, overscan: 12 }), [d4, i2] = reactExports.useState(0);
  n$3(() => {
    i2((n3) => n3 + 1);
  }, [e2]);
  let m3 = s4.getVirtualItems();
  return m3.length === 0 ? null : React.createElement(Le$1.Provider, { value: s4 }, React.createElement("div", { style: { position: "relative", width: "100%", height: `${s4.getTotalSize()}px` }, ref: (n3) => {
    if (n3) {
      if (typeof process != "undefined" && {}.JEST_WORKER_ID !== void 0 || r4.activationTrigger === 0)
        return;
      r4.activeOptionIndex !== null && e2.length > r4.activeOptionIndex && s4.scrollToIndex(r4.activeOptionIndex);
    }
  } }, m3.map((n3) => {
    var p2;
    return React.createElement(reactExports.Fragment, { key: n3.key }, React.cloneElement((p2 = o3.children) == null ? void 0 : p2.call(o3, { option: e2[n3.index], open: r4.comboboxState === 0 }), { key: `${d4}-${n3.key}`, "data-index": n3.index, "aria-setsize": e2.length, "aria-posinset": n3.index + 1, style: { position: "absolute", top: 0, left: 0, transform: `translateY(${n3.start}px)`, overflowAnchor: "none" } }));
  })));
}
let se$1 = reactExports.createContext(null);
se$1.displayName = "ComboboxDataContext";
function Q(o3) {
  let r4 = reactExports.useContext(se$1);
  if (r4 === null) {
    let e2 = new Error(`<${o3} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e2, Q), e2;
  }
  return r4;
}
function yo$1(o3, r4) {
  return u$9(r4.type, Oo$1, o3, r4);
}
let Ro$1 = reactExports.Fragment;
function So$1(o3, r4) {
  var D2, U2;
  let e2 = a$8(), { value: t2, defaultValue: c4, onChange: s4, form: d4, name: i2, by: m3, disabled: n3 = e2 || false, onClose: p2, __demoMode: f2 = false, multiple: _3 = false, immediate: F2 = false, virtual: u3 = null, nullable: x2, ...V2 } = o3, P3 = l$5(c4), [C2 = _3 ? [] : void 0, y3] = T$3(t2, s4, P3), [I4, A2] = reactExports.useReducer(yo$1, { dataRef: reactExports.createRef(), comboboxState: f2 ? 0 : 1, options: [], virtual: u3 ? { options: u3.options, disabled: (D2 = u3.disabled) != null ? D2 : () => false } : null, activeOptionIndex: null, activationTrigger: 2, __demoMode: f2 }), h2 = reactExports.useRef(false), w2 = reactExports.useRef({ static: false, hold: false }), O2 = reactExports.useRef(null), W2 = reactExports.useRef(null), z2 = reactExports.useRef(null), g2 = u$6(m3), $2 = o$7((b3) => u3 ? m3 === null ? u3.options.indexOf(b3) : u3.options.findIndex((v2) => g2(v2, b3)) : I4.options.findIndex((v2) => g2(v2.dataRef.current.value, b3))), X2 = reactExports.useCallback((b3) => u$9(a3.mode, { [1]: () => C2.some((v2) => g2(v2, b3)), [0]: () => g2(C2, b3) }), [C2]), J2 = o$7((b3) => I4.activeOptionIndex === $2(b3)), a3 = reactExports.useMemo(() => ({ ...I4, immediate: F2, optionsPropsRef: w2, inputRef: O2, buttonRef: W2, optionsRef: z2, value: C2, defaultValue: P3, disabled: n3, mode: _3 ? 1 : 0, virtual: u3 ? I4.virtual : null, get activeOptionIndex() {
    if (h2.current && I4.activeOptionIndex === null && (u3 ? u3.options.length > 0 : I4.options.length > 0)) {
      if (u3) {
        let v2 = u3.options.findIndex((N2) => {
          var ae2, ve2;
          return !((ve2 = (ae2 = u3.disabled) == null ? void 0 : ae2.call(u3, N2)) != null && ve2);
        });
        if (v2 !== -1)
          return v2;
      }
      let b3 = I4.options.findIndex((v2) => !v2.dataRef.current.disabled);
      if (b3 !== -1)
        return b3;
    }
    return I4.activeOptionIndex;
  }, calculateIndex: $2, compare: g2, isSelected: X2, isActive: J2 }), [C2, P3, n3, _3, f2, I4, u3]);
  n$3(() => {
    var b3;
    u3 && A2({ type: 6, options: u3.options, disabled: (b3 = u3.disabled) != null ? b3 : null });
  }, [u3, u3 == null ? void 0 : u3.options, u3 == null ? void 0 : u3.disabled]), n$3(() => {
    I4.dataRef.current = a3;
  }, [a3]), w$2([a3.buttonRef, a3.inputRef, a3.optionsRef], () => l2.closeCombobox(), a3.comboboxState === 0);
  let j2 = reactExports.useMemo(() => {
    var b3, v2, N2;
    return { open: a3.comboboxState === 0, disabled: n3, activeIndex: a3.activeOptionIndex, activeOption: a3.activeOptionIndex === null ? null : a3.virtual ? a3.virtual.options[(b3 = a3.activeOptionIndex) != null ? b3 : 0] : (N2 = (v2 = a3.options[a3.activeOptionIndex]) == null ? void 0 : v2.dataRef.current.value) != null ? N2 : null, value: C2 };
  }, [a3, n3, C2]), de2 = o$7(() => {
    if (a3.activeOptionIndex !== null) {
      if (a3.virtual)
        q2(a3.virtual.options[a3.activeOptionIndex]);
      else {
        let { dataRef: b3 } = a3.options[a3.activeOptionIndex];
        q2(b3.current.value);
      }
      l2.goToOption(c$6.Specific, a3.activeOptionIndex);
    }
  }), be2 = o$7(() => {
    A2({ type: 0 }), h2.current = true;
  }), te2 = o$7(() => {
    A2({ type: 1 }), h2.current = false, p2 == null || p2();
  }), ne2 = o$7((b3, v2, N2) => (h2.current = false, b3 === c$6.Specific ? A2({ type: 2, focus: c$6.Specific, idx: v2, trigger: N2 }) : A2({ type: 2, focus: b3, trigger: N2 }))), re2 = o$7((b3, v2) => (A2({ type: 3, payload: { id: b3, dataRef: v2 } }), () => {
    a3.isActive(v2.current.value) && (h2.current = true), A2({ type: 4, id: b3 });
  })), q2 = o$7((b3) => u$9(a3.mode, { [0]() {
    return y3 == null ? void 0 : y3(b3);
  }, [1]() {
    let v2 = a3.value.slice(), N2 = v2.findIndex((ae2) => g2(ae2, b3));
    return N2 === -1 ? v2.push(b3) : v2.splice(N2, 1), y3 == null ? void 0 : y3(v2);
  } })), ie2 = o$7((b3) => {
    A2({ type: 5, trigger: b3 });
  }), l2 = reactExports.useMemo(() => ({ onChange: q2, registerOption: re2, goToOption: ne2, closeCombobox: te2, openCombobox: be2, setActivationTrigger: ie2, selectActiveOption: de2 }), []), [B2, E2] = z$2(), k2 = r4 === null ? {} : { ref: r4 }, R3 = reactExports.useCallback(() => {
    if (P3 !== void 0)
      return y3 == null ? void 0 : y3(P3);
  }, [y3, P3]);
  return React.createElement(E2, { value: B2, props: { htmlFor: (U2 = a3.inputRef.current) == null ? void 0 : U2.id }, slot: { open: a3.comboboxState === 0, disabled: n3 } }, React.createElement(ve$1, null, React.createElement(ge$2.Provider, { value: l2 }, React.createElement(se$1.Provider, { value: a3 }, React.createElement(s$6, { value: u$9(a3.comboboxState, { [0]: d$6.Open, [1]: d$6.Closed }) }, i2 != null && React.createElement(j$3, { disabled: n3, data: C2 != null ? { [i2]: C2 } : {}, form: d4, onReset: R3 }), H$3({ ourProps: k2, theirProps: V2, slot: j2, defaultTag: Ro$1, name: "Combobox" }))))));
}
let Po$1 = "input";
function Io$1(o3, r4) {
  var te2, ne2, re2, q2, ie2;
  let e2 = Q("Combobox.Input"), t2 = oe$1("Combobox.Input"), c4 = reactExports.useId(), s4 = u$7(), { id: d4 = s4 || `headlessui-combobox-input-${c4}`, onChange: i2, displayValue: m3, disabled: n3 = e2.disabled || false, autoFocus: p2 = false, type: f2 = "text", ..._3 } = o3, F2 = y$4(e2.inputRef, r4, ye$2()), u3 = n$4(e2.inputRef), x2 = reactExports.useRef(false), V2 = p$2(), P3 = o$7(() => {
    t2.onChange(null), e2.optionsRef.current && (e2.optionsRef.current.scrollTop = 0), t2.goToOption(c$6.Nothing);
  }), C2 = reactExports.useMemo(() => {
    var l2;
    return typeof m3 == "function" && e2.value !== void 0 ? (l2 = m3(e2.value)) != null ? l2 : "" : typeof e2.value == "string" ? e2.value : "";
  }, [e2.value, m3]);
  m$5(([l2, B2], [E2, k2]) => {
    if (x2.current)
      return;
    let R3 = e2.inputRef.current;
    R3 && ((k2 === 0 && B2 === 1 || l2 !== E2) && (R3.value = l2), requestAnimationFrame(() => {
      if (x2.current || !R3 || (u3 == null ? void 0 : u3.activeElement) !== R3)
        return;
      let { selectionStart: D2, selectionEnd: U2 } = R3;
      Math.abs((U2 != null ? U2 : 0) - (D2 != null ? D2 : 0)) === 0 && D2 === 0 && R3.setSelectionRange(R3.value.length, R3.value.length);
    }));
  }, [C2, e2.comboboxState, u3]), m$5(([l2], [B2]) => {
    if (l2 === 0 && B2 === 1) {
      if (x2.current)
        return;
      let E2 = e2.inputRef.current;
      if (!E2)
        return;
      let k2 = E2.value, { selectionStart: R3, selectionEnd: D2, selectionDirection: U2 } = E2;
      E2.value = "", E2.value = k2, U2 !== null ? E2.setSelectionRange(R3, D2, U2) : E2.setSelectionRange(R3, D2);
    }
  }, [e2.comboboxState]);
  let y3 = reactExports.useRef(false), I4 = o$7(() => {
    y3.current = true;
  }), A2 = o$7(() => {
    V2.nextFrame(() => {
      y3.current = false;
    });
  }), h2 = m$4(), w2 = o$7((l2) => {
    switch (x2.current = true, h2(() => {
      x2.current = false;
    }), l2.key) {
      case o$9.Enter:
        if (x2.current = false, e2.comboboxState !== 0 || y3.current)
          return;
        if (l2.preventDefault(), l2.stopPropagation(), e2.activeOptionIndex === null) {
          t2.closeCombobox();
          return;
        }
        t2.selectActiveOption(), e2.mode === 0 && t2.closeCombobox();
        break;
      case o$9.ArrowDown:
        return x2.current = false, l2.preventDefault(), l2.stopPropagation(), u$9(e2.comboboxState, { [0]: () => t2.goToOption(c$6.Next), [1]: () => t2.openCombobox() });
      case o$9.ArrowUp:
        return x2.current = false, l2.preventDefault(), l2.stopPropagation(), u$9(e2.comboboxState, { [0]: () => t2.goToOption(c$6.Previous), [1]: () => {
          t2.openCombobox(), V2.nextFrame(() => {
            e2.value || t2.goToOption(c$6.Last);
          });
        } });
      case o$9.Home:
        if (l2.shiftKey)
          break;
        return x2.current = false, l2.preventDefault(), l2.stopPropagation(), t2.goToOption(c$6.First);
      case o$9.PageUp:
        return x2.current = false, l2.preventDefault(), l2.stopPropagation(), t2.goToOption(c$6.First);
      case o$9.End:
        if (l2.shiftKey)
          break;
        return x2.current = false, l2.preventDefault(), l2.stopPropagation(), t2.goToOption(c$6.Last);
      case o$9.PageDown:
        return x2.current = false, l2.preventDefault(), l2.stopPropagation(), t2.goToOption(c$6.Last);
      case o$9.Escape:
        return x2.current = false, e2.comboboxState !== 0 ? void 0 : (l2.preventDefault(), e2.optionsRef.current && !e2.optionsPropsRef.current.static && l2.stopPropagation(), e2.mode === 0 && e2.value === null && P3(), t2.closeCombobox());
      case o$9.Tab:
        if (x2.current = false, e2.comboboxState !== 0)
          return;
        e2.mode === 0 && e2.activationTrigger !== 1 && t2.selectActiveOption(), t2.closeCombobox();
        break;
    }
  }), O2 = o$7((l2) => {
    i2 == null || i2(l2), e2.mode === 0 && l2.target.value === "" && P3(), t2.openCombobox();
  }), W2 = o$7((l2) => {
    var E2, k2, R3;
    let B2 = (E2 = l2.relatedTarget) != null ? E2 : t$3.find((D2) => D2 !== l2.currentTarget);
    if (x2.current = false, !((k2 = e2.optionsRef.current) != null && k2.contains(B2)) && !((R3 = e2.buttonRef.current) != null && R3.contains(B2)) && e2.comboboxState === 0)
      return l2.preventDefault(), e2.mode === 0 && e2.value === null && P3(), t2.closeCombobox();
  }), z2 = o$7((l2) => {
    var E2, k2, R3;
    let B2 = (E2 = l2.relatedTarget) != null ? E2 : t$3.find((D2) => D2 !== l2.currentTarget);
    (k2 = e2.buttonRef.current) != null && k2.contains(B2) || (R3 = e2.optionsRef.current) != null && R3.contains(B2) || e2.disabled || e2.immediate && e2.comboboxState !== 0 && (t2.openCombobox(), V2.nextFrame(() => {
      t2.setActivationTrigger(1);
    }));
  }), g2 = I$4(), $2 = G$3(), { isFocused: X2, focusProps: J2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: p2 }), { isHovered: a3, hoverProps: j2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: n3 }), de2 = reactExports.useMemo(() => ({ open: e2.comboboxState === 0, disabled: n3, hover: a3, focus: X2, autofocus: p2 }), [e2, a3, X2, p2, n3]), be2 = D$4({ ref: F2, id: d4, role: "combobox", type: f2, "aria-controls": (te2 = e2.optionsRef.current) == null ? void 0 : te2.id, "aria-expanded": e2.comboboxState === 0, "aria-activedescendant": e2.activeOptionIndex === null ? void 0 : e2.virtual ? (ne2 = e2.options.find((l2) => !l2.dataRef.current.disabled && e2.compare(l2.dataRef.current.value, e2.virtual.options[e2.activeOptionIndex]))) == null ? void 0 : ne2.id : (re2 = e2.options[e2.activeOptionIndex]) == null ? void 0 : re2.id, "aria-labelledby": g2, "aria-describedby": $2, "aria-autocomplete": "list", defaultValue: (ie2 = (q2 = o3.defaultValue) != null ? q2 : e2.defaultValue !== void 0 ? m3 == null ? void 0 : m3(e2.defaultValue) : null) != null ? ie2 : e2.defaultValue, disabled: n3 || void 0, autoFocus: p2, onCompositionStart: I4, onCompositionEnd: A2, onKeyDown: w2, onChange: O2, onFocus: z2, onBlur: W2 }, J2, j2);
  return H$3({ ourProps: be2, theirProps: _3, slot: de2, defaultTag: Po$1, name: "Combobox.Input" });
}
let Ao$1 = "button";
function Eo$1(o3, r4) {
  var w2;
  let e2 = Q("Combobox.Button"), t2 = oe$1("Combobox.Button"), c4 = y$4(e2.buttonRef, r4), s4 = reactExports.useId(), { id: d4 = `headlessui-combobox-button-${s4}`, disabled: i2 = e2.disabled || false, autoFocus: m3 = false, ...n3 } = o3, p2 = p$2(), f2 = f$4(e2.inputRef), _3 = o$7((O2) => {
    switch (O2.key) {
      case o$9.Space:
      case o$9.Enter:
        return O2.preventDefault(), O2.stopPropagation(), e2.comboboxState === 1 && t2.openCombobox(), p2.nextFrame(() => f2());
      case o$9.ArrowDown:
        return O2.preventDefault(), O2.stopPropagation(), e2.comboboxState === 1 && (t2.openCombobox(), p2.nextFrame(() => {
          e2.value || t2.goToOption(c$6.First);
        })), p2.nextFrame(() => f2());
      case o$9.ArrowUp:
        return O2.preventDefault(), O2.stopPropagation(), e2.comboboxState === 1 && (t2.openCombobox(), p2.nextFrame(() => {
          e2.value || t2.goToOption(c$6.Last);
        })), p2.nextFrame(() => f2());
      case o$9.Escape:
        return e2.comboboxState !== 0 ? void 0 : (O2.preventDefault(), e2.optionsRef.current && !e2.optionsPropsRef.current.static && O2.stopPropagation(), t2.closeCombobox(), p2.nextFrame(() => f2()));
      default:
        return;
    }
  }), F2 = o$7((O2) => {
    O2.preventDefault(), !r$5(O2.currentTarget) && (O2.button === g$4.Left && (e2.comboboxState === 0 ? t2.closeCombobox() : t2.openCombobox()), f2());
  }), u3 = I$4([d4]), { isFocusVisible: x2, focusProps: V2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: m3 }), { isHovered: P3, hoverProps: C2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: i2 }), { pressed: y3, pressProps: I4 } = w$3({ disabled: i2 }), A2 = reactExports.useMemo(() => ({ open: e2.comboboxState === 0, active: y3 || e2.comboboxState === 0, disabled: i2, value: e2.value, hover: P3, focus: x2 }), [e2, P3, x2, y3, i2]), h2 = D$4({ ref: c4, id: d4, type: T$4(o3, e2.buttonRef), tabIndex: -1, "aria-haspopup": "listbox", "aria-controls": (w2 = e2.optionsRef.current) == null ? void 0 : w2.id, "aria-expanded": e2.comboboxState === 0, "aria-labelledby": u3, disabled: i2 || void 0, autoFocus: m3, onMouseDown: F2, onKeyDown: _3 }, V2, C2, I4);
  return H$3({ ourProps: h2, theirProps: n3, slot: A2, defaultTag: Ao$1, name: "Combobox.Button" });
}
let _o$1 = "div", Fo$1 = O$3.RenderStrategy | O$3.Static;
function ho$1(o3, r4) {
  var z2;
  let e2 = reactExports.useId(), { id: t2 = `headlessui-combobox-options-${e2}`, hold: c4 = false, anchor: s4, portal: d4 = false, modal: i2 = true, ...m3 } = o3, n3 = Q("Combobox.Options"), p2 = oe$1("Combobox.Options"), f2 = xe$1(s4);
  f2 && (d4 = true);
  let [_3, F2] = Re$2(f2), u3 = be$2(), x2 = y$4(n3.optionsRef, r4, f2 ? _3 : null), V2 = n$4(n3.optionsRef), P3 = u$a(), C2 = (() => P3 !== null ? (P3 & d$6.Open) === d$6.Open : n3.comboboxState === 0)();
  m$6(n3.inputRef, p2.closeCombobox, C2), u$b(V2, n3.__demoMode ? false : i2 && n3.comboboxState === 0), T$5({ allowed: o$7(() => [n3.inputRef.current, n3.buttonRef.current, n3.optionsRef.current]) }, n3.__demoMode ? false : i2 && n3.comboboxState === 0), n$3(() => {
    var g2;
    n3.optionsPropsRef.current.static = (g2 = o3.static) != null ? g2 : false;
  }, [n3.optionsPropsRef, o3.static]), n$3(() => {
    n3.optionsPropsRef.current.hold = c4;
  }, [n3.optionsPropsRef, c4]), F$4({ container: n3.optionsRef.current, enabled: n3.comboboxState === 0, accept(g2) {
    return g2.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : g2.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(g2) {
    g2.setAttribute("role", "none");
  } });
  let y3 = I$4([(z2 = n3.buttonRef.current) == null ? void 0 : z2.id]), I4 = reactExports.useMemo(() => ({ open: n3.comboboxState === 0, option: void 0 }), [n3]), A2 = o$7(() => {
    p2.setActivationTrigger(0);
  }), h2 = D$4(f2 ? u3() : {}, { "aria-labelledby": y3, role: "listbox", "aria-multiselectable": n3.mode === 1 ? true : void 0, id: t2, ref: x2, style: { ...F2, "--input-width": f$5(n3.inputRef, true).width, "--button-width": f$5(n3.buttonRef, true).width }, onWheel: A2 });
  n3.virtual && C2 && Object.assign(m3, { children: React.createElement(Co$1, null, m3.children) });
  let [w2, O2] = reactExports.useState(n3.value);
  n3.value !== w2 && n3.comboboxState === 0 && n3.mode !== 1 && O2(n3.value);
  let W2 = o$7((g2) => n3.compare(w2, g2));
  return React.createElement(te$1, { enabled: d4 ? o3.static || C2 : false }, React.createElement(se$1.Provider, { value: n3.mode === 1 ? n3 : { ...n3, isSelected: W2 } }, H$3({ ourProps: h2, theirProps: m3, slot: I4, defaultTag: _o$1, features: Fo$1, visible: C2, name: "Combobox.Options" })));
}
let Do$1 = "div";
function Mo$1(o3, r4) {
  var g2, $2, X2, J2;
  let e2 = Q("Combobox.Option"), t2 = oe$1("Combobox.Option"), c4 = reactExports.useId(), { id: s4 = `headlessui-combobox-option-${c4}`, value: d4, disabled: i2 = (X2 = ($2 = (g2 = e2.virtual) == null ? void 0 : g2.disabled) == null ? void 0 : $2.call(g2, d4)) != null ? X2 : false, order: m3 = null, ...n3 } = o3, p2 = f$4(e2.inputRef), f2 = e2.virtual ? e2.activeOptionIndex === e2.calculateIndex(d4) : e2.activeOptionIndex === null ? false : ((J2 = e2.options[e2.activeOptionIndex]) == null ? void 0 : J2.id) === s4, _3 = e2.isSelected(d4), F2 = reactExports.useRef(null), u3 = s$7({ disabled: i2, value: d4, domRef: F2, order: m3 }), x2 = reactExports.useContext(Le$1), V2 = y$4(r4, F2, x2 ? x2.measureElement : null), P3 = o$7(() => t2.onChange(d4));
  n$3(() => t2.registerOption(s4, u3), [u3, s4]);
  let C2 = reactExports.useRef(!(e2.virtual || e2.__demoMode));
  n$3(() => {
    if (!e2.virtual && !e2.__demoMode)
      return o$8().requestAnimationFrame(() => {
        C2.current = true;
      });
  }, [e2.virtual, e2.__demoMode]), n$3(() => {
    if (C2.current && e2.comboboxState === 0 && f2 && e2.activationTrigger !== 0)
      return o$8().requestAnimationFrame(() => {
        var a3, j2;
        (j2 = (a3 = F2.current) == null ? void 0 : a3.scrollIntoView) == null || j2.call(a3, { block: "nearest" });
      });
  }, [F2, f2, e2.comboboxState, e2.activationTrigger, e2.activeOptionIndex]);
  let y3 = o$7((a3) => {
    a3.preventDefault(), a3.button === g$4.Left && (i2 || (P3(), n$5() || requestAnimationFrame(() => p2()), e2.mode === 0 && t2.closeCombobox()));
  }), I4 = o$7(() => {
    if (i2)
      return t2.goToOption(c$6.Nothing);
    let a3 = e2.calculateIndex(d4);
    t2.goToOption(c$6.Specific, a3);
  }), A2 = u$5(), h2 = o$7((a3) => A2.update(a3)), w2 = o$7((a3) => {
    if (!A2.wasMoved(a3) || i2 || f2)
      return;
    let j2 = e2.calculateIndex(d4);
    t2.goToOption(c$6.Specific, j2, 0);
  }), O2 = o$7((a3) => {
    A2.wasMoved(a3) && (i2 || f2 && (e2.optionsPropsRef.current.hold || t2.goToOption(c$6.Nothing)));
  }), W2 = reactExports.useMemo(() => ({ active: f2, focus: f2, selected: _3, disabled: i2 }), [f2, _3, i2]);
  return H$3({ ourProps: { id: s4, ref: V2, role: "option", tabIndex: i2 === true ? void 0 : -1, "aria-disabled": i2 === true ? true : void 0, "aria-selected": _3, disabled: void 0, onMouseDown: y3, onFocus: I4, onPointerEnter: h2, onMouseEnter: h2, onPointerMove: w2, onMouseMove: w2, onPointerLeave: O2, onMouseLeave: O2 }, theirProps: n3, slot: W2, defaultTag: Do$1, name: "Combobox.Option" });
}
let Vo$1 = I$5(So$1), Lo$1 = I$5(Eo$1), wo$1 = I$5(Io$1), Bo$1 = K$1, ko$1 = I$5(ho$1), No$1 = I$5(Mo$1), ht$1 = Object.assign(Vo$1, { Input: wo$1, Button: Lo$1, Label: Bo$1, Options: ko$1, Option: No$1 });
var t$1;
let a$7 = (t$1 = React.startTransition) != null ? t$1 : function(i2) {
  i2();
};
var ae$1 = ((o3) => (o3[o3.Open = 0] = "Open", o3[o3.Closed = 1] = "Closed", o3))(ae$1 || {}), pe$1 = ((t2) => (t2[t2.ToggleDisclosure = 0] = "ToggleDisclosure", t2[t2.CloseDisclosure = 1] = "CloseDisclosure", t2[t2.SetButtonId = 2] = "SetButtonId", t2[t2.SetPanelId = 3] = "SetPanelId", t2[t2.LinkPanel = 4] = "LinkPanel", t2[t2.UnlinkPanel = 5] = "UnlinkPanel", t2))(pe$1 || {});
let ce = { [0]: (e2) => ({ ...e2, disclosureState: u$9(e2.disclosureState, { [0]: 1, [1]: 0 }) }), [1]: (e2) => e2.disclosureState === 1 ? e2 : { ...e2, disclosureState: 1 }, [4](e2) {
  return e2.linkedPanel === true ? e2 : { ...e2, linkedPanel: true };
}, [5](e2) {
  return e2.linkedPanel === false ? e2 : { ...e2, linkedPanel: false };
}, [2](e2, n3) {
  return e2.buttonId === n3.buttonId ? e2 : { ...e2, buttonId: n3.buttonId };
}, [3](e2, n3) {
  return e2.panelId === n3.panelId ? e2 : { ...e2, panelId: n3.panelId };
} }, M$4 = reactExports.createContext(null);
M$4.displayName = "DisclosureContext";
function F$3(e2) {
  let n3 = reactExports.useContext(M$4);
  if (n3 === null) {
    let o3 = new Error(`<${e2} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o3, F$3), o3;
  }
  return n3;
}
let k$3 = reactExports.createContext(null);
k$3.displayName = "DisclosureAPIContext";
function V$2(e2) {
  let n3 = reactExports.useContext(k$3);
  if (n3 === null) {
    let o3 = new Error(`<${e2} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o3, V$2), o3;
  }
  return n3;
}
let H$2 = reactExports.createContext(null);
H$2.displayName = "DisclosurePanelContext";
function de() {
  return reactExports.useContext(H$2);
}
function fe$1(e2, n3) {
  return u$9(n3.type, ce, e2, n3);
}
let Te$1 = reactExports.Fragment;
function De$1(e2, n3) {
  let { defaultOpen: o3 = false, ...d4 } = e2, u3 = reactExports.useRef(null), r4 = y$4(n3, T$6((c4) => {
    u3.current = c4;
  }, e2.as === void 0 || e2.as === reactExports.Fragment)), t2 = reactExports.useRef(null), l2 = reactExports.useRef(null), i2 = reactExports.useReducer(fe$1, { disclosureState: o3 ? 0 : 1, linkedPanel: false, buttonRef: l2, panelRef: t2, buttonId: null, panelId: null }), [{ disclosureState: f2, buttonId: s4 }, T2] = i2, p2 = o$7((c4) => {
    T2({ type: 1 });
    let P3 = u$8(u3);
    if (!P3 || !s4)
      return;
    let y3 = (() => c4 ? c4 instanceof HTMLElement ? c4 : c4.current instanceof HTMLElement ? c4.current : P3.getElementById(s4) : P3.getElementById(s4))();
    y3 == null || y3.focus();
  }), m3 = reactExports.useMemo(() => ({ close: p2 }), [p2]), D2 = reactExports.useMemo(() => ({ open: f2 === 0, close: p2 }), [f2, p2]), I4 = { ref: r4 };
  return React.createElement(M$4.Provider, { value: i2 }, React.createElement(k$3.Provider, { value: m3 }, React.createElement(u$c, { value: p2 }, React.createElement(s$6, { value: u$9(f2, { [0]: d$6.Open, [1]: d$6.Closed }) }, H$3({ ourProps: I4, theirProps: d4, slot: D2, defaultTag: Te$1, name: "Disclosure" })))));
}
let Pe$1 = "button";
function ye$1(e2, n3) {
  let o3 = reactExports.useId(), { id: d4 = `headlessui-disclosure-button-${o3}`, disabled: u3 = false, autoFocus: r4 = false, ...t2 } = e2, [l2, i2] = F$3("Disclosure.Button"), f2 = de(), s4 = f2 === null ? false : f2 === l2.panelId, T2 = reactExports.useRef(null), p2 = y$4(T2, n3, s4 ? null : l2.buttonRef), m3 = U$3();
  reactExports.useEffect(() => {
    if (!s4)
      return i2({ type: 2, buttonId: d4 }), () => {
        i2({ type: 2, buttonId: null });
      };
  }, [d4, i2, s4]);
  let D2 = o$7((a3) => {
    var E2;
    if (s4) {
      if (l2.disclosureState === 1)
        return;
      switch (a3.key) {
        case o$9.Space:
        case o$9.Enter:
          a3.preventDefault(), a3.stopPropagation(), i2({ type: 0 }), (E2 = l2.buttonRef.current) == null || E2.focus();
          break;
      }
    } else
      switch (a3.key) {
        case o$9.Space:
        case o$9.Enter:
          a3.preventDefault(), a3.stopPropagation(), i2({ type: 0 });
          break;
      }
  }), I4 = o$7((a3) => {
    switch (a3.key) {
      case o$9.Space:
        a3.preventDefault();
        break;
    }
  }), c4 = o$7((a3) => {
    var E2;
    r$5(a3.currentTarget) || u3 || (s4 ? (i2({ type: 0 }), (E2 = l2.buttonRef.current) == null || E2.focus()) : i2({ type: 0 }));
  }), { isFocusVisible: P3, focusProps: y3 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: r4 }), { isHovered: U2, hoverProps: h2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: u3 }), { pressed: N2, pressProps: w2 } = w$3({ disabled: u3 }), q2 = reactExports.useMemo(() => ({ open: l2.disclosureState === 0, hover: U2, active: N2, disabled: u3, focus: P3, autofocus: r4 }), [l2, U2, N2, P3, u3, r4]), G2 = T$4(e2, T2), z2 = s4 ? D$4({ ref: p2, type: G2, disabled: u3 || void 0, autoFocus: r4, onKeyDown: D2, onClick: c4 }, y3, h2, w2) : D$4({ ref: p2, id: d4, type: G2, "aria-expanded": l2.disclosureState === 0, "aria-controls": l2.linkedPanel ? l2.panelId : void 0, disabled: u3 || void 0, autoFocus: r4, onKeyDown: D2, onKeyUp: I4, onClick: c4 }, y3, h2, w2);
  return H$3({ mergeRefs: m3, ourProps: z2, theirProps: t2, slot: q2, defaultTag: Pe$1, name: "Disclosure.Button" });
}
let me$1 = "div", Ee$1 = O$3.RenderStrategy | O$3.Static;
function ge$1(e2, n3) {
  let o3 = reactExports.useId(), { id: d4 = `headlessui-disclosure-panel-${o3}`, ...u3 } = e2, [r4, t2] = F$3("Disclosure.Panel"), { close: l2 } = V$2("Disclosure.Panel"), i2 = U$3(), f2 = y$4(n3, r4.panelRef, (D2) => {
    a$7(() => t2({ type: D2 ? 4 : 5 }));
  });
  reactExports.useEffect(() => (t2({ type: 3, panelId: d4 }), () => {
    t2({ type: 3, panelId: null });
  }), [d4, t2]);
  let s4 = u$a(), T2 = (() => s4 !== null ? (s4 & d$6.Open) === d$6.Open : r4.disclosureState === 0)(), p2 = reactExports.useMemo(() => ({ open: r4.disclosureState === 0, close: l2 }), [r4, l2]), m3 = { ref: f2, id: d4 };
  return React.createElement(H$2.Provider, { value: r4.panelId }, H$3({ mergeRefs: i2, ourProps: m3, theirProps: u3, slot: p2, defaultTag: me$1, features: Ee$1, visible: T2, name: "Disclosure.Panel" }));
}
let Se$1 = I$5(De$1), be$1 = I$5(ye$1), Re$1 = I$5(ge$1), we$1 = Object.assign(Se$1, { Button: be$1, Panel: Re$1 });
function InputError({ message, className = "", ...props }) {
  return message ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { ...props, className: "text-sm text-red-600 " + className, children: message }) : null;
}
var dist$1 = {};
var DatePicker = {};
var dist = { exports: {} };
var tailwindMerge_cjs_production_min = {};
function r$4() {
  for (var r4, o3, t2 = 0, n3 = ""; t2 < arguments.length; )
    (r4 = arguments[t2++]) && (o3 = e(r4)) && (n3 && (n3 += " "), n3 += o3);
  return n3;
}
function e(r4) {
  if ("string" == typeof r4)
    return r4;
  for (var o3, t2 = "", n3 = 0; n3 < r4.length; n3++)
    r4[n3] && (o3 = e(r4[n3])) && (t2 && (t2 += " "), t2 += o3);
  return t2;
}
Object.defineProperty(tailwindMerge_cjs_production_min, "__esModule", { value: true });
var o$6 = "-";
function t(r4) {
  var e2 = function(r5) {
    var e3 = r5.theme, o3 = r5.prefix, t3 = { nextPart: /* @__PURE__ */ new Map(), validators: [] }, n3 = function(r6, e4) {
      return e4 ? r6.map(function(r7) {
        return [r7[0], r7[1].map(function(r8) {
          return "string" == typeof r8 ? e4 + r8 : "object" == typeof r8 ? Object.fromEntries(Object.entries(r8).map(function(r9) {
            return [e4 + r9[0], r9[1]];
          })) : r8;
        })];
      }) : r6;
    }(Object.entries(r5.classGroups), o3);
    return n3.forEach(function(r6) {
      a$6(r6[1], t3, r6[0], e3);
    }), t3;
  }(r4), t2 = r4.conflictingClassGroups, l2 = r4.conflictingClassGroupModifiers, s4 = void 0 === l2 ? {} : l2;
  return { getClassGroupId: function(r5) {
    var t3 = r5.split(o$6);
    return "" === t3[0] && 1 !== t3.length && t3.shift(), n$2(t3, e2) || function(r6) {
      if (i$2.test(r6)) {
        var e3 = i$2.exec(r6)[1], o3 = e3 == null ? void 0 : e3.substring(0, e3.indexOf(":"));
        if (o3)
          return "arbitrary.." + o3;
      }
    }(r5);
  }, getConflictingClassGroupIds: function(r5, e3) {
    var o3 = t2[r5] || [];
    return e3 && s4[r5] ? [].concat(o3, s4[r5]) : o3;
  } };
}
function n$2(r4, e2) {
  var _a;
  if (0 === r4.length)
    return e2.classGroupId;
  var t2 = e2.nextPart.get(r4[0]), i2 = t2 ? n$2(r4.slice(1), t2) : void 0;
  if (i2)
    return i2;
  if (0 !== e2.validators.length) {
    var a3 = r4.join(o$6);
    return (_a = e2.validators.find(function(r5) {
      return (0, r5.validator)(a3);
    })) == null ? void 0 : _a.classGroupId;
  }
}
var i$2 = /^\[(.+)\]$/;
function a$6(r4, e2, o3, t2) {
  r4.forEach(function(r5) {
    if ("string" != typeof r5) {
      if ("function" == typeof r5)
        return r5.isThemeGetter ? void a$6(r5(t2), e2, o3, t2) : void e2.validators.push({ validator: r5, classGroupId: o3 });
      Object.entries(r5).forEach(function(r6) {
        a$6(r6[1], l$3(e2, r6[0]), o3, t2);
      });
    } else
      ("" === r5 ? e2 : l$3(e2, r5)).classGroupId = o3;
  });
}
function l$3(r4, e2) {
  var t2 = r4;
  return e2.split(o$6).forEach(function(r5) {
    t2.nextPart.has(r5) || t2.nextPart.set(r5, { nextPart: /* @__PURE__ */ new Map(), validators: [] }), t2 = t2.nextPart.get(r5);
  }), t2;
}
function s$4(r4) {
  if (r4 < 1)
    return { get: function() {
    }, set: function() {
    } };
  var e2 = 0, o3 = /* @__PURE__ */ new Map(), t2 = /* @__PURE__ */ new Map();
  function n3(n4, i2) {
    o3.set(n4, i2), ++e2 > r4 && (e2 = 0, t2 = o3, o3 = /* @__PURE__ */ new Map());
  }
  return { get: function(r5) {
    var e3 = o3.get(r5);
    return void 0 !== e3 ? e3 : void 0 !== (e3 = t2.get(r5)) ? (n3(r5, e3), e3) : void 0;
  }, set: function(r5, e3) {
    o3.has(r5) ? o3.set(r5, e3) : n3(r5, e3);
  } };
}
var c$5 = "!";
function d$5(r4) {
  var e2 = r4.separator || ":", o3 = 1 === e2.length, t2 = e2[0], n3 = e2.length;
  return function(r5) {
    for (var i2, a3 = [], l2 = 0, s4 = 0, d4 = 0; d4 < r5.length; d4++) {
      var u3 = r5[d4];
      if (0 === l2) {
        if (u3 === t2 && (o3 || r5.slice(d4, d4 + n3) === e2)) {
          a3.push(r5.slice(s4, d4)), s4 = d4 + n3;
          continue;
        }
        if ("/" === u3) {
          i2 = d4;
          continue;
        }
      }
      "[" === u3 ? l2++ : "]" === u3 && l2--;
    }
    var p2 = 0 === a3.length ? r5 : r5.substring(s4), f2 = p2.startsWith(c$5);
    return { modifiers: a3, hasImportantModifier: f2, baseClassName: f2 ? p2.substring(1) : p2, maybePostfixModifierPosition: i2 && i2 > s4 ? i2 - s4 : void 0 };
  };
}
var u$3 = /\s+/;
function p$1() {
  for (var e2 = arguments.length, o3 = new Array(e2), n3 = 0; n3 < e2; n3++)
    o3[n3] = arguments[n3];
  var i2, a3, l2, p2 = function(r4) {
    var e3 = o3[0], n4 = o3.slice(1).reduce(function(r5, e4) {
      return e4(r5);
    }, e3());
    return i2 = function(r5) {
      return { cache: s$4(r5.cacheSize), splitModifiers: d$5(r5), ...t(r5) };
    }(n4), a3 = i2.cache.get, l2 = i2.cache.set, p2 = f2, f2(r4);
  };
  function f2(r4) {
    var e3 = a3(r4);
    if (e3)
      return e3;
    var o4 = function(r5, e4) {
      var o5 = e4.splitModifiers, t2 = e4.getClassGroupId, n4 = e4.getConflictingClassGroupIds, i3 = /* @__PURE__ */ new Set();
      return r5.trim().split(u$3).map(function(r6) {
        var e5 = o5(r6), n5 = e5.modifiers, i4 = e5.hasImportantModifier, a4 = e5.baseClassName, l3 = e5.maybePostfixModifierPosition, s4 = t2(l3 ? a4.substring(0, l3) : a4), d4 = Boolean(l3);
        if (!s4) {
          if (!l3)
            return { isTailwindClass: false, originalClassName: r6 };
          if (!(s4 = t2(a4)))
            return { isTailwindClass: false, originalClassName: r6 };
          d4 = false;
        }
        var u3 = function(r7) {
          if (r7.length <= 1)
            return r7;
          var e6 = [], o6 = [];
          return r7.forEach(function(r8) {
            "[" === r8[0] ? (e6.push.apply(e6, o6.sort().concat([r8])), o6 = []) : o6.push(r8);
          }), e6.push.apply(e6, o6.sort()), e6;
        }(n5).join(":");
        return { isTailwindClass: true, modifierId: i4 ? u3 + c$5 : u3, classGroupId: s4, originalClassName: r6, hasPostfixModifier: d4 };
      }).reverse().filter(function(r6) {
        if (!r6.isTailwindClass)
          return true;
        var e5 = r6.modifierId, o6 = r6.classGroupId, t3 = r6.hasPostfixModifier, a4 = e5 + o6;
        return !i3.has(a4) && (i3.add(a4), n4(o6, t3).forEach(function(r7) {
          return i3.add(e5 + r7);
        }), true);
      }).reverse().map(function(r6) {
        return r6.originalClassName;
      }).join(" ");
    }(r4, i2);
    return l2(r4, o4), o4;
  }
  return function() {
    return p2(r$4.apply(null, arguments));
  };
}
function f$2(r4) {
  var e2 = function(e3) {
    return e3[r4] || [];
  };
  return e2.isThemeGetter = true, e2;
}
var b$2 = /^\[(?:([a-z-]+):)?(.+)\]$/i, m$3 = /^\d+\/\d+$/, g$3 = /* @__PURE__ */ new Set(["px", "full", "screen"]), h$3 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, v$2 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, y$2 = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
function x$2(r4) {
  return M$3(r4) || g$3.has(r4) || m$3.test(r4) || w$1(r4);
}
function w$1(r4) {
  return T$2(r4, "length", O$2);
}
function k$2(r4) {
  return T$2(r4, "size", E);
}
function z$1(r4) {
  return T$2(r4, "position", E);
}
function C$3(r4) {
  return T$2(r4, "url", _$2);
}
function j$2(r4) {
  return T$2(r4, "number", M$3);
}
function M$3(r4) {
  return !Number.isNaN(Number(r4));
}
function G$1(r4) {
  return r4.endsWith("%") && M$3(r4.slice(0, -1));
}
function P$3(r4) {
  return W$1(r4) || T$2(r4, "number", W$1);
}
function I$3(r4) {
  return b$2.test(r4);
}
function A$1() {
  return true;
}
function N$1(r4) {
  return h$3.test(r4);
}
function S$1(r4) {
  return T$2(r4, "", $$1);
}
function T$2(r4, e2, o3) {
  var t2 = b$2.exec(r4);
  return !!t2 && (t2[1] ? t2[1] === e2 : o3(t2[2]));
}
function O$2(r4) {
  return v$2.test(r4);
}
function E() {
  return false;
}
function _$2(r4) {
  return r4.startsWith("url(");
}
function W$1(r4) {
  return Number.isInteger(Number(r4));
}
function $$1(r4) {
  return y$2.test(r4);
}
var R$4 = { __proto__: null, isAny: A$1, isArbitraryLength: w$1, isArbitraryNumber: j$2, isArbitraryPosition: z$1, isArbitraryShadow: S$1, isArbitrarySize: k$2, isArbitraryUrl: C$3, isArbitraryValue: I$3, isArbitraryWeight: j$2, isInteger: P$3, isLength: x$2, isNumber: M$3, isPercent: G$1, isTshirtSize: N$1 };
function q$1() {
  var r4 = f$2("colors"), e2 = f$2("spacing"), o3 = f$2("blur"), t2 = f$2("brightness"), n3 = f$2("borderColor"), i2 = f$2("borderRadius"), a3 = f$2("borderSpacing"), l2 = f$2("borderWidth"), s4 = f$2("contrast"), c4 = f$2("grayscale"), d4 = f$2("hueRotate"), u3 = f$2("invert"), p2 = f$2("gap"), b3 = f$2("gradientColorStops"), m3 = f$2("gradientColorStopPositions"), g2 = f$2("inset"), h2 = f$2("margin"), v2 = f$2("opacity"), y3 = f$2("padding"), T2 = f$2("saturate"), O2 = f$2("scale"), E2 = f$2("sepia"), _3 = f$2("skew"), W2 = f$2("space"), $2 = f$2("translate"), R3 = function() {
    return ["auto", I$3, e2];
  }, q2 = function() {
    return [I$3, e2];
  }, L2 = function() {
    return ["", x$2];
  }, B2 = function() {
    return ["auto", M$3, I$3];
  }, D2 = function() {
    return ["", "0", I$3];
  }, J2 = function() {
    return [M$3, j$2];
  }, U2 = function() {
    return [M$3, I$3];
  };
  return { cacheSize: 500, theme: { colors: [A$1], spacing: [x$2], blur: ["none", "", N$1, I$3], brightness: J2(), borderColor: [r4], borderRadius: ["none", "", "full", N$1, I$3], borderSpacing: q2(), borderWidth: L2(), contrast: J2(), grayscale: D2(), hueRotate: U2(), invert: D2(), gap: q2(), gradientColorStops: [r4], gradientColorStopPositions: [G$1, w$1], inset: R3(), margin: R3(), opacity: J2(), padding: q2(), saturate: J2(), scale: J2(), sepia: D2(), skew: U2(), space: q2(), translate: q2() }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", I$3] }], container: ["container"], columns: [{ columns: [N$1] }], "break-after": [{ "break-after": ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"] }], "break-before": [{ "break-before": ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"] }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none"] }], clear: [{ clear: ["left", "right", "both", "none"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [].concat(["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], [I$3]) }], overflow: [{ overflow: ["auto", "hidden", "clip", "visible", "scroll"] }], "overflow-x": [{ "overflow-x": ["auto", "hidden", "clip", "visible", "scroll"] }], "overflow-y": [{ "overflow-y": ["auto", "hidden", "clip", "visible", "scroll"] }], overscroll: [{ overscroll: ["auto", "contain", "none"] }], "overscroll-x": [{ "overscroll-x": ["auto", "contain", "none"] }], "overscroll-y": [{ "overscroll-y": ["auto", "contain", "none"] }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [g2] }], "inset-x": [{ "inset-x": [g2] }], "inset-y": [{ "inset-y": [g2] }], start: [{ start: [g2] }], end: [{ end: [g2] }], top: [{ top: [g2] }], right: [{ right: [g2] }], bottom: [{ bottom: [g2] }], left: [{ left: [g2] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", P$3] }], basis: [{ basis: R3() }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", I$3] }], grow: [{ grow: D2() }], shrink: [{ shrink: D2() }], order: [{ order: ["first", "last", "none", P$3] }], "grid-cols": [{ "grid-cols": [A$1] }], "col-start-end": [{ col: ["auto", { span: ["full", P$3] }, I$3] }], "col-start": [{ "col-start": B2() }], "col-end": [{ "col-end": B2() }], "grid-rows": [{ "grid-rows": [A$1] }], "row-start-end": [{ row: ["auto", { span: [P$3] }, I$3] }], "row-start": [{ "row-start": B2() }], "row-end": [{ "row-end": B2() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", I$3] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", I$3] }], gap: [{ gap: [p2] }], "gap-x": [{ "gap-x": [p2] }], "gap-y": [{ "gap-y": [p2] }], "justify-content": [{ justify: ["normal"].concat(["start", "end", "center", "between", "around", "evenly", "stretch"]) }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal"].concat(["start", "end", "center", "between", "around", "evenly", "stretch"], ["baseline"]) }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [].concat(["start", "end", "center", "between", "around", "evenly", "stretch"], ["baseline"]) }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [y3] }], px: [{ px: [y3] }], py: [{ py: [y3] }], ps: [{ ps: [y3] }], pe: [{ pe: [y3] }], pt: [{ pt: [y3] }], pr: [{ pr: [y3] }], pb: [{ pb: [y3] }], pl: [{ pl: [y3] }], m: [{ m: [h2] }], mx: [{ mx: [h2] }], my: [{ my: [h2] }], ms: [{ ms: [h2] }], me: [{ me: [h2] }], mt: [{ mt: [h2] }], mr: [{ mr: [h2] }], mb: [{ mb: [h2] }], ml: [{ ml: [h2] }], "space-x": [{ "space-x": [W2] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [W2] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", I$3, e2] }], "min-w": [{ "min-w": ["min", "max", "fit", I$3, x$2] }], "max-w": [{ "max-w": ["0", "none", "full", "min", "max", "fit", "prose", { screen: [N$1] }, N$1, I$3] }], h: [{ h: [I$3, e2, "auto", "min", "max", "fit"] }], "min-h": [{ "min-h": ["min", "max", "fit", I$3, x$2] }], "max-h": [{ "max-h": [I$3, e2, "min", "max", "fit"] }], "font-size": [{ text: ["base", N$1, w$1] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", j$2] }], "font-family": [{ font: [A$1] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractons"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", I$3] }], "line-clamp": [{ "line-clamp": ["none", M$3, j$2] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", I$3, x$2] }], "list-image": [{ "list-image": ["none", I$3] }], "list-style-type": [{ list: ["none", "disc", "decimal", I$3] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [r4] }], "placeholder-opacity": [{ "placeholder-opacity": [v2] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [r4] }], "text-opacity": [{ "text-opacity": [v2] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [].concat(["solid", "dashed", "dotted", "double", "none"], ["wavy"]) }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", x$2] }], "underline-offset": [{ "underline-offset": ["auto", I$3, x$2] }], "text-decoration-color": [{ decoration: [r4] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], indent: [{ indent: q2() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", I$3] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", I$3] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [v2] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [].concat(["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], [z$1]) }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", k$2] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, C$3] }], "bg-color": [{ bg: [r4] }], "gradient-from-pos": [{ from: [m3] }], "gradient-via-pos": [{ via: [m3] }], "gradient-to-pos": [{ to: [m3] }], "gradient-from": [{ from: [b3] }], "gradient-via": [{ via: [b3] }], "gradient-to": [{ to: [b3] }], rounded: [{ rounded: [i2] }], "rounded-s": [{ "rounded-s": [i2] }], "rounded-e": [{ "rounded-e": [i2] }], "rounded-t": [{ "rounded-t": [i2] }], "rounded-r": [{ "rounded-r": [i2] }], "rounded-b": [{ "rounded-b": [i2] }], "rounded-l": [{ "rounded-l": [i2] }], "rounded-ss": [{ "rounded-ss": [i2] }], "rounded-se": [{ "rounded-se": [i2] }], "rounded-ee": [{ "rounded-ee": [i2] }], "rounded-es": [{ "rounded-es": [i2] }], "rounded-tl": [{ "rounded-tl": [i2] }], "rounded-tr": [{ "rounded-tr": [i2] }], "rounded-br": [{ "rounded-br": [i2] }], "rounded-bl": [{ "rounded-bl": [i2] }], "border-w": [{ border: [l2] }], "border-w-x": [{ "border-x": [l2] }], "border-w-y": [{ "border-y": [l2] }], "border-w-s": [{ "border-s": [l2] }], "border-w-e": [{ "border-e": [l2] }], "border-w-t": [{ "border-t": [l2] }], "border-w-r": [{ "border-r": [l2] }], "border-w-b": [{ "border-b": [l2] }], "border-w-l": [{ "border-l": [l2] }], "border-opacity": [{ "border-opacity": [v2] }], "border-style": [{ border: [].concat(["solid", "dashed", "dotted", "double", "none"], ["hidden"]) }], "divide-x": [{ "divide-x": [l2] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [l2] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [v2] }], "divide-style": [{ divide: ["solid", "dashed", "dotted", "double", "none"] }], "border-color": [{ border: [n3] }], "border-color-x": [{ "border-x": [n3] }], "border-color-y": [{ "border-y": [n3] }], "border-color-t": [{ "border-t": [n3] }], "border-color-r": [{ "border-r": [n3] }], "border-color-b": [{ "border-b": [n3] }], "border-color-l": [{ "border-l": [n3] }], "divide-color": [{ divide: [n3] }], "outline-style": [{ outline: [""].concat(["solid", "dashed", "dotted", "double", "none"]) }], "outline-offset": [{ "outline-offset": [I$3, x$2] }], "outline-w": [{ outline: [x$2] }], "outline-color": [{ outline: [r4] }], "ring-w": [{ ring: L2() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [r4] }], "ring-opacity": [{ "ring-opacity": [v2] }], "ring-offset-w": [{ "ring-offset": [x$2] }], "ring-offset-color": [{ "ring-offset": [r4] }], shadow: [{ shadow: ["", "inner", "none", N$1, S$1] }], "shadow-color": [{ shadow: [A$1] }], opacity: [{ opacity: [v2] }], "mix-blend": [{ "mix-blend": ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"] }], "bg-blend": [{ "bg-blend": ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"] }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [o3] }], brightness: [{ brightness: [t2] }], contrast: [{ contrast: [s4] }], "drop-shadow": [{ "drop-shadow": ["", "none", N$1, I$3] }], grayscale: [{ grayscale: [c4] }], "hue-rotate": [{ "hue-rotate": [d4] }], invert: [{ invert: [u3] }], saturate: [{ saturate: [T2] }], sepia: [{ sepia: [E2] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [o3] }], "backdrop-brightness": [{ "backdrop-brightness": [t2] }], "backdrop-contrast": [{ "backdrop-contrast": [s4] }], "backdrop-grayscale": [{ "backdrop-grayscale": [c4] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [d4] }], "backdrop-invert": [{ "backdrop-invert": [u3] }], "backdrop-opacity": [{ "backdrop-opacity": [v2] }], "backdrop-saturate": [{ "backdrop-saturate": [T2] }], "backdrop-sepia": [{ "backdrop-sepia": [E2] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [a3] }], "border-spacing-x": [{ "border-spacing-x": [a3] }], "border-spacing-y": [{ "border-spacing-y": [a3] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", I$3] }], duration: [{ duration: U2() }], ease: [{ ease: ["linear", "in", "out", "in-out", I$3] }], delay: [{ delay: U2() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", I$3] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [O2] }], "scale-x": [{ "scale-x": [O2] }], "scale-y": [{ "scale-y": [O2] }], rotate: [{ rotate: [P$3, I$3] }], "translate-x": [{ "translate-x": [$2] }], "translate-y": [{ "translate-y": [$2] }], "skew-x": [{ "skew-x": [_3] }], "skew-y": [{ "skew-y": [_3] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", I$3] }], accent: [{ accent: ["auto", r4] }], appearance: ["appearance-none"], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", I$3] }], "caret-color": [{ caret: [r4] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": q2() }], "scroll-mx": [{ "scroll-mx": q2() }], "scroll-my": [{ "scroll-my": q2() }], "scroll-ms": [{ "scroll-ms": q2() }], "scroll-me": [{ "scroll-me": q2() }], "scroll-mt": [{ "scroll-mt": q2() }], "scroll-mr": [{ "scroll-mr": q2() }], "scroll-mb": [{ "scroll-mb": q2() }], "scroll-ml": [{ "scroll-ml": q2() }], "scroll-p": [{ "scroll-p": q2() }], "scroll-px": [{ "scroll-px": q2() }], "scroll-py": [{ "scroll-py": q2() }], "scroll-ps": [{ "scroll-ps": q2() }], "scroll-pe": [{ "scroll-pe": q2() }], "scroll-pt": [{ "scroll-pt": q2() }], "scroll-pr": [{ "scroll-pr": q2() }], "scroll-pb": [{ "scroll-pb": q2() }], "scroll-pl": [{ "scroll-pl": q2() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "pinch-zoom", "manipulation", { pan: ["x", "left", "right", "y", "up", "down"] }] }], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", I$3] }], fill: [{ fill: [r4, "none"] }], "stroke-w": [{ stroke: [x$2, j$2] }], stroke: [{ stroke: [r4, "none"] }], sr: ["sr-only", "not-sr-only"] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } };
}
function L$2(r4, e2) {
  for (var o3 in e2)
    J(r4, o3, e2[o3]);
  return r4;
}
var B$1 = Object.prototype.hasOwnProperty, D$2 = /* @__PURE__ */ new Set(["string", "number", "boolean"]);
function J(r4, e2, o3) {
  if (B$1.call(r4, e2) && !D$2.has(typeof o3) && null !== o3) {
    if (Array.isArray(o3) && Array.isArray(r4[e2]))
      r4[e2] = r4[e2].concat(o3);
    else if ("object" == typeof o3 && "object" == typeof r4[e2]) {
      if (null === r4[e2])
        return void (r4[e2] = o3);
      for (var t2 in o3)
        J(r4[e2], t2, o3[t2]);
    }
  } else
    r4[e2] = o3;
}
var U$1 = p$1(q$1), V$1 = r$4;
tailwindMerge_cjs_production_min.createTailwindMerge = p$1, tailwindMerge_cjs_production_min.extendTailwindMerge = function(r4) {
  for (var e2 = arguments.length, o3 = new Array(e2 > 1 ? e2 - 1 : 0), t2 = 1; t2 < e2; t2++)
    o3[t2 - 1] = arguments[t2];
  return p$1.apply(void 0, "function" == typeof r4 ? [q$1, r4].concat(o3) : [function() {
    return L$2(q$1(), r4);
  }].concat(o3));
}, tailwindMerge_cjs_production_min.fromTheme = f$2, tailwindMerge_cjs_production_min.getDefaultConfig = q$1, tailwindMerge_cjs_production_min.join = V$1, tailwindMerge_cjs_production_min.mergeConfigs = L$2, tailwindMerge_cjs_production_min.twJoin = r$4, tailwindMerge_cjs_production_min.twMerge = U$1, tailwindMerge_cjs_production_min.validators = R$4;
{
  dist.exports = tailwindMerge_cjs_production_min;
}
var distExports = dist.exports;
var Options = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return _default;
  } });
  var options = { autoHide: true, todayBtn: true, clearBtn: true, todayBtnText: "Today", clearBtnText: "Clear", theme: { background: "", todayBtn: "", clearBtn: "", icons: "", text: "", disabledText: "", input: "", inputIcon: "", selected: "" }, datepickerClassNames: "", defaultDate: /* @__PURE__ */ new Date(), language: "en", weekDays: ["Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"], inputNameProp: "date", inputIdProp: "date", inputPlaceholderProp: "Select Date", inputDateFormatProp: { day: "numeric", month: "long", year: "numeric" } };
  var _default = options;
})(Options);
var DatePickerPopup = {};
var date = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, { enumerable: true, get: all[name] });
  }
  _export(exports, { firstDateOfMonth: function() {
    return firstDateOfMonth;
  }, addDays: function() {
    return addDays;
  }, dayDiff: function() {
    return dayDiff;
  }, dayOfTheWeekOf: function() {
    return dayOfTheWeekOf;
  }, addMonths: function() {
    return addMonths;
  }, addYears: function() {
    return addYears;
  }, getFormattedDate: function() {
    return getFormattedDate;
  }, goToPrevNext: function() {
    return goToPrevNext;
  }, startOfYearPeriod: function() {
    return startOfYearPeriod;
  } });
  var firstDateOfMonth = function(selectedYear, selectedMonth, date2) {
    var newDate = /* @__PURE__ */ new Date(0);
    newDate.setFullYear(selectedYear, selectedMonth, date2);
    return newDate.setHours(0, 0, 0, 0);
  };
  var addDays = function(date2, amount) {
    var newDate = new Date(date2);
    return newDate.setDate(newDate.getDate() + amount);
  };
  var dayDiff = function(day, from) {
    return (day - from + 7) % 7;
  };
  var dayOfTheWeekOf = function(baseDate, dayOfWeek) {
    var weekStart = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var baseDay = new Date(baseDate).getDay();
    return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));
  };
  var addMonths = function(date2, amount) {
    var newDate = date2;
    var monthsToSet = newDate.getMonth() + amount;
    var expectedMonth = monthsToSet % 12;
    if (expectedMonth < 0) {
      expectedMonth += 12;
    }
    var time = newDate.setMonth(monthsToSet);
    return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;
  };
  var addYears = function(date2, amount) {
    var newDate = date2;
    var expectedMonth = newDate.getMonth();
    var time = newDate.setFullYear(newDate.getFullYear() + amount);
    return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;
  };
  var getFormattedDate = function(language, date2, options) {
    var defaultOptions = { day: "numeric", month: "long", year: "numeric" };
    if (options)
      defaultOptions = options;
    return new Intl.DateTimeFormat(language, defaultOptions).format(date2);
  };
  var goToPrevNext = function(view, date2, direction) {
    switch (view) {
      case "days":
        return addMonths(date2, direction);
      case "months":
        return addYears(date2, direction);
      case "years":
        return addYears(date2, direction * 10);
      case "decades":
        return addYears(date2, direction * 100);
      default:
        return addYears(date2, direction * 10);
    }
  };
  var startOfYearPeriod = function(date2, years) {
    var year = date2.getFullYear();
    return Math.floor(year / years) * years;
  };
})(date);
var Buttons = {};
var DatePickerProvider = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, { enumerable: true, get: all[name] });
  }
  _export(exports, { DatePickerContext: function() {
    return DatePickerContext;
  }, default: function() {
    return _default;
  } });
  var _react = _interopRequireWildcard(reactExports);
  var _options = _interopRequireDefault(Options);
  var _date = date;
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
      arr2[i2] = arr[i2];
    return arr2;
  }
  function _arrayWithHoles2(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _iterableToArrayLimit2(arr, i2) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e2;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2)
          break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
  function _nonIterableRest2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function _slicedToArray2(arr, i2) {
    return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i2) || _unsupportedIterableToArray2(arr, i2) || _nonIterableRest2();
  }
  function _unsupportedIterableToArray2(o3, minLen) {
    if (!o3)
      return;
    if (typeof o3 === "string")
      return _arrayLikeToArray2(o3, minLen);
    var n3 = Object.prototype.toString.call(o3).slice(8, -1);
    if (n3 === "Object" && o3.constructor)
      n3 = o3.constructor.name;
    if (n3 === "Map" || n3 === "Set")
      return Array.from(n3);
    if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
      return _arrayLikeToArray2(o3, minLen);
  }
  var DatePickerContext = (0, _react.createContext)({ options: _options.default, view: "days", setView: function() {
  }, show: false, setShow: function() {
  }, selectedDate: /* @__PURE__ */ new Date(), changeSelectedDate: function() {
  }, showSelectedDate: true, setShowSelectedDate: function() {
  }, selectedMonth: 0, selectedYear: 0, getFormattedDate: function() {
    return "";
  } });
  var DatePickerProvider2 = function(param) {
    var children = param.children, customOptions = param.options, onChange2 = param.onChange, show = param.show, setShow = param.setShow, selectedDateState = param.selectedDateState;
    var options = _objectSpread3({}, _options.default, customOptions);
    var ref = _slicedToArray2((0, _react.useState)("days"), 2), view = ref[0], setView = ref[1];
    var ref1 = _slicedToArray2(selectedDateState || (0, _react.useState)((options === null || options === void 0 ? void 0 : options.defaultDate) || /* @__PURE__ */ new Date()), 2), selectedDate = ref1[0], setSelectedDate = ref1[1];
    var ref2 = _slicedToArray2((0, _react.useState)((options === null || options === void 0 ? void 0 : options.defaultDate) !== null), 2), showSelectedDate = ref2[0], setShowSelectedDate = ref2[1];
    var selectedMonth = selectedDate.getMonth();
    var selectedYear = selectedDate.getFullYear();
    var changeSelectedDate = function(action, date2) {
      if ((options === null || options === void 0 ? void 0 : options.maxDate) && date2 > options.maxDate)
        return;
      if ((options === null || options === void 0 ? void 0 : options.minDate) && date2 < options.minDate)
        return;
      if ((options === null || options === void 0 ? void 0 : options.disabledDates) && options.disabledDates.indexOf(date2) >= 0)
        return;
      setSelectedDate(date2);
      setShowSelectedDate(true);
      if ((options === null || options === void 0 ? void 0 : options.autoHide) && view === "days" && action === "date")
        setShow(false);
      if (onChange2)
        onChange2(date2);
    };
    var getFormattedDate = function(date2, formatOptions) {
      return (0, _date.getFormattedDate)((options === null || options === void 0 ? void 0 : options.language) ? options === null || options === void 0 ? void 0 : options.language : "en", date2, formatOptions);
    };
    return _react.default.createElement(DatePickerContext.Provider, { value: { options, view, setView, show, setShow, selectedDate, changeSelectedDate, showSelectedDate, setShowSelectedDate, selectedMonth, selectedYear, getFormattedDate } }, children);
  };
  var _default = DatePickerProvider2;
})(DatePickerProvider);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, { enumerable: true, get: all[name] });
  }
  _export(exports, { ButtonPrevMonth: function() {
    return ButtonPrevMonth;
  }, ButtonSelectMonth: function() {
    return ButtonSelectMonth;
  }, ButtonNextMonth: function() {
    return ButtonNextMonth;
  }, ButtonToday: function() {
    return ButtonToday;
  }, ButtonClear: function() {
    return ButtonClear;
  } });
  var _react = _interopRequireWildcard(reactExports);
  var _tailwindMerge = distExports;
  var _date = date;
  var _datePickerProvider = DatePickerProvider;
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  var ButtonPrevMonth = function() {
    var ref, ref1, ref2;
    var ref3 = (0, _react.useContext)(_datePickerProvider.DatePickerContext), selectedDate = ref3.selectedDate, changeSelectedDate = ref3.changeSelectedDate, view = ref3.view, options = ref3.options;
    return _react.default.createElement("button", { type: "button", className: (0, _tailwindMerge.twMerge)("bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200", options === null || options === void 0 ? void 0 : (ref = options.theme) === null || ref === void 0 ? void 0 : ref.icons), onClick: function() {
      return changeSelectedDate("prev", new Date((0, _date.goToPrevNext)(view, selectedDate, -1)));
    } }, (options === null || options === void 0 ? void 0 : (ref1 = options.icons) === null || ref1 === void 0 ? void 0 : ref1.prev) ? options === null || options === void 0 ? void 0 : (ref2 = options.icons) === null || ref2 === void 0 ? void 0 : ref2.prev() : _react.default.createElement("svg", { className: "w-4 h-4", fill: "currentColor", viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg" }, _react.default.createElement("path", { fillRule: "evenodd", d: "M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z", clipRule: "evenodd" })));
  };
  var ButtonSelectMonth = function() {
    var ref;
    var ref1 = (0, _react.useContext)(_datePickerProvider.DatePickerContext), selectedDate = ref1.selectedDate, view = ref1.view, setView = ref1.setView, options = ref1.options, getFormattedDate = ref1.getFormattedDate;
    var calculateView = function() {
      if (view === "days")
        return "months";
      if (view === "months")
        return "years";
      if (view === "years")
        return "decades";
      return view;
    };
    return _react.default.createElement("button", { type: "button", className: (0, _tailwindMerge.twMerge)("text-sm rounded-lg text-gray-900 dark:text-white bg-white dark:bg-gray-700 font-semibold py-2.5 px-5 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-200", options === null || options === void 0 ? void 0 : (ref = options.theme) === null || ref === void 0 ? void 0 : ref.icons), onClick: function() {
      return setView(calculateView());
    } }, view === "days" && getFormattedDate(selectedDate, { month: "long", year: "numeric" }), view === "months" && getFormattedDate(selectedDate, { year: "numeric" }), view === "years" && "".concat((0, _date.startOfYearPeriod)(selectedDate, 10), "-").concat((0, _date.startOfYearPeriod)(selectedDate, 10) + 9), view === "decades" && "".concat((0, _date.startOfYearPeriod)(selectedDate, 100), "-").concat((0, _date.startOfYearPeriod)(selectedDate, 100) + 90));
  };
  var ButtonNextMonth = function() {
    var ref, ref1, ref2;
    var ref3 = (0, _react.useContext)(_datePickerProvider.DatePickerContext), selectedDate = ref3.selectedDate, changeSelectedDate = ref3.changeSelectedDate, view = ref3.view, options = ref3.options;
    return _react.default.createElement("button", { type: "button", className: (0, _tailwindMerge.twMerge)("bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200", options === null || options === void 0 ? void 0 : (ref = options.theme) === null || ref === void 0 ? void 0 : ref.icons), onClick: function() {
      return changeSelectedDate("next", new Date((0, _date.goToPrevNext)(view, selectedDate, 1)));
    } }, (options === null || options === void 0 ? void 0 : (ref1 = options.icons) === null || ref1 === void 0 ? void 0 : ref1.next) ? options === null || options === void 0 ? void 0 : (ref2 = options.icons) === null || ref2 === void 0 ? void 0 : ref2.next() : _react.default.createElement("svg", { className: "w-4 h-4", fill: "currentColor", viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg" }, _react.default.createElement("path", { fillRule: "evenodd", d: "M12.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-2.293-2.293a1 1 0 010-1.414z", clipRule: "evenodd" })));
  };
  var ButtonToday = function() {
    var ref;
    var ref1 = (0, _react.useContext)(_datePickerProvider.DatePickerContext), changeSelectedDate = ref1.changeSelectedDate, setView = ref1.setView, options = ref1.options;
    return _react.default.createElement("button", { type: "button", className: (0, _tailwindMerge.twMerge)("w-full px-5 py-2 text-sm font-medium text-center text-white bg-blue-700 rounded-lg dark:bg-blue-600 hover:bg-blue-800 dark:hover:bg-blue-700 focus:ring-4 focus:ring-blue-300", options === null || options === void 0 ? void 0 : (ref = options.theme) === null || ref === void 0 ? void 0 : ref.todayBtn), onClick: function() {
      changeSelectedDate("today", /* @__PURE__ */ new Date());
      setView("days");
    } }, options === null || options === void 0 ? void 0 : options.todayBtnText);
  };
  var ButtonClear = function() {
    var ref;
    var ref1 = (0, _react.useContext)(_datePickerProvider.DatePickerContext), setShowSelectedDate = ref1.setShowSelectedDate, options = ref1.options;
    return _react.default.createElement("button", { type: "button", className: (0, _tailwindMerge.twMerge)("w-full px-5 py-2 text-sm font-medium text-center text-gray-900 bg-white border border-gray-300 rounded-lg dark:text-white dark:bg-gray-700 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-600 focus:ring-4 focus:ring-blue-300", options === null || options === void 0 ? void 0 : (ref = options.theme) === null || ref === void 0 ? void 0 : ref.clearBtn), onClick: function() {
      return setShowSelectedDate(false);
    } }, options === null || options === void 0 ? void 0 : options.clearBtnText);
  };
})(Buttons);
var Days = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return _default;
  } });
  var _react = _interopRequireWildcard(reactExports);
  var _date = date;
  var _datePickerProvider = DatePickerProvider;
  var _tailwindMerge = distExports;
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
      arr2[i2] = arr[i2];
    return arr2;
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray2(arr);
  }
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread();
  }
  function _unsupportedIterableToArray2(o3, minLen) {
    if (!o3)
      return;
    if (typeof o3 === "string")
      return _arrayLikeToArray2(o3, minLen);
    var n3 = Object.prototype.toString.call(o3).slice(8, -1);
    if (n3 === "Object" && o3.constructor)
      n3 = o3.constructor.name;
    if (n3 === "Map" || n3 === "Set")
      return Array.from(n3);
    if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
      return _arrayLikeToArray2(o3, minLen);
  }
  var Days2 = function(param) {
    var start = param.start;
    var ref = (0, _react.useContext)(_datePickerProvider.DatePickerContext), selectedDate = ref.selectedDate, changeSelectedDate = ref.changeSelectedDate, showSelectedDate = ref.showSelectedDate, getFormattedDate = ref.getFormattedDate, options = ref.options;
    var startOfWeek = (new Date(start).getDay() + 6) % 7;
    var weekDays = options.weekDays || [];
    var sortedWeekDays = weekDays.slice(startOfWeek).concat(weekDays.slice(0, startOfWeek));
    return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement("div", { className: "grid grid-cols-7 mb-1" }, sortedWeekDays.map(function(day, index2) {
      return _react.default.createElement("span", { key: index2, className: "h-6 text-sm font-medium leading-6 text-center text-gray-500 dow dark:text-gray-400" }, day);
    })), _react.default.createElement("div", { className: "grid w-64 grid-cols-7" }, _toConsumableArray(Array(42)).map(function(_date1, index2) {
      var ref2, ref1, ref22, ref3, ref4;
      var current = (0, _date.addDays)(start, index2);
      var day = getFormattedDate(current, { day: "numeric" });
      var month = getFormattedDate(current, { month: "long" });
      var year = getFormattedDate(current, { year: "numeric" });
      return _react.default.createElement("span", { key: index2, className: "hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center  dark:text-white font-semibold text-sm ".concat(showSelectedDate && selectedDate.getTime() > 0 && getFormattedDate(selectedDate) === getFormattedDate(current) ? (0, _tailwindMerge.twMerge)("bg-blue-700 text-white hover:bg-blue-600", options === null || options === void 0 ? void 0 : (ref2 = options.theme) === null || ref2 === void 0 ? void 0 : ref2.selected) : "", " ").concat(month == getFormattedDate(selectedDate, { month: "long" }) && year == getFormattedDate(selectedDate, { year: "numeric" }) ? (0, _tailwindMerge.twMerge)("text-gray-900", options === null || options === void 0 ? void 0 : (ref1 = options.theme) === null || ref1 === void 0 ? void 0 : ref1.text) : (0, _tailwindMerge.twMerge)("text-gray-500", options === null || options === void 0 ? void 0 : (ref22 = options.theme) === null || ref22 === void 0 ? void 0 : ref22.disabledText), " ").concat((options === null || options === void 0 ? void 0 : options.minDate) && new Date(current) < (options === null || options === void 0 ? void 0 : options.minDate) || (options === null || options === void 0 ? void 0 : options.disabledDates) && options.disabledDates.indexOf(new Date(current)) >= 0 ? (0, _tailwindMerge.twMerge)("text-gray-500", options === null || options === void 0 ? void 0 : (ref3 = options.theme) === null || ref3 === void 0 ? void 0 : ref3.disabledText) : "", " ").concat((options === null || options === void 0 ? void 0 : options.maxDate) && new Date(current) > (options === null || options === void 0 ? void 0 : options.maxDate) || (options === null || options === void 0 ? void 0 : options.disabledDates) && options.disabledDates.indexOf(new Date(current)) >= 0 ? (0, _tailwindMerge.twMerge)("text-gray-500", options === null || options === void 0 ? void 0 : (ref4 = options.theme) === null || ref4 === void 0 ? void 0 : ref4.disabledText) : "", "\n                            "), onClick: function() {
        changeSelectedDate("date", new Date(current));
      } }, day);
    })));
  };
  var _default = Days2;
})(Days);
var Decades = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return _default;
  } });
  var _react = _interopRequireWildcard(reactExports);
  var _date = date;
  var _datePickerProvider = DatePickerProvider;
  var _tailwindMerge = distExports;
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
      arr2[i2] = arr[i2];
    return arr2;
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray2(arr);
  }
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread();
  }
  function _unsupportedIterableToArray2(o3, minLen) {
    if (!o3)
      return;
    if (typeof o3 === "string")
      return _arrayLikeToArray2(o3, minLen);
    var n3 = Object.prototype.toString.call(o3).slice(8, -1);
    if (n3 === "Object" && o3.constructor)
      n3 = o3.constructor.name;
    if (n3 === "Map" || n3 === "Set")
      return Array.from(n3);
    if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
      return _arrayLikeToArray2(o3, minLen);
  }
  var Decades2 = function() {
    var ref = (0, _react.useContext)(_datePickerProvider.DatePickerContext), selectedDate = ref.selectedDate, showSelectedDate = ref.showSelectedDate, changeSelectedDate = ref.changeSelectedDate, setView = ref.setView, getFormattedDate = ref.getFormattedDate, options = ref.options;
    return _react.default.createElement("div", { className: "grid w-64 grid-cols-4" }, _toConsumableArray(Array(12)).map(function(_year, index2) {
      var ref2, ref1, ref22, ref3, ref4;
      var first = (0, _date.startOfYearPeriod)(selectedDate, 100);
      var year = first - 10 + index2 * 10;
      return _react.default.createElement("span", { key: index2, className: "hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center  dark:text-white font-semibold text-sm ".concat(showSelectedDate && selectedDate.getTime() > 0 && Number(getFormattedDate(selectedDate, { year: "numeric" })) === year ? (0, _tailwindMerge.twMerge)("bg-blue-700 text-white hover:bg-blue-600", options === null || options === void 0 ? void 0 : (ref2 = options.theme) === null || ref2 === void 0 ? void 0 : ref2.selected) : "", " ").concat(index2 == 0 || index2 == 11 ? (0, _tailwindMerge.twMerge)("text-gray-500", options === null || options === void 0 ? void 0 : (ref1 = options.theme) === null || ref1 === void 0 ? void 0 : ref1.disabledText) : (0, _tailwindMerge.twMerge)("text-gray-900", options === null || options === void 0 ? void 0 : (ref22 = options.theme) === null || ref22 === void 0 ? void 0 : ref22.text), "\n                            ").concat((options === null || options === void 0 ? void 0 : options.minDate) && year < Number(getFormattedDate(options === null || options === void 0 ? void 0 : options.minDate, { year: "numeric" })) ? (0, _tailwindMerge.twMerge)("text-gray-500", options === null || options === void 0 ? void 0 : (ref3 = options.theme) === null || ref3 === void 0 ? void 0 : ref3.disabledText) : "", "\n                            ").concat((options === null || options === void 0 ? void 0 : options.maxDate) && year > Number(getFormattedDate(options === null || options === void 0 ? void 0 : options.maxDate, { year: "numeric" })) ? (0, _tailwindMerge.twMerge)("text-gray-500", options === null || options === void 0 ? void 0 : (ref4 = options.theme) === null || ref4 === void 0 ? void 0 : ref4.disabledText) : "", "\n                            "), onClick: function() {
        changeSelectedDate("date", new Date((0, _date.addYears)(selectedDate, year - selectedDate.getFullYear())));
        setView("years");
      } }, year);
    }));
  };
  var _default = Decades2;
})(Decades);
var Months = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return _default;
  } });
  var _react = _interopRequireWildcard(reactExports);
  var _date = date;
  var _datePickerProvider = DatePickerProvider;
  var _tailwindMerge = distExports;
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
      arr2[i2] = arr[i2];
    return arr2;
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray2(arr);
  }
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread();
  }
  function _unsupportedIterableToArray2(o3, minLen) {
    if (!o3)
      return;
    if (typeof o3 === "string")
      return _arrayLikeToArray2(o3, minLen);
    var n3 = Object.prototype.toString.call(o3).slice(8, -1);
    if (n3 === "Object" && o3.constructor)
      n3 = o3.constructor.name;
    if (n3 === "Map" || n3 === "Set")
      return Array.from(n3);
    if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
      return _arrayLikeToArray2(o3, minLen);
  }
  var Months2 = function() {
    var ref = (0, _react.useContext)(_datePickerProvider.DatePickerContext), selectedDate = ref.selectedDate, showSelectedDate = ref.showSelectedDate, changeSelectedDate = ref.changeSelectedDate, getFormattedDate = ref.getFormattedDate, setView = ref.setView, options = ref.options;
    return _react.default.createElement("div", { className: "grid w-64 grid-cols-4" }, _toConsumableArray(Array(12)).map(function(_month, index2) {
      var ref2, ref1;
      var month = getFormattedDate(new Date(selectedDate.getFullYear(), index2), { month: "short" });
      return _react.default.createElement("span", { key: index2, className: "hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center  dark:text-white font-semibold text-sm text-gray-900 ".concat(showSelectedDate && selectedDate.getTime() > 0 && getFormattedDate(selectedDate, { month: "short" }) === month ? (0, _tailwindMerge.twMerge)("bg-blue-700 text-white hover:bg-blue-600", options === null || options === void 0 ? void 0 : (ref2 = options.theme) === null || ref2 === void 0 ? void 0 : ref2.selected) : "", " ").concat((0, _tailwindMerge.twMerge)(options === null || options === void 0 ? void 0 : (ref1 = options.theme) === null || ref1 === void 0 ? void 0 : ref1.text)), onClick: function() {
        changeSelectedDate("date", new Date((0, _date.addMonths)(selectedDate, index2 - selectedDate.getMonth())));
        setView("days");
      } }, month);
    }));
  };
  var _default = Months2;
})(Months);
var Years = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return _default;
  } });
  var _react = _interopRequireWildcard(reactExports);
  var _date = date;
  var _datePickerProvider = DatePickerProvider;
  var _tailwindMerge = distExports;
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
      arr2[i2] = arr[i2];
    return arr2;
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray2(arr);
  }
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread();
  }
  function _unsupportedIterableToArray2(o3, minLen) {
    if (!o3)
      return;
    if (typeof o3 === "string")
      return _arrayLikeToArray2(o3, minLen);
    var n3 = Object.prototype.toString.call(o3).slice(8, -1);
    if (n3 === "Object" && o3.constructor)
      n3 = o3.constructor.name;
    if (n3 === "Map" || n3 === "Set")
      return Array.from(n3);
    if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
      return _arrayLikeToArray2(o3, minLen);
  }
  var Years2 = function() {
    var ref = (0, _react.useContext)(_datePickerProvider.DatePickerContext), selectedDate = ref.selectedDate, showSelectedDate = ref.showSelectedDate, changeSelectedDate = ref.changeSelectedDate, setView = ref.setView, getFormattedDate = ref.getFormattedDate, options = ref.options;
    return _react.default.createElement("div", { className: "grid w-64 grid-cols-4" }, _toConsumableArray(Array(12)).map(function(_year, index2) {
      var ref2, ref1, ref22;
      var first = (0, _date.startOfYearPeriod)(selectedDate, 10);
      var year = first - 1 + index2 * 1;
      return _react.default.createElement("span", { key: index2, className: "hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center  dark:text-white font-semibold text-sm ".concat(showSelectedDate && selectedDate.getTime() > 0 && Number(getFormattedDate(selectedDate, { year: "numeric" })) === year ? (0, _tailwindMerge.twMerge)("bg-blue-700 text-white hover:bg-blue-600", options === null || options === void 0 ? void 0 : (ref2 = options.theme) === null || ref2 === void 0 ? void 0 : ref2.selected) : "", " ").concat(index2 == 0 || index2 == 11 ? (0, _tailwindMerge.twMerge)("text-gray-500", options === null || options === void 0 ? void 0 : (ref1 = options.theme) === null || ref1 === void 0 ? void 0 : ref1.disabledText) : (0, _tailwindMerge.twMerge)("text-gray-900", options === null || options === void 0 ? void 0 : (ref22 = options.theme) === null || ref22 === void 0 ? void 0 : ref22.text)), onClick: function() {
        changeSelectedDate("date", new Date((0, _date.addYears)(selectedDate, year - selectedDate.getFullYear())));
        setView("months");
      } }, year);
    }));
  };
  var _default = Years2;
})(Years);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return _default;
  } });
  var _react = _interopRequireWildcard(reactExports);
  var _tailwindMerge = distExports;
  var _date = date;
  var _buttons = Buttons;
  var _datePickerProvider = DatePickerProvider;
  var _days = _interopRequireDefault(Days);
  var _decades = _interopRequireDefault(Decades);
  var _months = _interopRequireDefault(Months);
  var _years = _interopRequireDefault(Years);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  var DatePickerPopup2 = (0, _react.forwardRef)(function(_props, ref) {
    var _$ref, _$ref1, _$ref2;
    var _$ref3 = (0, _react.useContext)(_datePickerProvider.DatePickerContext), selectedMonth = _$ref3.selectedMonth, selectedYear = _$ref3.selectedYear, view = _$ref3.view, options = _$ref3.options;
    var language = (options === null || options === void 0 ? void 0 : options.language) ? options === null || options === void 0 ? void 0 : options.language : "en";
    var locale = new Intl.Locale(language);
    var weekStart = (locale === null || locale === void 0 ? void 0 : (_$ref = locale.weekInfo) === null || _$ref === void 0 ? void 0 : _$ref.firstDay) || 1;
    var firstOfMonth = (0, _date.firstDateOfMonth)(selectedYear, selectedMonth, 1);
    var start = (0, _date.dayOfTheWeekOf)(firstOfMonth, weekStart, weekStart);
    return _react.default.createElement("div", { ref, className: (0, _tailwindMerge.twMerge)("absolute z-50 block pt-2 top-10", options === null || options === void 0 ? void 0 : options.datepickerClassNames) }, _react.default.createElement("div", { className: (0, _tailwindMerge.twMerge)("inline-block p-4 bg-white rounded-lg shadow-lg dark:bg-gray-700", options === null || options === void 0 ? void 0 : (_$ref1 = options.theme) === null || _$ref1 === void 0 ? void 0 : _$ref1.background) }, _react.default.createElement("div", null, (options === null || options === void 0 ? void 0 : options.title) && _react.default.createElement("div", { className: (0, _tailwindMerge.twMerge)("px-2 py-3 font-semibold text-center text-gray-900 dark:text-white", options === null || options === void 0 ? void 0 : (_$ref2 = options.theme) === null || _$ref2 === void 0 ? void 0 : _$ref2.text) }, options === null || options === void 0 ? void 0 : options.title), _react.default.createElement("div", { className: "flex justify-between mb-2" }, _react.default.createElement(_buttons.ButtonPrevMonth, null), _react.default.createElement(_buttons.ButtonSelectMonth, null), _react.default.createElement(_buttons.ButtonNextMonth, null))), _react.default.createElement("div", { className: "p-1" }, view === "days" && _react.default.createElement(_days.default, { start }), view === "months" && _react.default.createElement(_months.default, null), view === "years" && _react.default.createElement(_years.default, null), view === "decades" && _react.default.createElement(_decades.default, null)), ((options === null || options === void 0 ? void 0 : options.todayBtn) || (options === null || options === void 0 ? void 0 : options.clearBtn)) && _react.default.createElement("div", { className: "flex mt-2 space-x-2" }, (options === null || options === void 0 ? void 0 : options.todayBtn) && _react.default.createElement(_buttons.ButtonToday, null), (options === null || options === void 0 ? void 0 : options.clearBtn) && _react.default.createElement(_buttons.ButtonClear, null))));
  });
  DatePickerPopup2.displayName = "DatePickerPopup";
  var _default = DatePickerPopup2;
})(DatePickerPopup);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return _default;
  } });
  var _react = _interopRequireWildcard(reactExports);
  var _tailwindMerge = distExports;
  var _options = _interopRequireDefault(Options);
  var _datePickerPopup = _interopRequireDefault(DatePickerPopup);
  var _datePickerProvider = _interopRequireWildcard(DatePickerProvider);
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  var DatePicker2 = function(param) {
    var value = param.value, children = param.children, options = param.options, onChange2 = param.onChange, classNames2 = param.classNames, show = param.show, setShow = param.setShow, selectedDateState = param.selectedDateState;
    return _react.default.createElement("div", { className: (0, _tailwindMerge.twMerge)("w-full", classNames2) }, _react.default.createElement(_datePickerProvider.default, { options, onChange: onChange2, show, setShow, selectedDateState }, _react.default.createElement(DatePickerMain, { value, options }, children)));
  };
  var DatePickerMain = function(param) {
    var value = param.value, customOptions = param.options, children = param.children;
    var options = _objectSpread3({}, _options.default, customOptions);
    var ref = (0, _react.useContext)(_datePickerProvider.DatePickerContext), setShow = ref.setShow, show = ref.show;
    var InputRef = (0, _react.useRef)(null);
    var DatePickerRef = (0, _react.useRef)(null);
    (0, _react.useEffect)(function() {
      var handleClickOutside = function(event) {
        if (!((InputRef === null || InputRef === void 0 ? void 0 : InputRef.current) && (DatePickerRef === null || DatePickerRef === void 0 ? void 0 : DatePickerRef.current)))
          return;
        if (!InputRef.current.contains(event.target) && !DatePickerRef.current.contains(event.target)) {
          setShow(false);
        }
      };
      document.addEventListener("mousedown", function(event) {
        return handleClickOutside(event);
      });
      return function() {
        document.removeEventListener("mousedown", function(event) {
          return handleClickOutside(event);
        });
      };
    }, [DatePickerRef, InputRef, setShow]);
    return _react.default.createElement(_react.default.Fragment, null, children ? children : _react.default.createElement("div", { className: "relative" }, _react.default.createElement("div", { className: "absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none" }, _react.default.createElement(CalendarIcon, null)), _react.default.createElement(Input2, { ref: InputRef, idProp: options === null || options === void 0 ? void 0 : options.inputIdProp, valueProp: value, nameProp: options === null || options === void 0 ? void 0 : options.inputNameProp, placeholderProp: options === null || options === void 0 ? void 0 : options.inputPlaceholderProp, dateFormat: options === null || options === void 0 ? void 0 : options.inputDateFormatProp })), show && _react.default.createElement(_datePickerPopup.default, { ref: DatePickerRef }));
  };
  var Input2 = (0, _react.forwardRef)(function(props, ref) {
    var _$ref;
    var _$ref1 = (0, _react.useContext)(_datePickerProvider.DatePickerContext), setShow = _$ref1.setShow, selectedDate = _$ref1.selectedDate, showSelectedDate = _$ref1.showSelectedDate, options = _$ref1.options, getFormattedDate = _$ref1.getFormattedDate;
    var nameProp = props.nameProp || "date";
    var idProp = props.idProp || nameProp;
    var placeholderProp = props.placeholderProp || "Select Date";
    var valueProp = props.valueProp;
    var format2 = props.dateFormat || null;
    return _react.default.createElement("input", { ref, type: "text", name: nameProp, id: idProp, className: (0, _tailwindMerge.twMerge)("pl-9 pr-2.5 py-2.5 bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full  dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500", options === null || options === void 0 ? void 0 : (_$ref = options.theme) === null || _$ref === void 0 ? void 0 : _$ref.input), placeholder: placeholderProp, value: valueProp ? getFormattedDate(valueProp, format2) : selectedDate && showSelectedDate ? getFormattedDate(selectedDate, format2) : "", onFocus: function() {
      return setShow(true);
    }, readOnly: true });
  });
  Input2.displayName = "Input";
  var CalendarIcon = function() {
    var ref;
    var options = (0, _react.useContext)(_datePickerProvider.DatePickerContext).options;
    return _react.default.createElement("svg", { "aria-hidden": "true", className: (0, _tailwindMerge.twMerge)("w-5 h-5 text-gray-500 dark:text-gray-400", options === null || options === void 0 ? void 0 : (ref = options.theme) === null || ref === void 0 ? void 0 : ref.inputIcon), fill: "currentColor", viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg" }, _react.default.createElement("path", { fillRule: "evenodd", d: "M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z", clipRule: "evenodd" }));
  };
  var _default = DatePicker2;
})(DatePicker);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return _default;
  } });
  var _datePicker = _interopRequireDefault(DatePicker);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var _default = _datePicker.default;
})(dist$1);
const Datepicker = /* @__PURE__ */ getDefaultExportFromCjs(dist$1);
const DateInput = reactExports.forwardRef(function DateInput2({ map, className = "", isFocused = false, ...props }, ref) {
  const input = ref ? ref : reactExports.useRef(null);
  const [show, setShow] = reactExports.useState(false);
  const options = {
    autoHide: true,
    todayBtn: false,
    clearBtn: true,
    clearBtnText: "Clear",
    maxDate: /* @__PURE__ */ new Date("2030-01-01"),
    minDate: /* @__PURE__ */ new Date("1950-01-01"),
    theme: {
      background: "",
      todayBtn: "",
      clearBtn: "",
      icons: "",
      text: "",
      disabledText: "",
      input: "bg-white mt-0 border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5 mt-1 text-md block w-full text-black",
      inputIcon: "text-gray-700",
      selected: ""
    },
    icons: {
      // () => ReactElement | JSX.Element
      prev: () => /* @__PURE__ */ jsxRuntimeExports.jsx(AppIcon, { icon: "chevron-left", className: "h-4" }),
      next: () => /* @__PURE__ */ jsxRuntimeExports.jsx(AppIcon, { icon: "chevron-right", className: "h-4" })
    },
    defaultDate: props.value ? new Date(props.value) : null,
    language: "en",
    disabledDates: [],
    weekDays: ["Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
    inputNameProp: "date",
    inputIdProp: "date",
    inputPlaceholderProp: "Select Date",
    inputDateFormatProp: {
      day: "numeric",
      month: "long",
      year: "numeric"
    }
  };
  const handleClose = (state) => {
    setShow(state);
  };
  reactExports.useEffect(() => {
    if (isFocused) {
      input.current.focus();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Datepicker,
    {
      show,
      setShow: handleClose,
      ...props,
      options,
      onChange: (date2) => {
        props.onChange && props.onChange(date2);
      },
      value: props.value ? new Date(props.value) : null,
      classNames: "border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5 " + className
    }
  );
});
const AgeInput = reactExports.forwardRef(function AgeInputProps({ map, className = "", isFocused = false, value, ...props }, ref) {
  const input = ref ? ref : reactExports.useRef(null);
  const [title, setTitle] = reactExports.useState(value == null ? void 0 : value.title);
  const [age, setAgeValue] = reactExports.useState(value == null ? void 0 : value.value);
  const updateDate = (dataType, e2) => {
    dataType === "title" && setTitle(e2.target.value);
    dataType === "value" && setAgeValue(Number(e2.target.value));
    const ageValue = {
      title,
      value: age
    };
    props.onChange && props.onChange(ageValue);
    props.onBlur && props.onBlur(ageValue);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-0", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1 block w-1/3 flex-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "number",
        name: map + `_value`,
        onChange: (e2) => updateDate("value", e2),
        onBlur: (e2) => updateDate("value", e2),
        className: "border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5 " + className,
        ref: input
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1 block w-1/3 flex-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "select",
      {
        onChange: (e2) => updateDate("title", e2),
        className: "w-full flex bg-white border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm ",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "years", children: "Years" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "months", children: "Months" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "day", children: "days" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "hours", children: "hours" })
        ]
      },
      map + `_title`
    ) })
  ] });
});
const metadata$1 = { "version": 4, "country_calling_codes": { "1": ["US", "AG", "AI", "AS", "BB", "BM", "BS", "CA", "DM", "DO", "GD", "GU", "JM", "KN", "KY", "LC", "MP", "MS", "PR", "SX", "TC", "TT", "VC", "VG", "VI"], "7": ["RU", "KZ"], "20": ["EG"], "27": ["ZA"], "30": ["GR"], "31": ["NL"], "32": ["BE"], "33": ["FR"], "34": ["ES"], "36": ["HU"], "39": ["IT", "VA"], "40": ["RO"], "41": ["CH"], "43": ["AT"], "44": ["GB", "GG", "IM", "JE"], "45": ["DK"], "46": ["SE"], "47": ["NO", "SJ"], "48": ["PL"], "49": ["DE"], "51": ["PE"], "52": ["MX"], "53": ["CU"], "54": ["AR"], "55": ["BR"], "56": ["CL"], "57": ["CO"], "58": ["VE"], "60": ["MY"], "61": ["AU", "CC", "CX"], "62": ["ID"], "63": ["PH"], "64": ["NZ"], "65": ["SG"], "66": ["TH"], "81": ["JP"], "82": ["KR"], "84": ["VN"], "86": ["CN"], "90": ["TR"], "91": ["IN"], "92": ["PK"], "93": ["AF"], "94": ["LK"], "95": ["MM"], "98": ["IR"], "211": ["SS"], "212": ["MA", "EH"], "213": ["DZ"], "216": ["TN"], "218": ["LY"], "220": ["GM"], "221": ["SN"], "222": ["MR"], "223": ["ML"], "224": ["GN"], "225": ["CI"], "226": ["BF"], "227": ["NE"], "228": ["TG"], "229": ["BJ"], "230": ["MU"], "231": ["LR"], "232": ["SL"], "233": ["GH"], "234": ["NG"], "235": ["TD"], "236": ["CF"], "237": ["CM"], "238": ["CV"], "239": ["ST"], "240": ["GQ"], "241": ["GA"], "242": ["CG"], "243": ["CD"], "244": ["AO"], "245": ["GW"], "246": ["IO"], "247": ["AC"], "248": ["SC"], "249": ["SD"], "250": ["RW"], "251": ["ET"], "252": ["SO"], "253": ["DJ"], "254": ["KE"], "255": ["TZ"], "256": ["UG"], "257": ["BI"], "258": ["MZ"], "260": ["ZM"], "261": ["MG"], "262": ["RE", "YT"], "263": ["ZW"], "264": ["NA"], "265": ["MW"], "266": ["LS"], "267": ["BW"], "268": ["SZ"], "269": ["KM"], "290": ["SH", "TA"], "291": ["ER"], "297": ["AW"], "298": ["FO"], "299": ["GL"], "350": ["GI"], "351": ["PT"], "352": ["LU"], "353": ["IE"], "354": ["IS"], "355": ["AL"], "356": ["MT"], "357": ["CY"], "358": ["FI", "AX"], "359": ["BG"], "370": ["LT"], "371": ["LV"], "372": ["EE"], "373": ["MD"], "374": ["AM"], "375": ["BY"], "376": ["AD"], "377": ["MC"], "378": ["SM"], "380": ["UA"], "381": ["RS"], "382": ["ME"], "383": ["XK"], "385": ["HR"], "386": ["SI"], "387": ["BA"], "389": ["MK"], "420": ["CZ"], "421": ["SK"], "423": ["LI"], "500": ["FK"], "501": ["BZ"], "502": ["GT"], "503": ["SV"], "504": ["HN"], "505": ["NI"], "506": ["CR"], "507": ["PA"], "508": ["PM"], "509": ["HT"], "590": ["GP", "BL", "MF"], "591": ["BO"], "592": ["GY"], "593": ["EC"], "594": ["GF"], "595": ["PY"], "596": ["MQ"], "597": ["SR"], "598": ["UY"], "599": ["CW", "BQ"], "670": ["TL"], "672": ["NF"], "673": ["BN"], "674": ["NR"], "675": ["PG"], "676": ["TO"], "677": ["SB"], "678": ["VU"], "679": ["FJ"], "680": ["PW"], "681": ["WF"], "682": ["CK"], "683": ["NU"], "685": ["WS"], "686": ["KI"], "687": ["NC"], "688": ["TV"], "689": ["PF"], "690": ["TK"], "691": ["FM"], "692": ["MH"], "850": ["KP"], "852": ["HK"], "853": ["MO"], "855": ["KH"], "856": ["LA"], "880": ["BD"], "886": ["TW"], "960": ["MV"], "961": ["LB"], "962": ["JO"], "963": ["SY"], "964": ["IQ"], "965": ["KW"], "966": ["SA"], "967": ["YE"], "968": ["OM"], "970": ["PS"], "971": ["AE"], "972": ["IL"], "973": ["BH"], "974": ["QA"], "975": ["BT"], "976": ["MN"], "977": ["NP"], "992": ["TJ"], "993": ["TM"], "994": ["AZ"], "995": ["GE"], "996": ["KG"], "998": ["UZ"] }, "countries": { "AC": ["247", "00", "(?:[01589]\\d|[46])\\d{4}", [5, 6]], "AD": ["376", "00", "(?:1|6\\d)\\d{7}|[135-9]\\d{5}", [6, 8, 9], [["(\\d{3})(\\d{3})", "$1 $2", ["[135-9]"]], ["(\\d{4})(\\d{4})", "$1 $2", ["1"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6"]]]], "AE": ["971", "00", "(?:[4-7]\\d|9[0-689])\\d{7}|800\\d{2,9}|[2-4679]\\d{7}", [5, 6, 7, 8, 9, 10, 11, 12], [["(\\d{3})(\\d{2,9})", "$1 $2", ["60|8"]], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[236]|[479][2-8]"], "0$1"], ["(\\d{3})(\\d)(\\d{5})", "$1 $2 $3", ["[479]"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["5"], "0$1"]], "0"], "AF": ["93", "00", "[2-7]\\d{8}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-7]"], "0$1"]], "0"], "AG": ["1", "011", "(?:268|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([457]\\d{6})$|1", "268$1", 0, "268"], "AI": ["1", "011", "(?:264|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2457]\\d{6})$|1", "264$1", 0, "264"], "AL": ["355", "00", "(?:700\\d\\d|900)\\d{3}|8\\d{5,7}|(?:[2-5]|6\\d)\\d{7}", [6, 7, 8, 9], [["(\\d{3})(\\d{3,4})", "$1 $2", ["80|9"], "0$1"], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["4[2-6]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2358][2-5]|4"], "0$1"], ["(\\d{3})(\\d{5})", "$1 $2", ["[23578]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["6"], "0$1"]], "0"], "AM": ["374", "00", "(?:[1-489]\\d|55|60|77)\\d{6}", [8], [["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[89]0"], "0 $1"], ["(\\d{3})(\\d{5})", "$1 $2", ["2|3[12]"], "(0$1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["1|47"], "(0$1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["[3-9]"], "0$1"]], "0"], "AO": ["244", "00", "[29]\\d{8}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[29]"]]]], "AR": ["54", "00", "(?:11|[89]\\d\\d)\\d{8}|[2368]\\d{9}", [10, 11], [["(\\d{4})(\\d{2})(\\d{4})", "$1 $2-$3", ["2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9])", "2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8]))|2(?:2[24-9]|3[1-59]|47)", "2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5[56][46]|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]", "2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|58|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|54(?:4|5[13-7]|6[89])|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:454|85[56])[46]|3(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"], "0$1", 1], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2-$3", ["1"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2-$3", ["[68]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2-$3", ["[23]"], "0$1", 1], ["(\\d)(\\d{4})(\\d{2})(\\d{4})", "$2 15-$3-$4", ["9(?:2[2-469]|3[3-578])", "9(?:2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9]))", "9(?:2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8])))|92(?:2[24-9]|3[1-59]|47)", "9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5(?:[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]", "9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|5(?:4(?:4|5[13-7]|6[89])|[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"], "0$1", 0, "$1 $2 $3-$4"], ["(\\d)(\\d{2})(\\d{4})(\\d{4})", "$2 15-$3-$4", ["91"], "0$1", 0, "$1 $2 $3-$4"], ["(\\d{3})(\\d{3})(\\d{5})", "$1-$2-$3", ["8"], "0$1"], ["(\\d)(\\d{3})(\\d{3})(\\d{4})", "$2 15-$3-$4", ["9"], "0$1", 0, "$1 $2 $3-$4"]], "0", 0, "0?(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1267])|3(?:02?|1[467]|2[03-6]|3[13-8]|[49][2-6]|5[2-8]|[67])|4(?:7[3-578]|9)|6(?:[0136]|2[24-6]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\d|3[1-6]|4[02568]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|6|8[2578])|4(?:0[0-24-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6[02-9]|7[126]|8[2379]?|9[1-36-8])|5(?:1|2[1245]|3[237]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:[069]|1[1568]|2[15]|3[145]|4[13]|5[14-8]|7[2-57]|8[126])|8(?:[01]|2[15-7]|3[2578]?|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))15)?", "9$1"], "AS": ["1", "011", "(?:[58]\\d\\d|684|900)\\d{7}", [10], 0, "1", 0, "([267]\\d{6})$|1", "684$1", 0, "684"], "AT": ["43", "00", "1\\d{3,12}|2\\d{6,12}|43(?:(?:0\\d|5[02-9])\\d{3,9}|2\\d{4,5}|[3467]\\d{4}|8\\d{4,6}|9\\d{4,7})|5\\d{4,12}|8\\d{7,12}|9\\d{8,12}|(?:[367]\\d|4[0-24-9])\\d{4,11}", [4, 5, 6, 7, 8, 9, 10, 11, 12, 13], [["(\\d)(\\d{3,12})", "$1 $2", ["1(?:11|[2-9])"], "0$1"], ["(\\d{3})(\\d{2})", "$1 $2", ["517"], "0$1"], ["(\\d{2})(\\d{3,5})", "$1 $2", ["5[079]"], "0$1"], ["(\\d{3})(\\d{3,10})", "$1 $2", ["(?:31|4)6|51|6(?:5[0-3579]|[6-9])|7(?:20|32|8)|[89]"], "0$1"], ["(\\d{4})(\\d{3,9})", "$1 $2", ["[2-467]|5[2-6]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["5"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4,7})", "$1 $2 $3", ["5"], "0$1"]], "0"], "AU": ["61", "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011", "1(?:[0-79]\\d{7}(?:\\d(?:\\d{2})?)?|8[0-24-9]\\d{7})|[2-478]\\d{8}|1\\d{4,7}", [5, 6, 7, 8, 9, 10, 12], [["(\\d{2})(\\d{3,4})", "$1 $2", ["16"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2,4})", "$1 $2 $3", ["16"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["14|4"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["[2378]"], "(0$1)"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1(?:30|[89])"]]], "0", 0, "(183[12])|0", 0, 0, 0, [["(?:(?:(?:2(?:[0-26-9]\\d|3[0-8]|4[02-9]|5[0135-9])|7(?:[013-57-9]\\d|2[0-8]))\\d|3(?:(?:[0-3589]\\d|6[1-9]|7[0-35-9])\\d|4(?:[0-578]\\d|90)))\\d\\d|8(?:51(?:0(?:0[03-9]|[12479]\\d|3[2-9]|5[0-8]|6[1-9]|8[0-7])|1(?:[0235689]\\d|1[0-69]|4[0-589]|7[0-47-9])|2(?:0[0-79]|[18][13579]|2[14-9]|3[0-46-9]|[4-6]\\d|7[89]|9[0-4])|3\\d\\d)|(?:6[0-8]|[78]\\d)\\d{3}|9(?:[02-9]\\d{3}|1(?:(?:[0-58]\\d|6[0135-9])\\d|7(?:0[0-24-9]|[1-9]\\d)|9(?:[0-46-9]\\d|5[0-79])))))\\d{3}", [9]], ["4(?:(?:79|94)[01]|83[0-389])\\d{5}|4(?:[0-3]\\d|4[047-9]|5[0-25-9]|6[0-36-9]|7[02-8]|8[0-24-9]|9[0-37-9])\\d{6}", [9]], ["180(?:0\\d{3}|2)\\d{3}", [7, 10]], ["190[0-26]\\d{6}", [10]], 0, 0, 0, ["163\\d{2,6}", [5, 6, 7, 8, 9]], ["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}", [9]], ["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}", [6, 8, 10, 12]]], "0011"], "AW": ["297", "00", "(?:[25-79]\\d\\d|800)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[25-9]"]]]], "AX": ["358", "00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))", "2\\d{4,9}|35\\d{4,5}|(?:60\\d\\d|800)\\d{4,6}|7\\d{5,11}|(?:[14]\\d|3[0-46-9]|50)\\d{4,8}", [5, 6, 7, 8, 9, 10, 11, 12], 0, "0", 0, 0, 0, 0, "18", 0, "00"], "AZ": ["994", "00", "365\\d{6}|(?:[124579]\\d|60|88)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["90"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["1[28]|2|365|46", "1[28]|2|365[45]|46", "1[28]|2|365(?:4|5[02])|46"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[13-9]"], "0$1"]], "0"], "BA": ["387", "00", "6\\d{8}|(?:[35689]\\d|49|70)\\d{6}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["6[1-3]|[7-9]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2-$3", ["[3-5]|6[56]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["6"], "0$1"]], "0"], "BB": ["1", "011", "(?:246|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "246$1", 0, "246"], "BD": ["880", "00", "[1-469]\\d{9}|8[0-79]\\d{7,8}|[2-79]\\d{8}|[2-9]\\d{7}|[3-9]\\d{6}|[57-9]\\d{5}", [6, 7, 8, 9, 10], [["(\\d{2})(\\d{4,6})", "$1-$2", ["31[5-8]|[459]1"], "0$1"], ["(\\d{3})(\\d{3,7})", "$1-$2", ["3(?:[67]|8[013-9])|4(?:6[168]|7|[89][18])|5(?:6[128]|9)|6(?:[15]|28|4[14])|7[2-589]|8(?:0[014-9]|[12])|9[358]|(?:3[2-5]|4[235]|5[2-578]|6[0389]|76|8[3-7]|9[24])1|(?:44|66)[01346-9]"], "0$1"], ["(\\d{4})(\\d{3,6})", "$1-$2", ["[13-9]|22"], "0$1"], ["(\\d)(\\d{7,8})", "$1-$2", ["2"], "0$1"]], "0"], "BE": ["32", "00", "4\\d{8}|[1-9]\\d{7}", [8, 9], [["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["(?:80|9)0"], "0$1"], ["(\\d)(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[239]|4[23]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[15-8]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["4"], "0$1"]], "0"], "BF": ["226", "00", "[025-7]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[025-7]"]]]], "BG": ["359", "00", "00800\\d{7}|[2-7]\\d{6,7}|[89]\\d{6,8}|2\\d{5}", [6, 7, 8, 9, 12], [["(\\d)(\\d)(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["2"], "0$1"], ["(\\d{3})(\\d{4})", "$1 $2", ["43[1-6]|70[1-9]"], "0$1"], ["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2,3})", "$1 $2 $3", ["[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["(?:70|8)0"], "0$1"], ["(\\d{3})(\\d{3})(\\d{2})", "$1 $2 $3", ["43[1-7]|7"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[48]|9[08]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"], "0$1"]], "0"], "BH": ["973", "00", "[136-9]\\d{7}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[13679]|8[02-4679]"]]]], "BI": ["257", "00", "(?:[267]\\d|31)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2367]"]]]], "BJ": ["229", "00", "[24-689]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[24-689]"]]]], "BL": ["590", "00", "590\\d{6}|(?:69|80|9\\d)\\d{7}", [9], 0, "0", 0, 0, 0, 0, 0, [["590(?:2[7-9]|3[3-7]|5[12]|87)\\d{4}"], ["69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))\\d{4}"], ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:39[5-7]|76[018])\\d|475[0-5])\\d{4}"]]], "BM": ["1", "011", "(?:441|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "441$1", 0, "441"], "BN": ["673", "00", "[2-578]\\d{6}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-578]"]]]], "BO": ["591", "00(?:1\\d)?", "(?:[2-467]\\d\\d|8001)\\d{5}", [8, 9], [["(\\d)(\\d{7})", "$1 $2", ["[23]|4[46]"]], ["(\\d{8})", "$1", ["[67]"]], ["(\\d{3})(\\d{2})(\\d{4})", "$1 $2 $3", ["8"]]], "0", 0, "0(1\\d)?"], "BQ": ["599", "00", "(?:[34]1|7\\d)\\d{5}", [7], 0, 0, 0, 0, 0, 0, "[347]"], "BR": ["55", "00(?:1[245]|2[1-35]|31|4[13]|[56]5|99)", "(?:[1-46-9]\\d\\d|5(?:[0-46-9]\\d|5[0-46-9]))\\d{8}|[1-9]\\d{9}|[3589]\\d{8}|[34]\\d{7}", [8, 9, 10, 11], [["(\\d{4})(\\d{4})", "$1-$2", ["300|4(?:0[02]|37)", "4(?:02|37)0|[34]00"]], ["(\\d{3})(\\d{2,3})(\\d{4})", "$1 $2 $3", ["(?:[358]|90)0"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2-$3", ["(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-57]"], "($1)"], ["(\\d{2})(\\d{5})(\\d{4})", "$1 $2-$3", ["[16][1-9]|[2-57-9]"], "($1)"]], "0", 0, "(?:0|90)(?:(1[245]|2[1-35]|31|4[13]|[56]5|99)(\\d{10,11}))?", "$2"], "BS": ["1", "011", "(?:242|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([3-8]\\d{6})$|1", "242$1", 0, "242"], "BT": ["975", "00", "[17]\\d{7}|[2-8]\\d{6}", [7, 8], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-68]|7[246]"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["1[67]|7"]]]], "BW": ["267", "00", "(?:0800|(?:[37]|800)\\d)\\d{6}|(?:[2-6]\\d|90)\\d{5}", [7, 8, 10], [["(\\d{2})(\\d{5})", "$1 $2", ["90"]], ["(\\d{3})(\\d{4})", "$1 $2", ["[24-6]|3[15-9]"]], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[37]"]], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["0"]], ["(\\d{3})(\\d{4})(\\d{3})", "$1 $2 $3", ["8"]]]], "BY": ["375", "810", "(?:[12]\\d|33|44|902)\\d{7}|8(?:0[0-79]\\d{5,7}|[1-7]\\d{9})|8(?:1[0-489]|[5-79]\\d)\\d{7}|8[1-79]\\d{6,7}|8[0-79]\\d{5}|8\\d{5}", [6, 7, 8, 9, 10, 11], [["(\\d{3})(\\d{3})", "$1 $2", ["800"], "8 $1"], ["(\\d{3})(\\d{2})(\\d{2,4})", "$1 $2 $3", ["800"], "8 $1"], ["(\\d{4})(\\d{2})(\\d{3})", "$1 $2-$3", ["1(?:5[169]|6[3-5]|7[179])|2(?:1[35]|2[34]|3[3-5])", "1(?:5[169]|6(?:3[1-3]|4|5[125])|7(?:1[3-9]|7[0-24-6]|9[2-7]))|2(?:1[35]|2[34]|3[3-5])"], "8 0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["1(?:[56]|7[467])|2[1-3]"], "8 0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["[1-4]"], "8 0$1"], ["(\\d{3})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["[89]"], "8 $1"]], "8", 0, "0|80?", 0, 0, 0, 0, "8~10"], "BZ": ["501", "00", "(?:0800\\d|[2-8])\\d{6}", [7, 11], [["(\\d{3})(\\d{4})", "$1-$2", ["[2-8]"]], ["(\\d)(\\d{3})(\\d{4})(\\d{3})", "$1-$2-$3-$4", ["0"]]]], "CA": ["1", "011", "(?:[2-8]\\d|90)\\d{8}|3\\d{6}", [7, 10], 0, "1", 0, 0, 0, 0, 0, [["(?:2(?:04|[23]6|[48]9|50|63)|3(?:06|43|54|6[578]|82)|4(?:03|1[68]|[26]8|3[178]|50|74)|5(?:06|1[49]|48|79|8[147])|6(?:04|[18]3|39|47|72)|7(?:0[59]|42|53|78|8[02])|8(?:[06]7|19|25|7[39])|90[25])[2-9]\\d{6}", [10]], ["", [10]], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}", [10]], ["900[2-9]\\d{6}", [10]], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|(?:5(?:00|2[125-9]|33|44|66|77|88)|622)[2-9]\\d{6}", [10]], 0, ["310\\d{4}", [7]], 0, ["600[2-9]\\d{6}", [10]]]], "CC": ["61", "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011", "1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}", [6, 7, 8, 9, 10, 12], 0, "0", 0, "([59]\\d{7})$|0", "8$1", 0, 0, [["8(?:51(?:0(?:02|31|60|89)|1(?:18|76)|223)|91(?:0(?:1[0-2]|29)|1(?:[28]2|50|79)|2(?:10|64)|3(?:[06]8|22)|4[29]8|62\\d|70[23]|959))\\d{3}", [9]], ["4(?:(?:79|94)[01]|83[0-389])\\d{5}|4(?:[0-3]\\d|4[047-9]|5[0-25-9]|6[0-36-9]|7[02-8]|8[0-24-9]|9[0-37-9])\\d{6}", [9]], ["180(?:0\\d{3}|2)\\d{3}", [7, 10]], ["190[0-26]\\d{6}", [10]], 0, 0, 0, 0, ["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}", [9]], ["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}", [6, 8, 10, 12]]], "0011"], "CD": ["243", "00", "[189]\\d{8}|[1-68]\\d{6}", [7, 9], [["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["88"], "0$1"], ["(\\d{2})(\\d{5})", "$1 $2", ["[1-6]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[89]"], "0$1"]], "0"], "CF": ["236", "00", "(?:[27]\\d{3}|8776)\\d{4}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[278]"]]]], "CG": ["242", "00", "222\\d{6}|(?:0\\d|80)\\d{7}", [9], [["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["8"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[02]"]]]], "CH": ["41", "00", "8\\d{11}|[2-9]\\d{8}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8[047]|90"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-79]|81"], "0$1"], ["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["8"], "0$1"]], "0"], "CI": ["225", "00", "[02]\\d{9}", [10], [["(\\d{2})(\\d{2})(\\d)(\\d{5})", "$1 $2 $3 $4", ["2"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3 $4", ["0"]]]], "CK": ["682", "00", "[2-578]\\d{4}", [5], [["(\\d{2})(\\d{3})", "$1 $2", ["[2-578]"]]]], "CL": ["56", "(?:0|1(?:1[0-69]|2[02-5]|5[13-58]|69|7[0167]|8[018]))0", "12300\\d{6}|6\\d{9,10}|[2-9]\\d{8}", [9, 10, 11], [["(\\d{5})(\\d{4})", "$1 $2", ["219", "2196"], "($1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["44"]], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["2[1-36]"], "($1)"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["9[2-9]"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["3[2-5]|[47]|5[1-3578]|6[13-57]|8(?:0[1-9]|[1-9])"], "($1)"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["60|8"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]], ["(\\d{3})(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["60"]]]], "CM": ["237", "00", "[26]\\d{8}|88\\d{6,7}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["88"]], ["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["[26]|88"]]]], "CN": ["86", "00|1(?:[12]\\d|79)\\d\\d00", "1[127]\\d{8,9}|2\\d{9}(?:\\d{2})?|[12]\\d{6,7}|86\\d{6}|(?:1[03-689]\\d|6)\\d{7,9}|(?:[3-579]\\d|8[0-57-9])\\d{6,9}", [7, 8, 9, 10, 11, 12], [["(\\d{2})(\\d{5,6})", "$1 $2", ["(?:10|2[0-57-9])[19]", "(?:10|2[0-57-9])(?:10|9[56])", "10(?:10|9[56])|2[0-57-9](?:100|9[56])"], "0$1"], ["(\\d{3})(\\d{5,6})", "$1 $2", ["3(?:[157]|35|49|9[1-68])|4(?:[17]|2[179]|6[47-9]|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])|(?:4[35]|59|85)[1-9]", "(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))[19]", "85[23](?:10|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:10|9[56])", "85[23](?:100|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:100|9[56])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["(?:4|80)0"]], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["10|2(?:[02-57-9]|1[1-9])", "10|2(?:[02-57-9]|1[1-9])", "10[0-79]|2(?:[02-57-9]|1[1-79])|(?:10|21)8(?:0[1-9]|[1-9])"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["3(?:[3-59]|7[02-68])|4(?:[26-8]|3[3-9]|5[2-9])|5(?:3[03-9]|[468]|7[028]|9[2-46-9])|6|7(?:[0-247]|3[04-9]|5[0-4689]|6[2368])|8(?:[1-358]|9[1-7])|9(?:[013479]|5[1-5])|(?:[34]1|55|79|87)[02-9]"], "0$1", 1], ["(\\d{3})(\\d{7,8})", "$1 $2", ["9"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["80"], "0$1", 1], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["[3-578]"], "0$1", 1], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["1[3-9]"]], ["(\\d{2})(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["[12]"], "0$1", 1]], "0", 0, "(1(?:[12]\\d|79)\\d\\d)|0", 0, 0, 0, 0, "00"], "CO": ["57", "00(?:4(?:[14]4|56)|[579])", "(?:60\\d\\d|9101)\\d{6}|(?:1\\d|3)\\d{9}", [10, 11], [["(\\d{3})(\\d{7})", "$1 $2", ["6"], "($1)"], ["(\\d{3})(\\d{7})", "$1 $2", ["3[0-357]|91"]], ["(\\d)(\\d{3})(\\d{7})", "$1-$2-$3", ["1"], "0$1", 0, "$1 $2 $3"]], "0", 0, "0([3579]|4(?:[14]4|56))?"], "CR": ["506", "00", "(?:8\\d|90)\\d{8}|(?:[24-8]\\d{3}|3005)\\d{4}", [8, 10], [["(\\d{4})(\\d{4})", "$1 $2", ["[2-7]|8[3-9]"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2-$3", ["[89]"]]], 0, 0, "(19(?:0[0-2468]|1[09]|20|66|77|99))"], "CU": ["53", "119", "(?:[2-7]|8\\d\\d)\\d{7}|[2-47]\\d{6}|[34]\\d{5}", [6, 7, 8, 10], [["(\\d{2})(\\d{4,6})", "$1 $2", ["2[1-4]|[34]"], "(0$1)"], ["(\\d)(\\d{6,7})", "$1 $2", ["7"], "(0$1)"], ["(\\d)(\\d{7})", "$1 $2", ["[56]"], "0$1"], ["(\\d{3})(\\d{7})", "$1 $2", ["8"], "0$1"]], "0"], "CV": ["238", "0", "(?:[2-59]\\d\\d|800)\\d{4}", [7], [["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["[2-589]"]]]], "CW": ["599", "00", "(?:[34]1|60|(?:7|9\\d)\\d)\\d{5}", [7, 8], [["(\\d{3})(\\d{4})", "$1 $2", ["[3467]"]], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["9[4-8]"]]], 0, 0, 0, 0, 0, "[69]"], "CX": ["61", "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011", "1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}", [6, 7, 8, 9, 10, 12], 0, "0", 0, "([59]\\d{7})$|0", "8$1", 0, 0, [["8(?:51(?:0(?:01|30|59|88)|1(?:17|46|75)|2(?:22|35))|91(?:00[6-9]|1(?:[28]1|49|78)|2(?:09|63)|3(?:12|26|75)|4(?:56|97)|64\\d|7(?:0[01]|1[0-2])|958))\\d{3}", [9]], ["4(?:(?:79|94)[01]|83[0-389])\\d{5}|4(?:[0-3]\\d|4[047-9]|5[0-25-9]|6[0-36-9]|7[02-8]|8[0-24-9]|9[0-37-9])\\d{6}", [9]], ["180(?:0\\d{3}|2)\\d{3}", [7, 10]], ["190[0-26]\\d{6}", [10]], 0, 0, 0, 0, ["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}", [9]], ["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}", [6, 8, 10, 12]]], "0011"], "CY": ["357", "00", "(?:[279]\\d|[58]0)\\d{6}", [8], [["(\\d{2})(\\d{6})", "$1 $2", ["[257-9]"]]]], "CZ": ["420", "00", "(?:[2-578]\\d|60)\\d{7}|9\\d{8,11}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-8]|9[015-7]"]], ["(\\d{2})(\\d{3})(\\d{3})(\\d{2})", "$1 $2 $3 $4", ["96"]], ["(\\d{2})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["9"]], ["(\\d{3})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["9"]]]], "DE": ["49", "00", "[2579]\\d{5,14}|49(?:[34]0|69|8\\d)\\d\\d?|49(?:37|49|60|7[089]|9\\d)\\d{1,3}|49(?:2[024-9]|3[2-689]|7[1-7])\\d{1,8}|(?:1|[368]\\d|4[0-8])\\d{3,13}|49(?:[015]\\d|2[13]|31|[46][1-8])\\d{1,9}", [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [["(\\d{2})(\\d{3,13})", "$1 $2", ["3[02]|40|[68]9"], "0$1"], ["(\\d{3})(\\d{3,12})", "$1 $2", ["2(?:0[1-389]|1[124]|2[18]|3[14])|3(?:[35-9][15]|4[015])|906|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1", "2(?:0[1-389]|12[0-8])|3(?:[35-9][15]|4[015])|906|2(?:[13][14]|2[18])|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1"], "0$1"], ["(\\d{4})(\\d{2,11})", "$1 $2", ["[24-6]|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]", "[24-6]|3(?:3(?:0[1-467]|2[127-9]|3[124578]|7[1257-9]|8[1256]|9[145])|4(?:2[135]|4[13578]|9[1346])|5(?:0[14]|2[1-3589]|6[1-4]|7[13468]|8[13568])|6(?:2[1-489]|3[124-6]|6[13]|7[12579]|8[1-356]|9[135])|7(?:2[1-7]|4[145]|6[1-5]|7[1-4])|8(?:21|3[1468]|6|7[1467]|8[136])|9(?:0[12479]|2[1358]|4[134679]|6[1-9]|7[136]|8[147]|9[1468]))|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]|3[68]4[1347]|3(?:47|60)[1356]|3(?:3[46]|46|5[49])[1246]|3[4579]3[1357]"], "0$1"], ["(\\d{3})(\\d{4})", "$1 $2", ["138"], "0$1"], ["(\\d{5})(\\d{2,10})", "$1 $2", ["3"], "0$1"], ["(\\d{3})(\\d{5,11})", "$1 $2", ["181"], "0$1"], ["(\\d{3})(\\d)(\\d{4,10})", "$1 $2 $3", ["1(?:3|80)|9"], "0$1"], ["(\\d{3})(\\d{7,8})", "$1 $2", ["1[67]"], "0$1"], ["(\\d{3})(\\d{7,12})", "$1 $2", ["8"], "0$1"], ["(\\d{5})(\\d{6})", "$1 $2", ["185", "1850", "18500"], "0$1"], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["7"], "0$1"], ["(\\d{4})(\\d{7})", "$1 $2", ["18[68]"], "0$1"], ["(\\d{4})(\\d{7})", "$1 $2", ["15[1279]"], "0$1"], ["(\\d{5})(\\d{6})", "$1 $2", ["15[03568]", "15(?:[0568]|31)"], "0$1"], ["(\\d{3})(\\d{8})", "$1 $2", ["18"], "0$1"], ["(\\d{3})(\\d{2})(\\d{7,8})", "$1 $2 $3", ["1(?:6[023]|7)"], "0$1"], ["(\\d{4})(\\d{2})(\\d{7})", "$1 $2 $3", ["15[279]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{8})", "$1 $2 $3", ["15"], "0$1"]], "0"], "DJ": ["253", "00", "(?:2\\d|77)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[27]"]]]], "DK": ["45", "00", "[2-9]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-9]"]]]], "DM": ["1", "011", "(?:[58]\\d\\d|767|900)\\d{7}", [10], 0, "1", 0, "([2-7]\\d{6})$|1", "767$1", 0, "767"], "DO": ["1", "011", "(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, 0, 0, 0, "8001|8[024]9"], "DZ": ["213", "00", "(?:[1-4]|[5-79]\\d|80)\\d{7}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[1-4]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["9"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-8]"], "0$1"]], "0"], "EC": ["593", "00", "1\\d{9,10}|(?:[2-7]|9\\d)\\d{7}", [8, 9, 10, 11], [["(\\d)(\\d{3})(\\d{4})", "$1 $2-$3", ["[2-7]"], "(0$1)", 0, "$1-$2-$3"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["1"]]], "0"], "EE": ["372", "00", "8\\d{9}|[4578]\\d{7}|(?:[3-8]\\d|90)\\d{5}", [7, 8, 10], [["(\\d{3})(\\d{4})", "$1 $2", ["[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]|88", "[369]|4[3-8]|5(?:[02]|1(?:[0-8]|95)|5[0-478]|6(?:4[0-4]|5[1-589]))|7[1-9]|88"]], ["(\\d{4})(\\d{3,4})", "$1 $2", ["[45]|8(?:00|[1-49])", "[45]|8(?:00[1-9]|[1-49])"]], ["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["7"]], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]]]], "EG": ["20", "00", "[189]\\d{8,9}|[24-6]\\d{8}|[135]\\d{7}", [8, 9, 10], [["(\\d)(\\d{7,8})", "$1 $2", ["[23]"], "0$1"], ["(\\d{2})(\\d{6,7})", "$1 $2", ["1[35]|[4-6]|8[2468]|9[235-7]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[89]"], "0$1"], ["(\\d{2})(\\d{8})", "$1 $2", ["1"], "0$1"]], "0"], "EH": ["212", "00", "[5-8]\\d{8}", [9], 0, "0", 0, 0, 0, 0, "528[89]"], "ER": ["291", "00", "[178]\\d{6}", [7], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[178]"], "0$1"]], "0"], "ES": ["34", "00", "[5-9]\\d{8}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[89]00"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-9]"]]]], "ET": ["251", "00", "(?:11|[2-579]\\d)\\d{7}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1-579]"], "0$1"]], "0"], "FI": ["358", "00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))", "[1-35689]\\d{4}|7\\d{10,11}|(?:[124-7]\\d|3[0-46-9])\\d{8}|[1-9]\\d{5,8}", [5, 6, 7, 8, 9, 10, 11, 12], [["(\\d{5})", "$1", ["20[2-59]"], "0$1"], ["(\\d{3})(\\d{3,7})", "$1 $2", ["(?:[1-3]0|[68])0|70[07-9]"], "0$1"], ["(\\d{2})(\\d{4,8})", "$1 $2", ["[14]|2[09]|50|7[135]"], "0$1"], ["(\\d{2})(\\d{6,10})", "$1 $2", ["7"], "0$1"], ["(\\d)(\\d{4,9})", "$1 $2", ["(?:1[3-79]|[2568])[1-8]|3(?:0[1-9]|[1-9])|9"], "0$1"]], "0", 0, 0, 0, 0, "1[03-79]|[2-9]", 0, "00"], "FJ": ["679", "0(?:0|52)", "45\\d{5}|(?:0800\\d|[235-9])\\d{6}", [7, 11], [["(\\d{3})(\\d{4})", "$1 $2", ["[235-9]|45"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["0"]]], 0, 0, 0, 0, 0, 0, 0, "00"], "FK": ["500", "00", "[2-7]\\d{4}", [5]], "FM": ["691", "00", "(?:[39]\\d\\d|820)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[389]"]]]], "FO": ["298", "00", "[2-9]\\d{5}", [6], [["(\\d{6})", "$1", ["[2-9]"]]], 0, 0, "(10(?:01|[12]0|88))"], "FR": ["33", "00", "[1-9]\\d{8}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0 $1"], ["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["[1-79]"], "0$1"]], "0"], "GA": ["241", "00", "(?:[067]\\d|11)\\d{6}|[2-7]\\d{6}", [7, 8], [["(\\d)(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-7]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["0"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["11|[67]"], "0$1"]], 0, 0, "0(11\\d{6}|60\\d{6}|61\\d{6}|6[256]\\d{6}|7[467]\\d{6})", "$1"], "GB": ["44", "00", "[1-357-9]\\d{9}|[18]\\d{8}|8\\d{6}", [7, 9, 10], [["(\\d{3})(\\d{4})", "$1 $2", ["800", "8001", "80011", "800111", "8001111"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["845", "8454", "84546", "845464"], "0$1"], ["(\\d{3})(\\d{6})", "$1 $2", ["800"], "0$1"], ["(\\d{5})(\\d{4,5})", "$1 $2", ["1(?:38|5[23]|69|76|94)", "1(?:(?:38|69)7|5(?:24|39)|768|946)", "1(?:3873|5(?:242|39[4-6])|(?:697|768)[347]|9467)"], "0$1"], ["(\\d{4})(\\d{5,6})", "$1 $2", ["1(?:[2-69][02-9]|[78])"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["[25]|7(?:0|6[02-9])", "[25]|7(?:0|6(?:[03-9]|2[356]))"], "0$1"], ["(\\d{4})(\\d{6})", "$1 $2", ["7"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1389]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:1(?:1(?:3(?:[0-58]\\d\\d|73[0235])|4(?:(?:[0-5]\\d|70)\\d|69[7-9])|(?:(?:5[0-26-9]|[78][0-49])\\d|6(?:[0-4]\\d|50))\\d)|(?:2(?:(?:0[024-9]|2[3-9]|3[3-79]|4[1-689]|[58][02-9]|6[0-47-9]|7[013-9]|9\\d)\\d|1(?:[0-7]\\d|8[0-2]))|(?:3(?:0\\d|1[0-8]|[25][02-9]|3[02-579]|[468][0-46-9]|7[1-35-79]|9[2-578])|4(?:0[03-9]|[137]\\d|[28][02-57-9]|4[02-69]|5[0-8]|[69][0-79])|5(?:0[1-35-9]|[16]\\d|2[024-9]|3[015689]|4[02-9]|5[03-9]|7[0-35-9]|8[0-468]|9[0-57-9])|6(?:0[034689]|1\\d|2[0-35689]|[38][013-9]|4[1-467]|5[0-69]|6[13-9]|7[0-8]|9[0-24578])|7(?:0[0246-9]|2\\d|3[0236-8]|4[03-9]|5[0-46-9]|6[013-9]|7[0-35-9]|8[024-9]|9[02-9])|8(?:0[35-9]|2[1-57-9]|3[02-578]|4[0-578]|5[124-9]|6[2-69]|7\\d|8[02-9]|9[02569])|9(?:0[02-589]|[18]\\d|2[02-689]|3[1-57-9]|4[2-9]|5[0-579]|6[2-47-9]|7[0-24578]|9[2-57]))\\d)\\d)|2(?:0[013478]|3[0189]|4[017]|8[0-46-9]|9[0-2])\\d{3})\\d{4}|1(?:2(?:0(?:46[1-4]|87[2-9])|545[1-79]|76(?:2\\d|3[1-8]|6[1-6])|9(?:7(?:2[0-4]|3[2-5])|8(?:2[2-8]|7[0-47-9]|8[3-5])))|3(?:6(?:38[2-5]|47[23])|8(?:47[04-9]|64[0157-9]))|4(?:044[1-7]|20(?:2[23]|8\\d)|6(?:0(?:30|5[2-57]|6[1-8]|7[2-8])|140)|8(?:052|87[1-3]))|5(?:2(?:4(?:3[2-79]|6\\d)|76\\d)|6(?:26[06-9]|686))|6(?:06(?:4\\d|7[4-79])|295[5-7]|35[34]\\d|47(?:24|61)|59(?:5[08]|6[67]|74)|9(?:55[0-4]|77[23]))|7(?:26(?:6[13-9]|7[0-7])|(?:442|688)\\d|50(?:2[0-3]|[3-68]2|76))|8(?:27[56]\\d|37(?:5[2-5]|8[239])|843[2-58])|9(?:0(?:0(?:6[1-8]|85)|52\\d)|3583|4(?:66[1-8]|9(?:2[01]|81))|63(?:23|3[1-4])|9561))\\d{3}", [9, 10]], ["7(?:457[0-57-9]|700[01]|911[028])\\d{5}|7(?:[1-3]\\d\\d|4(?:[0-46-9]\\d|5[0-689])|5(?:0[0-8]|[13-9]\\d|2[0-35-9])|7(?:0[1-9]|[1-7]\\d|8[02-9]|9[0-689])|8(?:[014-9]\\d|[23][0-8])|9(?:[024-9]\\d|1[02-9]|3[0-689]))\\d{6}", [10]], ["80[08]\\d{7}|800\\d{6}|8001111"], ["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[2-49]))\\d{7}|845464\\d", [7, 10]], ["70\\d{8}", [10]], 0, ["(?:3[0347]|55)\\d{8}", [10]], ["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}", [10]], ["56\\d{8}", [10]]], 0, " x"], "GD": ["1", "011", "(?:473|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "473$1", 0, "473"], "GE": ["995", "00", "(?:[3-57]\\d\\d|800)\\d{6}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["70"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["32"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[57]"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[348]"], "0$1"]], "0"], "GF": ["594", "00", "[56]94\\d{6}|(?:80|9\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[56]|9[47]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[89]"], "0$1"]], "0"], "GG": ["44", "00", "(?:1481|[357-9]\\d{3})\\d{6}|8\\d{6}(?:\\d{2})?", [7, 9, 10], 0, "0", 0, "([25-9]\\d{5})$|0", "1481$1", 0, 0, [["1481[25-9]\\d{5}", [10]], ["7(?:(?:781|839)\\d|911[17])\\d{5}", [10]], ["80[08]\\d{7}|800\\d{6}|8001111"], ["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[0-3]))\\d{7}|845464\\d", [7, 10]], ["70\\d{8}", [10]], 0, ["(?:3[0347]|55)\\d{8}", [10]], ["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}", [10]], ["56\\d{8}", [10]]]], "GH": ["233", "00", "(?:[235]\\d{3}|800)\\d{5}", [8, 9], [["(\\d{3})(\\d{5})", "$1 $2", ["8"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[235]"], "0$1"]], "0"], "GI": ["350", "00", "(?:[25]\\d|60)\\d{6}", [8], [["(\\d{3})(\\d{5})", "$1 $2", ["2"]]]], "GL": ["299", "00", "(?:19|[2-689]\\d|70)\\d{4}", [6], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["19|[2-9]"]]]], "GM": ["220", "00", "[2-9]\\d{6}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-9]"]]]], "GN": ["224", "00", "722\\d{6}|(?:3|6\\d)\\d{7}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["3"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[67]"]]]], "GP": ["590", "00", "590\\d{6}|(?:69|80|9\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[569]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0$1"]], "0", 0, 0, 0, 0, 0, [["590(?:0[1-68]|[14][0-24-9]|2[0-68]|3[1-9]|5[3-579]|[68][0-689]|7[08]|9\\d)\\d{4}"], ["69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))\\d{4}"], ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:39[5-7]|76[018])\\d|475[0-5])\\d{4}"]]], "GQ": ["240", "00", "222\\d{6}|(?:3\\d|55|[89]0)\\d{7}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[235]"]], ["(\\d{3})(\\d{6})", "$1 $2", ["[89]"]]]], "GR": ["30", "00", "5005000\\d{3}|8\\d{9,11}|(?:[269]\\d|70)\\d{8}", [10, 11, 12], [["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["21|7"]], ["(\\d{4})(\\d{6})", "$1 $2", ["2(?:2|3[2-57-9]|4[2-469]|5[2-59]|6[2-9]|7[2-69]|8[2-49])|5"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2689]"]], ["(\\d{3})(\\d{3,4})(\\d{5})", "$1 $2 $3", ["8"]]]], "GT": ["502", "00", "80\\d{6}|(?:1\\d{3}|[2-7])\\d{7}", [8, 11], [["(\\d{4})(\\d{4})", "$1 $2", ["[2-8]"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]]]], "GU": ["1", "011", "(?:[58]\\d\\d|671|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "671$1", 0, "671"], "GW": ["245", "00", "[49]\\d{8}|4\\d{6}", [7, 9], [["(\\d{3})(\\d{4})", "$1 $2", ["40"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[49]"]]]], "GY": ["592", "001", "(?:[2-8]\\d{3}|9008)\\d{3}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-9]"]]]], "HK": ["852", "00(?:30|5[09]|[126-9]?)", "8[0-46-9]\\d{6,7}|9\\d{4,7}|(?:[2-7]|9\\d{3})\\d{7}", [5, 6, 7, 8, 9, 11], [["(\\d{3})(\\d{2,5})", "$1 $2", ["900", "9003"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[2-7]|8[1-4]|9(?:0[1-9]|[1-8])"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]], ["(\\d{3})(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["9"]]], 0, 0, 0, 0, 0, 0, 0, "00"], "HN": ["504", "00", "8\\d{10}|[237-9]\\d{7}", [8, 11], [["(\\d{4})(\\d{4})", "$1-$2", ["[237-9]"]]]], "HR": ["385", "00", "(?:[24-69]\\d|3[0-79])\\d{7}|80\\d{5,7}|[1-79]\\d{7}|6\\d{5,6}", [6, 7, 8, 9], [["(\\d{2})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["6[01]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["8"], "0$1"], ["(\\d)(\\d{4})(\\d{3})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["6|7[245]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-57]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"], "0$1"]], "0"], "HT": ["509", "00", "(?:[2-489]\\d|55)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["[2-589]"]]]], "HU": ["36", "00", "[235-7]\\d{8}|[1-9]\\d{7}", [8, 9], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "(06 $1)"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[27][2-9]|3[2-7]|4[24-9]|5[2-79]|6|8[2-57-9]|9[2-69]"], "(06 $1)"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-9]"], "06 $1"]], "06"], "ID": ["62", "00[89]", "(?:(?:00[1-9]|8\\d)\\d{4}|[1-36])\\d{6}|00\\d{10}|[1-9]\\d{8,10}|[2-9]\\d{7}", [7, 8, 9, 10, 11, 12, 13], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["15"]], ["(\\d{2})(\\d{5,9})", "$1 $2", ["2[124]|[36]1"], "(0$1)"], ["(\\d{3})(\\d{5,7})", "$1 $2", ["800"], "0$1"], ["(\\d{3})(\\d{5,8})", "$1 $2", ["[2-79]"], "(0$1)"], ["(\\d{3})(\\d{3,4})(\\d{3})", "$1-$2-$3", ["8[1-35-9]"], "0$1"], ["(\\d{3})(\\d{6,8})", "$1 $2", ["1"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["804"], "0$1"], ["(\\d{3})(\\d)(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["80"], "0$1"], ["(\\d{3})(\\d{4})(\\d{4,5})", "$1-$2-$3", ["8"], "0$1"]], "0"], "IE": ["353", "00", "(?:1\\d|[2569])\\d{6,8}|4\\d{6,9}|7\\d{8}|8\\d{8,9}", [7, 8, 9, 10], [["(\\d{2})(\\d{5})", "$1 $2", ["2[24-9]|47|58|6[237-9]|9[35-9]"], "(0$1)"], ["(\\d{3})(\\d{5})", "$1 $2", ["[45]0"], "(0$1)"], ["(\\d)(\\d{3,4})(\\d{4})", "$1 $2 $3", ["1"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2569]|4[1-69]|7[14]"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["70"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["81"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[78]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["4"], "(0$1)"], ["(\\d{2})(\\d)(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["8"], "0$1"]], "0"], "IL": ["972", "0(?:0|1[2-9])", "1\\d{6}(?:\\d{3,5})?|[57]\\d{8}|[1-489]\\d{7}", [7, 8, 9, 10, 11, 12], [["(\\d{4})(\\d{3})", "$1-$2", ["125"]], ["(\\d{4})(\\d{2})(\\d{2})", "$1-$2-$3", ["121"]], ["(\\d)(\\d{3})(\\d{4})", "$1-$2-$3", ["[2-489]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["[57]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1-$2-$3", ["12"]], ["(\\d{4})(\\d{6})", "$1-$2", ["159"]], ["(\\d)(\\d{3})(\\d{3})(\\d{3})", "$1-$2-$3-$4", ["1[7-9]"]], ["(\\d{3})(\\d{1,2})(\\d{3})(\\d{4})", "$1-$2 $3-$4", ["15"]]], "0"], "IM": ["44", "00", "1624\\d{6}|(?:[3578]\\d|90)\\d{8}", [10], 0, "0", 0, "([25-8]\\d{5})$|0", "1624$1", 0, "74576|(?:16|7[56])24"], "IN": ["91", "00", "(?:000800|[2-9]\\d\\d)\\d{7}|1\\d{7,12}", [8, 9, 10, 11, 12, 13], [["(\\d{8})", "$1", ["5(?:0|2[23]|3[03]|[67]1|88)", "5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|888)", "5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|8888)"], 0, 1], ["(\\d{4})(\\d{4,5})", "$1 $2", ["180", "1800"], 0, 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["140"], 0, 1], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["11|2[02]|33|4[04]|79[1-7]|80[2-46]", "11|2[02]|33|4[04]|79(?:[1-6]|7[19])|80(?:[2-4]|6[0-589])", "11|2[02]|33|4[04]|79(?:[124-6]|3(?:[02-9]|1[0-24-9])|7(?:1|9[1-6]))|80(?:[2-4]|6[0-589])"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["1(?:2[0-249]|3[0-25]|4[145]|[68]|7[1257])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|5[12]|[78]1)|6(?:12|[2-4]1|5[17]|6[13]|80)|7(?:12|3[134]|4[47]|61|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)|(?:43|59|75)[15]|(?:1[59]|29|67|72)[14]", "1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|674|7(?:(?:2[14]|3[34]|5[15])[2-6]|61[346]|88[0-8])|8(?:70[2-6]|84[235-7]|91[3-7])|(?:1(?:29|60|8[06])|261|552|6(?:12|[2-47]1|5[17]|6[13]|80)|7(?:12|31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))[2-7]", "1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12(?:[2-6]|7[0-8])|74[2-7])|7(?:(?:2[14]|5[15])[2-6]|3171|61[346]|88(?:[2-7]|82))|8(?:70[2-6]|84(?:[2356]|7[19])|91(?:[3-6]|7[19]))|73[134][2-6]|(?:74[47]|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[2-6]|7[19])|(?:1(?:29|60|8[06])|261|552|6(?:[2-4]1|5[17]|6[13]|7(?:1|4[0189])|80)|7(?:12|88[01]))[2-7]"], "0$1", 1], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2[2457-9]|3[2-5]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1[013-9]|28|3[129]|4[1-35689]|5[29]|6[02-5]|70)|807", "1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2(?:[2457]|84|95)|3(?:[2-4]|55)|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1(?:[013-8]|9[6-9])|28[6-8]|3(?:17|2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4|5[0-367])|70[13-7])|807[19]", "1(?:[2-479]|5(?:[0236-9]|5[013-9]))|[2-5]|6(?:2(?:84|95)|355|83)|73179|807(?:1|9[1-3])|(?:1552|6(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[124-6])\\d|7(?:1(?:[013-8]\\d|9[6-9])|28[6-8]|3(?:2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\d|5[0-367])|70[13-7]))[2-7]"], "0$1", 1], ["(\\d{5})(\\d{5})", "$1 $2", ["[6-9]"], "0$1", 1], ["(\\d{4})(\\d{2,4})(\\d{4})", "$1 $2 $3", ["1(?:6|8[06])", "1(?:6|8[06]0)"], 0, 1], ["(\\d{4})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["18"], 0, 1]], "0"], "IO": ["246", "00", "3\\d{6}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["3"]]]], "IQ": ["964", "00", "(?:1|7\\d\\d)\\d{7}|[2-6]\\d{7,8}", [8, 9, 10], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-6]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "0$1"]], "0"], "IR": ["98", "00", "[1-9]\\d{9}|(?:[1-8]\\d\\d|9)\\d{3,4}", [4, 5, 6, 7, 10], [["(\\d{4,5})", "$1", ["96"], "0$1"], ["(\\d{2})(\\d{4,5})", "$1 $2", ["(?:1[137]|2[13-68]|3[1458]|4[145]|5[1468]|6[16]|7[1467]|8[13467])[12689]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["[1-8]"], "0$1"]], "0"], "IS": ["354", "00|1(?:0(?:01|[12]0)|100)", "(?:38\\d|[4-9])\\d{6}", [7, 9], [["(\\d{3})(\\d{4})", "$1 $2", ["[4-9]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["3"]]], 0, 0, 0, 0, 0, 0, 0, "00"], "IT": ["39", "00", "0\\d{5,10}|1\\d{8,10}|3(?:[0-8]\\d{7,10}|9\\d{7,8})|(?:43|55|70)\\d{8}|8\\d{5}(?:\\d{2,4})?", [6, 7, 8, 9, 10, 11], [["(\\d{2})(\\d{4,6})", "$1 $2", ["0[26]"]], ["(\\d{3})(\\d{3,6})", "$1 $2", ["0[13-57-9][0159]|8(?:03|4[17]|9[2-5])", "0[13-57-9][0159]|8(?:03|4[17]|9(?:2|3[04]|[45][0-4]))"]], ["(\\d{4})(\\d{2,6})", "$1 $2", ["0(?:[13-579][2-46-8]|8[236-8])"]], ["(\\d{4})(\\d{4})", "$1 $2", ["894"]], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["0[26]|5"]], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["1(?:44|[679])|[378]|43"]], ["(\\d{3})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["0[13-57-9][0159]|14"]], ["(\\d{2})(\\d{4})(\\d{5})", "$1 $2 $3", ["0[26]"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["0"]], ["(\\d{3})(\\d{4})(\\d{4,5})", "$1 $2 $3", ["3"]]], 0, 0, 0, 0, 0, 0, [["0669[0-79]\\d{1,6}|0(?:1(?:[0159]\\d|[27][1-5]|31|4[1-4]|6[1356]|8[2-57])|2\\d\\d|3(?:[0159]\\d|2[1-4]|3[12]|[48][1-6]|6[2-59]|7[1-7])|4(?:[0159]\\d|[23][1-9]|4[245]|6[1-5]|7[1-4]|81)|5(?:[0159]\\d|2[1-5]|3[2-6]|4[1-79]|6[4-6]|7[1-578]|8[3-8])|6(?:[0-57-9]\\d|6[0-8])|7(?:[0159]\\d|2[12]|3[1-7]|4[2-46]|6[13569]|7[13-6]|8[1-59])|8(?:[0159]\\d|2[3-578]|3[1-356]|[6-8][1-5])|9(?:[0159]\\d|[238][1-5]|4[12]|6[1-8]|7[1-6]))\\d{2,7}"], ["3[2-9]\\d{7,8}|(?:31|43)\\d{8}", [9, 10]], ["80(?:0\\d{3}|3)\\d{3}", [6, 9]], ["(?:0878\\d{3}|89(?:2\\d|3[04]|4(?:[0-4]|[5-9]\\d\\d)|5[0-4]))\\d\\d|(?:1(?:44|6[346])|89(?:38|5[5-9]|9))\\d{6}", [6, 8, 9, 10]], ["1(?:78\\d|99)\\d{6}", [9, 10]], 0, 0, 0, ["55\\d{8}", [10]], ["84(?:[08]\\d{3}|[17])\\d{3}", [6, 9]]]], "JE": ["44", "00", "1534\\d{6}|(?:[3578]\\d|90)\\d{8}", [10], 0, "0", 0, "([0-24-8]\\d{5})$|0", "1534$1", 0, 0, [["1534[0-24-8]\\d{5}"], ["7(?:(?:(?:50|82)9|937)\\d|7(?:00[378]|97\\d))\\d{5}"], ["80(?:07(?:35|81)|8901)\\d{4}"], ["(?:8(?:4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|90(?:066[59]|1810|71(?:07|55)))\\d{4}"], ["701511\\d{4}"], 0, ["(?:3(?:0(?:07(?:35|81)|8901)|3\\d{4}|4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|55\\d{4})\\d{4}"], ["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}"], ["56\\d{8}"]]], "JM": ["1", "011", "(?:[58]\\d\\d|658|900)\\d{7}", [10], 0, "1", 0, 0, 0, 0, "658|876"], "JO": ["962", "00", "(?:(?:[2689]|7\\d)\\d|32|53)\\d{6}", [8, 9], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[2356]|87"], "(0$1)"], ["(\\d{3})(\\d{5,6})", "$1 $2", ["[89]"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["70"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["7"], "0$1"]], "0"], "JP": ["81", "010", "00[1-9]\\d{6,14}|[257-9]\\d{9}|(?:00|[1-9]\\d\\d)\\d{6}", [8, 9, 10, 11, 12, 13, 14, 15, 16, 17], [["(\\d{3})(\\d{3})(\\d{3})", "$1-$2-$3", ["(?:12|57|99)0"], "0$1"], ["(\\d{4})(\\d)(\\d{4})", "$1-$2-$3", ["1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|499|5(?:76|97)|746|8(?:3[89]|47|51)|9(?:80|9[16])", "1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:76|97)9|7468|8(?:3(?:8[7-9]|96)|477|51[2-9])|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]", "1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:769|979[2-69])|7468|8(?:3(?:8[7-9]|96[2457-9])|477|51[2-9])|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["60"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1-$2-$3", ["[36]|4(?:2[09]|7[01])", "[36]|4(?:2(?:0|9[02-69])|7(?:0[019]|1))"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["1(?:1|5[45]|77|88|9[69])|2(?:2[1-37]|3[0-269]|4[59]|5|6[24]|7[1-358]|8[1369]|9[0-38])|4(?:[28][1-9]|3[0-57]|[45]|6[248]|7[2-579]|9[29])|5(?:2|3[0459]|4[0-369]|5[29]|8[02389]|9[0-389])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9[2-6])|8(?:2[124589]|3[26-9]|49|51|6|7[0-468]|8[68]|9[019])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9[1-489])", "1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2(?:[127]|3[014-9])|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9[19])|62|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|8[1-9]|9[29])|5(?:2|3(?:[045]|9[0-8])|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0-2469])|3(?:[29]|60)|49|51|6(?:[0-24]|36|5[0-3589]|7[23]|9[01459])|7[0-468]|8[68])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3[34]|4[0178]))|(?:264|837)[016-9]|2(?:57|93)[015-9]|(?:25[0468]|422|838)[01]|(?:47[59]|59[89]|8(?:6[68]|9))[019]", "1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3(?:[045]|9(?:[0-58]|6[4-9]|7[0-35689]))|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0169])|3(?:[29]|60|7(?:[017-9]|6[6-8]))|49|51|6(?:[0-24]|36[2-57-9]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|7(?:2[2-468]|3[78])|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:8294|96)[1-3]|2(?:57|93)[015-9]|(?:223|8699)[014-9]|(?:25[0468]|422|838)[01]|(?:48|8292|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{4})", "$1-$2-$3", ["[14]|[289][2-9]|5[3-9]|7[2-4679]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2-$3", ["800"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1-$2-$3", ["[257-9]"], "0$1"]], "0", 0, "(000[259]\\d{6})$|(?:(?:003768)0?)|0", "$1"], "KE": ["254", "000", "(?:[17]\\d\\d|900)\\d{6}|(?:2|80)0\\d{6,7}|[4-6]\\d{6,8}", [7, 8, 9, 10], [["(\\d{2})(\\d{5,7})", "$1 $2", ["[24-6]"], "0$1"], ["(\\d{3})(\\d{6})", "$1 $2", ["[17]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[89]"], "0$1"]], "0"], "KG": ["996", "00", "8\\d{9}|[235-9]\\d{8}", [9, 10], [["(\\d{4})(\\d{5})", "$1 $2", ["3(?:1[346]|[24-79])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[235-79]|88"], "0$1"], ["(\\d{3})(\\d{3})(\\d)(\\d{2,3})", "$1 $2 $3 $4", ["8"], "0$1"]], "0"], "KH": ["855", "00[14-9]", "1\\d{9}|[1-9]\\d{7,8}", [8, 9, 10], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[1-9]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]]], "0"], "KI": ["686", "00", "(?:[37]\\d|6[0-79])\\d{6}|(?:[2-48]\\d|50)\\d{3}", [5, 8], 0, "0"], "KM": ["269", "00", "[3478]\\d{6}", [7], [["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["[3478]"]]]], "KN": ["1", "011", "(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-7]\\d{6})$|1", "869$1", 0, "869"], "KP": ["850", "00|99", "85\\d{6}|(?:19\\d|[2-7])\\d{7}", [8, 10], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"], "0$1"], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-7]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"]], "0"], "KR": ["82", "00(?:[125689]|3(?:[46]5|91)|7(?:00|27|3|55|6[126]))", "00[1-9]\\d{8,11}|(?:[12]|5\\d{3})\\d{7}|[13-6]\\d{9}|(?:[1-6]\\d|80)\\d{7}|[3-6]\\d{4,5}|(?:00|7)0\\d{8}", [5, 6, 8, 9, 10, 11, 12, 13, 14], [["(\\d{2})(\\d{3,4})", "$1-$2", ["(?:3[1-3]|[46][1-4]|5[1-5])1"], "0$1"], ["(\\d{4})(\\d{4})", "$1-$2", ["1"]], ["(\\d)(\\d{3,4})(\\d{4})", "$1-$2-$3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["60|8"], "0$1"], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1-$2-$3", ["[1346]|5[1-5]"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1-$2-$3", ["[57]"], "0$1"], ["(\\d{2})(\\d{5})(\\d{4})", "$1-$2-$3", ["5"], "0$1"]], "0", 0, "0(8(?:[1-46-8]|5\\d\\d))?"], "KW": ["965", "00", "18\\d{5}|(?:[2569]\\d|41)\\d{6}", [7, 8], [["(\\d{4})(\\d{3,4})", "$1 $2", ["[169]|2(?:[235]|4[1-35-9])|52"]], ["(\\d{3})(\\d{5})", "$1 $2", ["[245]"]]]], "KY": ["1", "011", "(?:345|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "345$1", 0, "345"], "KZ": ["7", "810", "(?:33622|8\\d{8})\\d{5}|[78]\\d{9}", [10, 14], 0, "8", 0, 0, 0, 0, "33|7", 0, "8~10"], "LA": ["856", "00", "[23]\\d{9}|3\\d{8}|(?:[235-8]\\d|41)\\d{6}", [8, 9, 10], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["2[13]|3[14]|[4-8]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["30[013-9]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["[23]"], "0$1"]], "0"], "LB": ["961", "00", "[27-9]\\d{7}|[13-9]\\d{6}", [7, 8], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[13-69]|7(?:[2-57]|62|8[0-7]|9[04-9])|8[02-9]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[27-9]"]]], "0"], "LC": ["1", "011", "(?:[58]\\d\\d|758|900)\\d{7}", [10], 0, "1", 0, "([2-8]\\d{6})$|1", "758$1", 0, "758"], "LI": ["423", "00", "[68]\\d{8}|(?:[2378]\\d|90)\\d{5}", [7, 9], [["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["[2379]|8(?:0[09]|7)", "[2379]|8(?:0(?:02|9)|7)"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["69"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6"]]], "0", 0, "(1001)|0"], "LK": ["94", "00", "[1-9]\\d{8}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[1-689]"], "0$1"]], "0"], "LR": ["231", "00", "(?:[245]\\d|33|77|88)\\d{7}|(?:2\\d|[4-6])\\d{6}", [7, 8, 9], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["4[67]|[56]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-578]"], "0$1"]], "0"], "LS": ["266", "00", "(?:[256]\\d\\d|800)\\d{5}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[2568]"]]]], "LT": ["370", "00", "(?:[3469]\\d|52|[78]0)\\d{6}", [8], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["52[0-7]"], "(0-$1)", 1], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[7-9]"], "0 $1", 1], ["(\\d{2})(\\d{6})", "$1 $2", ["37|4(?:[15]|6[1-8])"], "(0-$1)", 1], ["(\\d{3})(\\d{5})", "$1 $2", ["[3-6]"], "(0-$1)", 1]], "0", 0, "[08]"], "LU": ["352", "00", "35[013-9]\\d{4,8}|6\\d{8}|35\\d{2,4}|(?:[2457-9]\\d|3[0-46-9])\\d{2,9}", [4, 5, 6, 7, 8, 9, 10, 11], [["(\\d{2})(\\d{3})", "$1 $2", ["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]], ["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]], ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["20[2-689]"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})", "$1 $2 $3 $4", ["2(?:[0367]|4[3-8])"]], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["80[01]|90[015]"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["20"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})", "$1 $2 $3 $4 $5", ["2(?:[0367]|4[3-8])"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{1,5})", "$1 $2 $3 $4", ["[3-57]|8[13-9]|9(?:0[89]|[2-579])|(?:2|80)[2-9]"]]], 0, 0, "(15(?:0[06]|1[12]|[35]5|4[04]|6[26]|77|88|99)\\d)"], "LV": ["371", "00", "(?:[268]\\d|90)\\d{6}", [8], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[269]|8[01]"]]]], "LY": ["218", "00", "[2-9]\\d{8}", [9], [["(\\d{2})(\\d{7})", "$1-$2", ["[2-9]"], "0$1"]], "0"], "MA": ["212", "00", "[5-8]\\d{8}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["5[45]"], "0$1"], ["(\\d{4})(\\d{5})", "$1-$2", ["5(?:2[2-46-9]|3[3-9]|9)|8(?:0[89]|92)"], "0$1"], ["(\\d{2})(\\d{7})", "$1-$2", ["8"], "0$1"], ["(\\d{3})(\\d{6})", "$1-$2", ["[5-7]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["5(?:2(?:[0-25-79]\\d|3[1-578]|4[02-46-8]|8[0235-7])|3(?:[0-47]\\d|5[02-9]|6[02-8]|8[014-9]|9[3-9])|(?:4[067]|5[03])\\d)\\d{5}"], ["(?:6(?:[0-79]\\d|8[0-247-9])|7(?:[0167]\\d|2[0-4]|5[01]|8[0-3]))\\d{6}"], ["80[0-7]\\d{6}"], ["89\\d{7}"], 0, 0, 0, 0, ["(?:592(?:4[0-2]|93)|80[89]\\d\\d)\\d{4}"]]], "MC": ["377", "00", "(?:[3489]|6\\d)\\d{7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["4"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[389]"]], ["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["6"], "0$1"]], "0"], "MD": ["373", "00", "(?:[235-7]\\d|[89]0)\\d{6}", [8], [["(\\d{3})(\\d{5})", "$1 $2", ["[89]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["22|3"], "0$1"], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[25-7]"], "0$1"]], "0"], "ME": ["382", "00", "(?:20|[3-79]\\d)\\d{6}|80\\d{6,7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-9]"], "0$1"]], "0"], "MF": ["590", "00", "590\\d{6}|(?:69|80|9\\d)\\d{7}", [9], 0, "0", 0, 0, 0, 0, 0, [["590(?:0[079]|[14]3|[27][79]|3[03-7]|5[0-268]|87)\\d{4}"], ["69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))\\d{4}"], ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:39[5-7]|76[018])\\d|475[0-5])\\d{4}"]]], "MG": ["261", "00", "[23]\\d{8}", [9], [["(\\d{2})(\\d{2})(\\d{3})(\\d{2})", "$1 $2 $3 $4", ["[23]"], "0$1"]], "0", 0, "([24-9]\\d{6})$|0", "20$1"], "MH": ["692", "011", "329\\d{4}|(?:[256]\\d|45)\\d{5}", [7], [["(\\d{3})(\\d{4})", "$1-$2", ["[2-6]"]]], "1"], "MK": ["389", "00", "[2-578]\\d{7}", [8], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["2|34[47]|4(?:[37]7|5[47]|64)"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[347]"], "0$1"], ["(\\d{3})(\\d)(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[58]"], "0$1"]], "0"], "ML": ["223", "00", "[24-9]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[24-9]"]]]], "MM": ["95", "00", "1\\d{5,7}|95\\d{6}|(?:[4-7]|9[0-46-9])\\d{6,8}|(?:2|8\\d)\\d{5,8}", [6, 7, 8, 9, 10], [["(\\d)(\\d{2})(\\d{3})", "$1 $2 $3", ["16|2"], "0$1"], ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["[45]|6(?:0[23]|[1-689]|7[235-7])|7(?:[0-4]|5[2-7])|8[1-6]"], "0$1"], ["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[12]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[4-7]|8[1-35]"], "0$1"], ["(\\d)(\\d{3})(\\d{4,6})", "$1 $2 $3", ["9(?:2[0-4]|[35-9]|4[137-9])"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"], "0$1"], ["(\\d)(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["92"], "0$1"], ["(\\d)(\\d{5})(\\d{4})", "$1 $2 $3", ["9"], "0$1"]], "0"], "MN": ["976", "001", "[12]\\d{7,9}|[5-9]\\d{7}", [8, 9, 10], [["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["[12]1"], "0$1"], ["(\\d{4})(\\d{4})", "$1 $2", ["[5-9]"]], ["(\\d{3})(\\d{5,6})", "$1 $2", ["[12]2[1-3]"], "0$1"], ["(\\d{4})(\\d{5,6})", "$1 $2", ["[12](?:27|3[2-8]|4[2-68]|5[1-4689])", "[12](?:27|3[2-8]|4[2-68]|5[1-4689])[0-3]"], "0$1"], ["(\\d{5})(\\d{4,5})", "$1 $2", ["[12]"], "0$1"]], "0"], "MO": ["853", "00", "0800\\d{3}|(?:28|[68]\\d)\\d{6}", [7, 8], [["(\\d{4})(\\d{3})", "$1 $2", ["0"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[268]"]]]], "MP": ["1", "011", "[58]\\d{9}|(?:67|90)0\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "670$1", 0, "670"], "MQ": ["596", "00", "596\\d{6}|(?:69|80|9\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[569]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0$1"]], "0"], "MR": ["222", "00", "(?:[2-4]\\d\\d|800)\\d{5}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-48]"]]]], "MS": ["1", "011", "(?:[58]\\d\\d|664|900)\\d{7}", [10], 0, "1", 0, "([34]\\d{6})$|1", "664$1", 0, "664"], "MT": ["356", "00", "3550\\d{4}|(?:[2579]\\d\\d|800)\\d{5}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[2357-9]"]]]], "MU": ["230", "0(?:0|[24-7]0|3[03])", "(?:[57]|8\\d\\d)\\d{7}|[2-468]\\d{6}", [7, 8, 10], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-46]|8[013]"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[57]"]], ["(\\d{5})(\\d{5})", "$1 $2", ["8"]]], 0, 0, 0, 0, 0, 0, 0, "020"], "MV": ["960", "0(?:0|19)", "(?:800|9[0-57-9]\\d)\\d{7}|[34679]\\d{6}", [7, 10], [["(\\d{3})(\\d{4})", "$1-$2", ["[34679]"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[89]"]]], 0, 0, 0, 0, 0, 0, 0, "00"], "MW": ["265", "00", "(?:[1289]\\d|31|77)\\d{7}|1\\d{6}", [7, 9], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["1[2-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[137-9]"], "0$1"]], "0"], "MX": ["52", "0[09]", "1(?:(?:22|44|7[27]|87|9[69])[1-9]|65[0-689])\\d{7}|(?:1(?:[01]\\d|2[13-9]|[35][1-9]|4[0-35-9]|6[0-46-9]|7[013-689]|8[1-69]|9[1-578])|[2-9]\\d)\\d{8}", [10, 11], [["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["33|5[56]|81"], 0, 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-9]"], 0, 1], ["(\\d)(\\d{2})(\\d{4})(\\d{4})", "$2 $3 $4", ["1(?:33|5[56]|81)"], 0, 1], ["(\\d)(\\d{3})(\\d{3})(\\d{4})", "$2 $3 $4", ["1"], 0, 1]], "01", 0, "0(?:[12]|4[45])|1", 0, 0, 0, 0, "00"], "MY": ["60", "00", "1\\d{8,9}|(?:3\\d|[4-9])\\d{7}", [8, 9, 10], [["(\\d)(\\d{3})(\\d{4})", "$1-$2 $3", ["[4-79]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1-$2 $3", ["1(?:[02469]|[378][1-9]|53)|8", "1(?:[02469]|[37][1-9]|53|8(?:[1-46-9]|5[7-9]))|8"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1-$2 $3", ["3"], "0$1"], ["(\\d)(\\d{3})(\\d{2})(\\d{4})", "$1-$2-$3-$4", ["1(?:[367]|80)"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2 $3", ["15"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1-$2 $3", ["1"], "0$1"]], "0"], "MZ": ["258", "00", "(?:2|8\\d)\\d{7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2|8[2-79]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]]]], "NA": ["264", "00", "[68]\\d{7,8}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["88"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["6"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["87"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"], "0$1"]], "0"], "NC": ["687", "00", "(?:050|[2-57-9]\\d\\d)\\d{3}", [6], [["(\\d{2})(\\d{2})(\\d{2})", "$1.$2.$3", ["[02-57-9]"]]]], "NE": ["227", "00", "[027-9]\\d{7}", [8], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["08"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[089]|2[013]|7[047]"]]]], "NF": ["672", "00", "[13]\\d{5}", [6], [["(\\d{2})(\\d{4})", "$1 $2", ["1[0-3]"]], ["(\\d)(\\d{5})", "$1 $2", ["[13]"]]], 0, 0, "([0-258]\\d{4})$", "3$1"], "NG": ["234", "009", "2[0-24-9]\\d{8}|[78]\\d{10,13}|[7-9]\\d{9}|[1-9]\\d{7}|[124-7]\\d{6}", [7, 8, 10, 11, 12, 13, 14], [["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["78"], "0$1"], ["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[12]|9(?:0[3-9]|[1-9])"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2,3})", "$1 $2 $3", ["[3-6]|7(?:0[0-689]|[1-79])|8[2-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[7-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["20[129]"], "0$1"], ["(\\d{4})(\\d{2})(\\d{4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{3})(\\d{4})(\\d{4,5})", "$1 $2 $3", ["[78]"], "0$1"], ["(\\d{3})(\\d{5})(\\d{5,6})", "$1 $2 $3", ["[78]"], "0$1"]], "0"], "NI": ["505", "00", "(?:1800|[25-8]\\d{3})\\d{4}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[125-8]"]]]], "NL": ["31", "00", "(?:[124-7]\\d\\d|3(?:[02-9]\\d|1[0-8]))\\d{6}|8\\d{6,9}|9\\d{6,10}|1\\d{4,5}", [5, 6, 7, 8, 9, 10, 11], [["(\\d{3})(\\d{4,7})", "$1 $2", ["[89]0"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["66"], "0$1"], ["(\\d)(\\d{8})", "$1 $2", ["6"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["1[16-8]|2[259]|3[124]|4[17-9]|5[124679]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1-578]|91"], "0$1"], ["(\\d{3})(\\d{3})(\\d{5})", "$1 $2 $3", ["9"], "0$1"]], "0"], "NO": ["47", "00", "(?:0|[2-9]\\d{3})\\d{4}", [5, 8], [["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["8"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-79]"]]], 0, 0, 0, 0, 0, "[02-689]|7[0-8]"], "NP": ["977", "00", "(?:1\\d|9)\\d{9}|[1-9]\\d{7}", [8, 10, 11], [["(\\d)(\\d{7})", "$1-$2", ["1[2-6]"], "0$1"], ["(\\d{2})(\\d{6})", "$1-$2", ["1[01]|[2-8]|9(?:[1-59]|[67][2-6])"], "0$1"], ["(\\d{3})(\\d{7})", "$1-$2", ["9"]]], "0"], "NR": ["674", "00", "(?:444|(?:55|8\\d)\\d|666)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[4-68]"]]]], "NU": ["683", "00", "(?:[4-7]|888\\d)\\d{3}", [4, 7], [["(\\d{3})(\\d{4})", "$1 $2", ["8"]]]], "NZ": ["64", "0(?:0|161)", "[1289]\\d{9}|50\\d{5}(?:\\d{2,3})?|[27-9]\\d{7,8}|(?:[34]\\d|6[0-35-9])\\d{6}|8\\d{4,6}", [5, 6, 7, 8, 9, 10], [["(\\d{2})(\\d{3,8})", "$1 $2", ["8[1-79]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["50[036-8]|8|90", "50(?:[0367]|88)|8|90"], "0$1"], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["24|[346]|7[2-57-9]|9[2-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2(?:10|74)|[589]"], "0$1"], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["1|2[028]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,5})", "$1 $2 $3", ["2(?:[169]|7[0-35-9])|7"], "0$1"]], "0", 0, 0, 0, 0, 0, 0, "00"], "OM": ["968", "00", "(?:1505|[279]\\d{3}|500)\\d{4}|800\\d{5,6}", [7, 8, 9], [["(\\d{3})(\\d{4,6})", "$1 $2", ["[58]"]], ["(\\d{2})(\\d{6})", "$1 $2", ["2"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[179]"]]]], "PA": ["507", "00", "(?:00800|8\\d{3})\\d{6}|[68]\\d{7}|[1-57-9]\\d{6}", [7, 8, 10, 11], [["(\\d{3})(\\d{4})", "$1-$2", ["[1-57-9]"]], ["(\\d{4})(\\d{4})", "$1-$2", ["[68]"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"]]]], "PE": ["51", "00|19(?:1[124]|77|90)00", "(?:[14-8]|9\\d)\\d{7}", [8, 9], [["(\\d{3})(\\d{5})", "$1 $2", ["80"], "(0$1)"], ["(\\d)(\\d{7})", "$1 $2", ["1"], "(0$1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["[4-8]"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"]]], "0", 0, 0, 0, 0, 0, 0, "00", " Anexo "], "PF": ["689", "00", "4\\d{5}(?:\\d{2})?|8\\d{7,8}", [6, 8, 9], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["44"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["4|8[7-9]"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]]]], "PG": ["675", "00|140[1-3]", "(?:180|[78]\\d{3})\\d{4}|(?:[2-589]\\d|64)\\d{5}", [7, 8], [["(\\d{3})(\\d{4})", "$1 $2", ["18|[2-69]|85"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[78]"]]], 0, 0, 0, 0, 0, 0, 0, "00"], "PH": ["63", "00", "(?:[2-7]|9\\d)\\d{8}|2\\d{5}|(?:1800|8)\\d{7,9}", [6, 8, 9, 10, 11, 12, 13], [["(\\d)(\\d{5})", "$1 $2", ["2"], "(0$1)"], ["(\\d{4})(\\d{4,6})", "$1 $2", ["3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|544|88[245]|(?:52|64|86)2", "3(?:230|397|461)|4(?:2(?:35|[46]4|51)|396|4(?:22|63)|59[347]|76[15])|5(?:221|446)|642[23]|8(?:622|8(?:[24]2|5[13]))"], "(0$1)"], ["(\\d{5})(\\d{4})", "$1 $2", ["346|4(?:27|9[35])|883", "3469|4(?:279|9(?:30|56))|8834"], "(0$1)"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["2"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[3-7]|8[2-8]"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[89]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]], ["(\\d{4})(\\d{1,2})(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["1"]]], "0"], "PK": ["92", "00", "122\\d{6}|[24-8]\\d{10,11}|9(?:[013-9]\\d{8,10}|2(?:[01]\\d\\d|2(?:[06-8]\\d|1[01]))\\d{7})|(?:[2-8]\\d{3}|92(?:[0-7]\\d|8[1-9]))\\d{6}|[24-9]\\d{8}|[89]\\d{7}", [8, 9, 10, 11, 12], [["(\\d{3})(\\d{3})(\\d{2,7})", "$1 $2 $3", ["[89]0"], "0$1"], ["(\\d{4})(\\d{5})", "$1 $2", ["1"]], ["(\\d{3})(\\d{6,7})", "$1 $2", ["2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8])", "9(?:2[3-8]|98)|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:22|3[27-9]|4[2-6]|6[3569]|9[25-7]))[2-9]"], "(0$1)"], ["(\\d{2})(\\d{7,8})", "$1 $2", ["(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]"], "(0$1)"], ["(\\d{5})(\\d{5})", "$1 $2", ["58"], "(0$1)"], ["(\\d{3})(\\d{7})", "$1 $2", ["3"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["[24-9]"], "(0$1)"]], "0"], "PL": ["48", "00", "(?:6|8\\d\\d)\\d{7}|[1-9]\\d{6}(?:\\d{2})?|[26]\\d{5}", [6, 7, 8, 9, 10], [["(\\d{5})", "$1", ["19"]], ["(\\d{3})(\\d{3})", "$1 $2", ["11|20|64"]], ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])1", "(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])19"]], ["(\\d{3})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["64"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["21|39|45|5[0137]|6[0469]|7[02389]|8(?:0[14]|8)"]], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["1[2-8]|[2-7]|8[1-79]|9[145]"]], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["8"]]]], "PM": ["508", "00", "[45]\\d{5}|(?:708|80\\d)\\d{6}", [6, 9], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["[45]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["7"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0$1"]], "0"], "PR": ["1", "011", "(?:[589]\\d\\d|787)\\d{7}", [10], 0, "1", 0, 0, 0, 0, "787|939"], "PS": ["970", "00", "[2489]2\\d{6}|(?:1\\d|5)\\d{8}", [8, 9, 10], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[2489]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["5"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]]], "0"], "PT": ["351", "00", "1693\\d{5}|(?:[26-9]\\d|30)\\d{7}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["2[12]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["16|[236-9]"]]]], "PW": ["680", "01[12]", "(?:[24-8]\\d\\d|345|900)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-9]"]]]], "PY": ["595", "00", "59\\d{4,6}|9\\d{5,10}|(?:[2-46-8]\\d|5[0-8])\\d{4,7}", [6, 7, 8, 9, 10, 11], [["(\\d{3})(\\d{3,6})", "$1 $2", ["[2-9]0"], "0$1"], ["(\\d{2})(\\d{5})", "$1 $2", ["[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36]"], "(0$1)"], ["(\\d{3})(\\d{4,5})", "$1 $2", ["2[279]|3[13-5]|4[359]|5|6(?:[34]|7[1-46-8])|7[46-8]|85"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2[14-68]|3[26-9]|4[1246-8]|6(?:1|75)|7[1-35]|8[1-36]"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["87"]], ["(\\d{3})(\\d{6})", "$1 $2", ["9(?:[5-79]|8[1-7])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-8]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["9"]]], "0"], "QA": ["974", "00", "800\\d{4}|(?:2|800)\\d{6}|(?:0080|[3-7])\\d{7}", [7, 8, 9, 11], [["(\\d{3})(\\d{4})", "$1 $2", ["2[16]|8"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[3-7]"]]]], "RE": ["262", "00", "(?:26|[689]\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2689]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["26(?:2\\d\\d|3(?:0\\d|1[0-6]))\\d{4}"], ["69(?:2\\d\\d|3(?:[06][0-6]|1[013]|2[0-2]|3[0-39]|4\\d|5[0-5]|7[0-37]|8[0-8]|9[0-479]))\\d{4}"], ["80\\d{7}"], ["89[1-37-9]\\d{6}"], 0, 0, 0, 0, ["9(?:399[0-3]|479[0-5]|76(?:2[27]|3[0-37]))\\d{4}"], ["8(?:1[019]|2[0156]|84|90)\\d{6}"]]], "RO": ["40", "00", "(?:[236-8]\\d|90)\\d{7}|[23]\\d{5}", [6, 9], [["(\\d{3})(\\d{3})", "$1 $2", ["2[3-6]", "2[3-6]\\d9"], "0$1"], ["(\\d{2})(\\d{4})", "$1 $2", ["219|31"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[23]1"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[236-9]"], "0$1"]], "0", 0, 0, 0, 0, 0, 0, 0, " int "], "RS": ["381", "00", "38[02-9]\\d{6,9}|6\\d{7,9}|90\\d{4,8}|38\\d{5,6}|(?:7\\d\\d|800)\\d{3,9}|(?:[12]\\d|3[0-79])\\d{5,10}", [6, 7, 8, 9, 10, 11, 12], [["(\\d{3})(\\d{3,9})", "$1 $2", ["(?:2[389]|39)0|[7-9]"], "0$1"], ["(\\d{2})(\\d{5,10})", "$1 $2", ["[1-36]"], "0$1"]], "0"], "RU": ["7", "810", "8\\d{13}|[347-9]\\d{9}", [10, 14], [["(\\d{4})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["7(?:1[0-8]|2[1-9])", "7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:1[23]|[2-9]2))", "7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:13[03-69]|62[013-9]))|72[1-57-9]2"], "8 ($1)", 1], ["(\\d{5})(\\d)(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["7(?:1[0-68]|2[1-9])", "7(?:1(?:[06][3-6]|[18]|2[35]|[3-5][3-5])|2(?:[13][3-5]|[24-689]|7[457]))", "7(?:1(?:0(?:[356]|4[023])|[18]|2(?:3[013-9]|5)|3[45]|43[013-79]|5(?:3[1-8]|4[1-7]|5)|6(?:3[0-35-9]|[4-6]))|2(?:1(?:3[178]|[45])|[24-689]|3[35]|7[457]))|7(?:14|23)4[0-8]|71(?:33|45)[1-79]"], "8 ($1)", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "8 ($1)", 1], ["(\\d{3})(\\d{3})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["[349]|8(?:[02-7]|1[1-8])"], "8 ($1)", 1], ["(\\d{4})(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["8"], "8 ($1)"]], "8", 0, 0, 0, 0, "3[04-689]|[489]", 0, "8~10"], "RW": ["250", "00", "(?:06|[27]\\d\\d|[89]00)\\d{6}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["0"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["2"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[7-9]"], "0$1"]], "0"], "SA": ["966", "00", "92\\d{7}|(?:[15]|8\\d)\\d{8}", [9, 10], [["(\\d{4})(\\d{5})", "$1 $2", ["9"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["5"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["81"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"]]], "0"], "SB": ["677", "0[01]", "(?:[1-6]|[7-9]\\d\\d)\\d{4}", [5, 7], [["(\\d{2})(\\d{5})", "$1 $2", ["7|8[4-9]|9(?:[1-8]|9[0-8])"]]]], "SC": ["248", "010|0[0-2]", "800\\d{4}|(?:[249]\\d|64)\\d{5}", [7], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[246]|9[57]"]]], 0, 0, 0, 0, 0, 0, 0, "00"], "SD": ["249", "00", "[19]\\d{8}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[19]"], "0$1"]], "0"], "SE": ["46", "00", "(?:[26]\\d\\d|9)\\d{9}|[1-9]\\d{8}|[1-689]\\d{7}|[1-4689]\\d{6}|2\\d{5}", [6, 7, 8, 9, 10], [["(\\d{2})(\\d{2,3})(\\d{2})", "$1-$2 $3", ["20"], "0$1", 0, "$1 $2 $3"], ["(\\d{3})(\\d{4})", "$1-$2", ["9(?:00|39|44|9)"], "0$1", 0, "$1 $2"], ["(\\d{2})(\\d{3})(\\d{2})", "$1-$2 $3", ["[12][136]|3[356]|4[0246]|6[03]|90[1-9]"], "0$1", 0, "$1 $2 $3"], ["(\\d)(\\d{2,3})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["8"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2,3})(\\d{2})", "$1-$2 $3", ["1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[125689]|4[02-57]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"], "0$1", 0, "$1 $2 $3"], ["(\\d{3})(\\d{2,3})(\\d{3})", "$1-$2 $3", ["9(?:00|39|44)"], "0$1", 0, "$1 $2 $3"], ["(\\d{2})(\\d{2,3})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["1[13689]|2[0136]|3[1356]|4[0246]|54|6[03]|90[1-9]"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["10|7"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d)(\\d{3})(\\d{3})(\\d{2})", "$1-$2 $3 $4", ["8"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["[13-5]|2(?:[247-9]|5[0138])|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{3})", "$1-$2 $3 $4", ["9"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1-$2 $3 $4 $5", ["[26]"], "0$1", 0, "$1 $2 $3 $4 $5"]], "0"], "SG": ["65", "0[0-3]\\d", "(?:(?:1\\d|8)\\d\\d|7000)\\d{7}|[3689]\\d{7}", [8, 10, 11], [["(\\d{4})(\\d{4})", "$1 $2", ["[369]|8(?:0[1-9]|[1-9])"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"]], ["(\\d{4})(\\d{4})(\\d{3})", "$1 $2 $3", ["7"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]]]], "SH": ["290", "00", "(?:[256]\\d|8)\\d{3}", [4, 5], 0, 0, 0, 0, 0, 0, "[256]"], "SI": ["386", "00|10(?:22|66|88|99)", "[1-7]\\d{7}|8\\d{4,7}|90\\d{4,6}", [5, 6, 7, 8], [["(\\d{2})(\\d{3,6})", "$1 $2", ["8[09]|9"], "0$1"], ["(\\d{3})(\\d{5})", "$1 $2", ["59|8"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[37][01]|4[0139]|51|6"], "0$1"], ["(\\d)(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[1-57]"], "(0$1)"]], "0", 0, 0, 0, 0, 0, 0, "00"], "SJ": ["47", "00", "0\\d{4}|(?:[489]\\d|79)\\d{6}", [5, 8], 0, 0, 0, 0, 0, 0, "79"], "SK": ["421", "00", "[2-689]\\d{8}|[2-59]\\d{6}|[2-5]\\d{5}", [6, 7, 9], [["(\\d)(\\d{2})(\\d{3,4})", "$1 $2 $3", ["21"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["[3-5][1-8]1", "[3-5][1-8]1[67]"], "0$1"], ["(\\d)(\\d{3})(\\d{3})(\\d{2})", "$1/$2 $3 $4", ["2"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[689]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1/$2 $3 $4", ["[3-5]"], "0$1"]], "0"], "SL": ["232", "00", "(?:[237-9]\\d|66)\\d{6}", [8], [["(\\d{2})(\\d{6})", "$1 $2", ["[236-9]"], "(0$1)"]], "0"], "SM": ["378", "00", "(?:0549|[5-7]\\d)\\d{6}", [8, 10], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-7]"]], ["(\\d{4})(\\d{6})", "$1 $2", ["0"]]], 0, 0, "([89]\\d{5})$", "0549$1"], "SN": ["221", "00", "(?:[378]\\d|93)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[379]"]]]], "SO": ["252", "00", "[346-9]\\d{8}|[12679]\\d{7}|[1-5]\\d{6}|[1348]\\d{5}", [6, 7, 8, 9], [["(\\d{2})(\\d{4})", "$1 $2", ["8[125]"]], ["(\\d{6})", "$1", ["[134]"]], ["(\\d)(\\d{6})", "$1 $2", ["[15]|2[0-79]|3[0-46-8]|4[0-7]"]], ["(\\d)(\\d{7})", "$1 $2", ["(?:2|90)4|[67]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[348]|64|79|90"]], ["(\\d{2})(\\d{5,7})", "$1 $2", ["1|28|6[0-35-9]|77|9[2-9]"]]], "0"], "SR": ["597", "00", "(?:[2-5]|68|[78]\\d)\\d{5}", [6, 7], [["(\\d{2})(\\d{2})(\\d{2})", "$1-$2-$3", ["56"]], ["(\\d{3})(\\d{3})", "$1-$2", ["[2-5]"]], ["(\\d{3})(\\d{4})", "$1-$2", ["[6-8]"]]]], "SS": ["211", "00", "[19]\\d{8}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[19]"], "0$1"]], "0"], "ST": ["239", "00", "(?:22|9\\d)\\d{5}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[29]"]]]], "SV": ["503", "00", "[267]\\d{7}|(?:80\\d|900)\\d{4}(?:\\d{4})?", [7, 8, 11], [["(\\d{3})(\\d{4})", "$1 $2", ["[89]"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[267]"]], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["[89]"]]]], "SX": ["1", "011", "7215\\d{6}|(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "(5\\d{6})$|1", "721$1", 0, "721"], "SY": ["963", "00", "[1-39]\\d{8}|[1-5]\\d{7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[1-5]"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"], "0$1", 1]], "0"], "SZ": ["268", "00", "0800\\d{4}|(?:[237]\\d|900)\\d{6}", [8, 9], [["(\\d{4})(\\d{4})", "$1 $2", ["[0237]"]], ["(\\d{5})(\\d{4})", "$1 $2", ["9"]]]], "TA": ["290", "00", "8\\d{3}", [4], 0, 0, 0, 0, 0, 0, "8"], "TC": ["1", "011", "(?:[58]\\d\\d|649|900)\\d{7}", [10], 0, "1", 0, "([2-479]\\d{6})$|1", "649$1", 0, "649"], "TD": ["235", "00|16", "(?:22|[69]\\d|77)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2679]"]]], 0, 0, 0, 0, 0, 0, 0, "00"], "TG": ["228", "00", "[279]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[279]"]]]], "TH": ["66", "00[1-9]", "(?:001800|[2-57]|[689]\\d)\\d{7}|1\\d{7,9}", [8, 9, 10, 13], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[13-9]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]]], "0"], "TJ": ["992", "810", "[0-57-9]\\d{8}", [9], [["(\\d{6})(\\d)(\\d{2})", "$1 $2 $3", ["331", "3317"]], ["(\\d{3})(\\d{2})(\\d{4})", "$1 $2 $3", ["44[02-479]|[34]7"]], ["(\\d{4})(\\d)(\\d{4})", "$1 $2 $3", ["3[1-5]"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[0-57-9]"]]], 0, 0, 0, 0, 0, 0, 0, "8~10"], "TK": ["690", "00", "[2-47]\\d{3,6}", [4, 5, 6, 7]], "TL": ["670", "00", "7\\d{7}|(?:[2-47]\\d|[89]0)\\d{5}", [7, 8], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-489]|70"]], ["(\\d{4})(\\d{4})", "$1 $2", ["7"]]]], "TM": ["993", "810", "(?:[1-6]\\d|71)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["12"], "(8 $1)"], ["(\\d{3})(\\d)(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["[1-5]"], "(8 $1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["[67]"], "8 $1"]], "8", 0, 0, 0, 0, 0, 0, "8~10"], "TN": ["216", "00", "[2-57-9]\\d{7}", [8], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-57-9]"]]]], "TO": ["676", "00", "(?:0800|(?:[5-8]\\d\\d|999)\\d)\\d{3}|[2-8]\\d{4}", [5, 7], [["(\\d{2})(\\d{3})", "$1-$2", ["[2-4]|50|6[09]|7[0-24-69]|8[05]"]], ["(\\d{4})(\\d{3})", "$1 $2", ["0"]], ["(\\d{3})(\\d{4})", "$1 $2", ["[5-9]"]]]], "TR": ["90", "00", "4\\d{6}|8\\d{11,12}|(?:[2-58]\\d\\d|900)\\d{7}", [7, 10, 12, 13], [["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["512|8[01589]|90"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["5(?:[0-59]|61)", "5(?:[0-59]|61[06])", "5(?:[0-59]|61[06]1)"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[24][1-8]|3[1-9]"], "(0$1)", 1], ["(\\d{3})(\\d{3})(\\d{6,7})", "$1 $2 $3", ["80"], "0$1", 1]], "0"], "TT": ["1", "011", "(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-46-8]\\d{6})$|1", "868$1", 0, "868"], "TV": ["688", "00", "(?:2|7\\d\\d|90)\\d{4}", [5, 6, 7], [["(\\d{2})(\\d{3})", "$1 $2", ["2"]], ["(\\d{2})(\\d{4})", "$1 $2", ["90"]], ["(\\d{2})(\\d{5})", "$1 $2", ["7"]]]], "TW": ["886", "0(?:0[25-79]|19)", "[2-689]\\d{8}|7\\d{9,10}|[2-8]\\d{7}|2\\d{6}", [7, 8, 9, 10, 11], [["(\\d{2})(\\d)(\\d{4})", "$1 $2 $3", ["202"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[258]0"], "0$1"], ["(\\d)(\\d{3,4})(\\d{4})", "$1 $2 $3", ["[23568]|4(?:0[02-48]|[1-47-9])|7[1-9]", "[23568]|4(?:0[2-48]|[1-47-9])|(?:400|7)[1-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[49]"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4,5})", "$1 $2 $3", ["7"], "0$1"]], "0", 0, 0, 0, 0, 0, 0, 0, "#"], "TZ": ["255", "00[056]", "(?:[25-8]\\d|41|90)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{4})", "$1 $2 $3", ["[89]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[24]"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["5"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[67]"], "0$1"]], "0"], "UA": ["380", "00", "[89]\\d{9}|[3-9]\\d{8}", [9, 10], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6[12][29]|(?:3[1-8]|4[136-8]|5[12457]|6[49])2|(?:56|65)[24]", "6[12][29]|(?:35|4[1378]|5[12457]|6[49])2|(?:56|65)[24]|(?:3[1-46-8]|46)2[013-9]"], "0$1"], ["(\\d{4})(\\d{5})", "$1 $2", ["3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6[0135689]|7[4-6])|6(?:[12][3-7]|[459])", "3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6(?:[015689]|3[02389])|7[4-6])|6(?:[12][3-7]|[459])"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[3-7]|89|9[1-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[89]"], "0$1"]], "0", 0, 0, 0, 0, 0, 0, "0~0"], "UG": ["256", "00[057]", "800\\d{6}|(?:[29]0|[347]\\d)\\d{7}", [9], [["(\\d{4})(\\d{5})", "$1 $2", ["202", "2024"], "0$1"], ["(\\d{3})(\\d{6})", "$1 $2", ["[27-9]|4(?:6[45]|[7-9])"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["[34]"], "0$1"]], "0"], "US": ["1", "011", "[2-9]\\d{9}|3\\d{6}", [10], [["(\\d{3})(\\d{4})", "$1-$2", ["310"], 0, 1], ["(\\d{3})(\\d{3})(\\d{4})", "($1) $2-$3", ["[2-9]"], 0, 1, "$1-$2-$3"]], "1", 0, 0, 0, 0, 0, [["(?:5056(?:[0-35-9]\\d|4[468])|7302[0-4]\\d)\\d{4}|(?:472[24]|505[2-57-9]|7306|983[2-47-9])\\d{6}|(?:2(?:0[1-35-9]|1[02-9]|2[03-57-9]|3[1459]|4[08]|5[1-46]|6[0279]|7[0269]|8[13])|3(?:0[1-57-9]|1[02-9]|2[013569]|3[0-24679]|4[167]|5[0-2]|6[01349]|8[056])|4(?:0[124-9]|1[02-579]|2[3-5]|3[0245]|4[023578]|58|6[349]|7[0589]|8[04])|5(?:0[1-47-9]|1[0235-8]|20|3[0149]|4[01]|5[179]|6[1-47]|7[0-5]|8[0256])|6(?:0[1-35-9]|1[024-9]|2[03689]|3[016]|4[0156]|5[01679]|6[0-279]|78|8[0-29])|7(?:0[1-46-8]|1[2-9]|2[04-8]|3[1247]|4[037]|5[47]|6[02359]|7[0-59]|8[156])|8(?:0[1-68]|1[02-8]|2[068]|3[0-2589]|4[03578]|5[046-9]|6[02-5]|7[028])|9(?:0[1346-9]|1[02-9]|2[0589]|3[0146-8]|4[01357-9]|5[12469]|7[0-389]|8[04-69]))[2-9]\\d{6}"], [""], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], "UY": ["598", "0(?:0|1[3-9]\\d)", "0004\\d{2,9}|[1249]\\d{7}|(?:[49]\\d|80)\\d{5}", [6, 7, 8, 9, 10, 11, 12, 13], [["(\\d{3})(\\d{3,4})", "$1 $2", ["0"]], ["(\\d{3})(\\d{4})", "$1 $2", ["[49]0|8"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{4})(\\d{4})", "$1 $2", ["[124]"]], ["(\\d{3})(\\d{3})(\\d{2,4})", "$1 $2 $3", ["0"]], ["(\\d{3})(\\d{3})(\\d{3})(\\d{2,4})", "$1 $2 $3 $4", ["0"]]], "0", 0, 0, 0, 0, 0, 0, "00", " int. "], "UZ": ["998", "810", "(?:20|33|[5-79]\\d|88)\\d{7}", [9], [["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[235-9]"], "8 $1"]], "8", 0, 0, 0, 0, 0, 0, "8~10"], "VA": ["39", "00", "0\\d{5,10}|3[0-8]\\d{7,10}|55\\d{8}|8\\d{5}(?:\\d{2,4})?|(?:1\\d|39)\\d{7,8}", [6, 7, 8, 9, 10, 11], 0, 0, 0, 0, 0, 0, "06698"], "VC": ["1", "011", "(?:[58]\\d\\d|784|900)\\d{7}", [10], 0, "1", 0, "([2-7]\\d{6})$|1", "784$1", 0, "784"], "VE": ["58", "00", "[68]00\\d{7}|(?:[24]\\d|[59]0)\\d{8}", [10], [["(\\d{3})(\\d{7})", "$1-$2", ["[24-689]"], "0$1"]], "0"], "VG": ["1", "011", "(?:284|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-578]\\d{6})$|1", "284$1", 0, "284"], "VI": ["1", "011", "[58]\\d{9}|(?:34|90)0\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "340$1", 0, "340"], "VN": ["84", "00", "[12]\\d{9}|[135-9]\\d{8}|[16]\\d{7}|[16-8]\\d{6}", [7, 8, 9, 10], [["(\\d{2})(\\d{5})", "$1 $2", ["80"], "0$1", 1], ["(\\d{4})(\\d{4,6})", "$1 $2", ["1"], 0, 1], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["6"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[357-9]"], "0$1", 1], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["2[48]"], "0$1", 1], ["(\\d{3})(\\d{4})(\\d{3})", "$1 $2 $3", ["2"], "0$1", 1]], "0"], "VU": ["678", "00", "[57-9]\\d{6}|(?:[238]\\d|48)\\d{3}", [5, 7], [["(\\d{3})(\\d{4})", "$1 $2", ["[57-9]"]]]], "WF": ["681", "00", "(?:40|72)\\d{4}|8\\d{5}(?:\\d{3})?", [6, 9], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["[478]"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]]]], "WS": ["685", "0", "(?:[2-6]|8\\d{5})\\d{4}|[78]\\d{6}|[68]\\d{5}", [5, 6, 7, 10], [["(\\d{5})", "$1", ["[2-5]|6[1-9]"]], ["(\\d{3})(\\d{3,7})", "$1 $2", ["[68]"]], ["(\\d{2})(\\d{5})", "$1 $2", ["7"]]]], "XK": ["383", "00", "2\\d{7,8}|3\\d{7,11}|(?:4\\d\\d|[89]00)\\d{5}", [8, 9, 10, 11, 12], [["(\\d{3})(\\d{5})", "$1 $2", ["[89]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-4]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["2|39"], "0$1"], ["(\\d{2})(\\d{7,10})", "$1 $2", ["3"], "0$1"]], "0"], "YE": ["967", "00", "(?:1|7\\d)\\d{7}|[1-7]\\d{6}", [7, 8, 9], [["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[1-6]|7(?:[24-6]|8[0-7])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["7"], "0$1"]], "0"], "YT": ["262", "00", "(?:80|9\\d)\\d{7}|(?:26|63)9\\d{6}", [9], 0, "0", 0, 0, 0, 0, 0, [["269(?:0[0-467]|15|5[0-4]|6\\d|[78]0)\\d{4}"], ["639(?:0[0-79]|1[019]|[267]\\d|3[09]|40|5[05-9]|9[04-79])\\d{4}"], ["80\\d{7}"], 0, 0, 0, 0, 0, ["9(?:(?:39|47)8[01]|769\\d)\\d{4}"]]], "ZA": ["27", "00", "[1-79]\\d{8}|8\\d{4,9}", [5, 6, 7, 8, 9, 10], [["(\\d{2})(\\d{3,4})", "$1 $2", ["8[1-4]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2,3})", "$1 $2 $3", ["8[1-4]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["860"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"], "0$1"]], "0"], "ZM": ["260", "00", "800\\d{6}|(?:21|63|[79]\\d)\\d{7}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[28]"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["[79]"], "0$1"]], "0"], "ZW": ["263", "00", "2(?:[0-57-9]\\d{6,8}|6[0-24-9]\\d{6,7})|[38]\\d{9}|[35-8]\\d{8}|[3-6]\\d{7}|[1-689]\\d{6}|[1-3569]\\d{5}|[1356]\\d{4}", [5, 6, 7, 8, 9, 10], [["(\\d{3})(\\d{3,5})", "$1 $2", ["2(?:0[45]|2[278]|[49]8)|3(?:[09]8|17)|6(?:[29]8|37|75)|[23][78]|(?:33|5[15]|6[68])[78]"], "0$1"], ["(\\d)(\\d{3})(\\d{2,4})", "$1 $2 $3", ["[49]"], "0$1"], ["(\\d{3})(\\d{4})", "$1 $2", ["80"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["24|8[13-59]|(?:2[05-79]|39|5[45]|6[15-8])2", "2(?:02[014]|4|[56]20|[79]2)|392|5(?:42|525)|6(?:[16-8]21|52[013])|8[13-59]"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2(?:1[39]|2[0157]|[378]|[56][14])|3(?:12|29)", "2(?:1[39]|2[0157]|[378]|[56][14])|3(?:123|29)"], "0$1"], ["(\\d{4})(\\d{6})", "$1 $2", ["8"], "0$1"], ["(\\d{2})(\\d{3,5})", "$1 $2", ["1|2(?:0[0-36-9]|12|29|[56])|3(?:1[0-689]|[24-6])|5(?:[0236-9]|1[2-4])|6(?:[013-59]|7[0-46-9])|(?:33|55|6[68])[0-69]|(?:29|3[09]|62)[0-79]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["29[013-9]|39|54"], "0$1"], ["(\\d{4})(\\d{3,5})", "$1 $2", ["(?:25|54)8", "258|5483"], "0$1"]], "0"] }, "nonGeographic": { "800": ["800", 0, "(?:00|[1-9]\\d)\\d{6}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["\\d"]]], 0, 0, 0, 0, 0, 0, [0, 0, ["(?:00|[1-9]\\d)\\d{6}"]]], "808": ["808", 0, "[1-9]\\d{7}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[1-9]"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, 0, 0, 0, ["[1-9]\\d{7}"]]], "870": ["870", 0, "7\\d{11}|[35-7]\\d{8}", [9, 12], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[35-7]"]]], 0, 0, 0, 0, 0, 0, [0, ["(?:[356]|774[45])\\d{8}|7[6-8]\\d{7}"]]], "878": ["878", 0, "10\\d{10}", [12], [["(\\d{2})(\\d{5})(\\d{5})", "$1 $2 $3", ["1"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, 0, 0, ["10\\d{10}"]]], "881": ["881", 0, "6\\d{9}|[0-36-9]\\d{8}", [9, 10], [["(\\d)(\\d{3})(\\d{5})", "$1 $2 $3", ["[0-37-9]"]], ["(\\d)(\\d{3})(\\d{5,6})", "$1 $2 $3", ["6"]]], 0, 0, 0, 0, 0, 0, [0, ["6\\d{9}|[0-36-9]\\d{8}"]]], "882": ["882", 0, "[13]\\d{6}(?:\\d{2,5})?|[19]\\d{7}|(?:[25]\\d\\d|4)\\d{7}(?:\\d{2})?", [7, 8, 9, 10, 11, 12], [["(\\d{2})(\\d{5})", "$1 $2", ["16|342"]], ["(\\d{2})(\\d{6})", "$1 $2", ["49"]], ["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["1[36]|9"]], ["(\\d{2})(\\d{4})(\\d{3})", "$1 $2 $3", ["3[23]"]], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["16"]], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["10|23|3(?:[15]|4[57])|4|51"]], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["34"]], ["(\\d{2})(\\d{4,5})(\\d{5})", "$1 $2 $3", ["[1-35]"]]], 0, 0, 0, 0, 0, 0, [0, ["342\\d{4}|(?:337|49)\\d{6}|(?:3(?:2|47|7\\d{3})|50\\d{3})\\d{7}", [7, 8, 9, 10, 12]], 0, 0, 0, 0, 0, 0, ["1(?:3(?:0[0347]|[13][0139]|2[035]|4[013568]|6[0459]|7[06]|8[15-8]|9[0689])\\d{4}|6\\d{5,10})|(?:345\\d|9[89])\\d{6}|(?:10|2(?:3|85\\d)|3(?:[15]|[69]\\d\\d)|4[15-8]|51)\\d{8}"]]], "883": ["883", 0, "(?:[1-4]\\d|51)\\d{6,10}", [8, 9, 10, 11, 12], [["(\\d{3})(\\d{3})(\\d{2,8})", "$1 $2 $3", ["[14]|2[24-689]|3[02-689]|51[24-9]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["510"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["21"]], ["(\\d{4})(\\d{4})(\\d{4})", "$1 $2 $3", ["51[13]"]], ["(\\d{3})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["[235]"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, 0, 0, ["(?:2(?:00\\d\\d|10)|(?:370[1-9]|51\\d0)\\d)\\d{7}|51(?:00\\d{5}|[24-9]0\\d{4,7})|(?:1[0-79]|2[24-689]|3[02-689]|4[0-4])0\\d{5,9}"]]], "888": ["888", 0, "\\d{11}", [11], [["(\\d{3})(\\d{3})(\\d{5})", "$1 $2 $3"]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, ["\\d{11}"]]], "979": ["979", 0, "[1359]\\d{8}", [9], [["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["[1359]"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, ["[1359]\\d{8}"]]] } };
function edit(value, caret, operation) {
  switch (operation) {
    case "Backspace":
      if (caret > 0) {
        value = value.slice(0, caret - 1) + value.slice(caret);
        caret--;
      }
      break;
    case "Delete":
      value = value.slice(0, caret) + value.slice(caret + 1);
      break;
  }
  return {
    value,
    caret
  };
}
function parse$1(text, caret_position, parse_character) {
  var context = {};
  var value = "";
  var focused_input_character_index = 0;
  var index2 = 0;
  while (index2 < text.length) {
    var character = parse_character(text[index2], value, context);
    if (character !== void 0) {
      value += character;
      if (caret_position !== void 0) {
        if (caret_position === index2) {
          focused_input_character_index = value.length - 1;
        } else if (caret_position > index2) {
          focused_input_character_index = value.length;
        }
      }
    }
    index2++;
  }
  if (caret_position === void 0) {
    focused_input_character_index = value.length;
  }
  var result2 = {
    value,
    caret: focused_input_character_index
  };
  return result2;
}
function _createForOfIteratorHelperLoose$d(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2)
    return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray$g(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
    if (it2)
      o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length)
        return { done: true };
      return { done: false, value: o3[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$g(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$g(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$g(o3, minLen);
}
function _arrayLikeToArray$g(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function count_occurences(symbol, string) {
  var count2 = 0;
  for (var _iterator = _createForOfIteratorHelperLoose$d(string.split("")), _step; !(_step = _iterator()).done; ) {
    var character = _step.value;
    if (character === symbol) {
      count2++;
    }
  }
  return count2;
}
function closeBraces(retained_template, template) {
  var placeholder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "x";
  var empty_placeholder = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : " ";
  var cut_before = retained_template.length;
  var opening_braces = count_occurences("(", retained_template);
  var closing_braces = count_occurences(")", retained_template);
  var dangling_braces = opening_braces - closing_braces;
  while (dangling_braces > 0 && cut_before < template.length) {
    retained_template += template[cut_before].replace(placeholder, empty_placeholder);
    if (template[cut_before] === ")") {
      dangling_braces--;
    }
    cut_before++;
  }
  return retained_template;
}
function _createForOfIteratorHelperLoose$c(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2)
    return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray$f(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
    if (it2)
      o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length)
        return { done: true };
      return { done: false, value: o3[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$f(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$f(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$f(o3, minLen);
}
function _arrayLikeToArray$f(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function template_formatter(template) {
  var placeholder = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x";
  var should_close_braces = arguments.length > 2 ? arguments[2] : void 0;
  if (!template) {
    return function(value) {
      return {
        text: value
      };
    };
  }
  var characters_in_template = count_occurences(placeholder, template);
  return function(value) {
    if (!value) {
      return {
        text: "",
        template
      };
    }
    var value_character_index = 0;
    var filled_in_template = "";
    for (var _iterator = _createForOfIteratorHelperLoose$c(template.split("")), _step; !(_step = _iterator()).done; ) {
      var character = _step.value;
      if (character !== placeholder) {
        filled_in_template += character;
        continue;
      }
      filled_in_template += value[value_character_index];
      value_character_index++;
      if (value_character_index === value.length) {
        if (value.length < characters_in_template) {
          break;
        }
      }
    }
    if (should_close_braces) {
      filled_in_template = closeBraces(filled_in_template, template);
    }
    return {
      text: filled_in_template,
      template
    };
  };
}
function format$1(value, caret, formatter) {
  if (typeof formatter === "string") {
    formatter = template_formatter(formatter);
  }
  var _ref = formatter(value) || {}, text = _ref.text, template = _ref.template;
  if (text === void 0) {
    text = value;
  }
  if (template) {
    if (caret === void 0) {
      caret = text.length;
    } else {
      var index2 = 0;
      var found = false;
      var possibly_last_input_character_index = -1;
      while (index2 < text.length && index2 < template.length) {
        if (text[index2] !== template[index2]) {
          if (caret === 0) {
            found = true;
            caret = index2;
            break;
          }
          possibly_last_input_character_index = index2;
          caret--;
        }
        index2++;
      }
      if (!found) {
        caret = possibly_last_input_character_index + 1;
      }
    }
  }
  return {
    text,
    caret
  };
}
function isReadOnly(element) {
  return element.hasAttribute("readonly");
}
function getSelection(element) {
  if (element.selectionStart === element.selectionEnd) {
    return;
  }
  return {
    start: element.selectionStart,
    end: element.selectionEnd
  };
}
var Keys = {
  Backspace: 8,
  Delete: 46
};
function getOperation(event) {
  switch (event.keyCode) {
    case Keys.Backspace:
      return "Backspace";
    case Keys.Delete:
      return "Delete";
  }
}
function getCaretPosition$1(element) {
  return element.selectionStart;
}
function setCaretPosition(element, caret_position) {
  if (caret_position === void 0) {
    return;
  }
  if (isAndroid()) {
    setTimeout(function() {
      return element.setSelectionRange(caret_position, caret_position);
    }, 0);
  } else {
    element.setSelectionRange(caret_position, caret_position);
  }
}
function isAndroid() {
  if (typeof navigator !== "undefined") {
    return ANDROID_USER_AGENT_REG_EXP.test(navigator.userAgent);
  }
}
var ANDROID_USER_AGENT_REG_EXP = /Android/i;
function onChange(event, input, _parse, _format, on_change) {
  formatInputText(input, _parse, _format, void 0, on_change);
}
function onKeyDown(event, input, _parse, _format, on_change) {
  if (isReadOnly(input)) {
    return;
  }
  var operation = getOperation(event);
  switch (operation) {
    case "Delete":
    case "Backspace":
      event.preventDefault();
      var selection = getSelection(input);
      if (selection) {
        eraseSelection(input, selection);
        return formatInputText(input, _parse, _format, void 0, on_change);
      }
      return formatInputText(input, _parse, _format, operation, on_change);
  }
}
function eraseSelection(input, selection) {
  var text = input.value;
  text = text.slice(0, selection.start) + text.slice(selection.end);
  input.value = text;
  setCaretPosition(input, selection.start);
}
function formatInputText(input, _parse, _format, operation, on_change) {
  var _parse2 = parse$1(input.value, getCaretPosition$1(input), _parse), value = _parse2.value, caret = _parse2.caret;
  if (operation) {
    var newValueAndCaret = edit(value, caret, operation);
    value = newValueAndCaret.value;
    caret = newValueAndCaret.caret;
  }
  var formatted = format$1(value, caret, _format);
  var text = formatted.text;
  caret = formatted.caret;
  input.value = text;
  setCaretPosition(input, caret);
  on_change(value);
}
var _excluded$9 = ["value", "parse", "format", "inputComponent", "onChange", "onKeyDown"];
function _extends$8() {
  _extends$8 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$8.apply(this, arguments);
}
function _objectWithoutProperties$8(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$8(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$8(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function Input(_ref, ref) {
  var value = _ref.value, parse2 = _ref.parse, format2 = _ref.format, InputComponent = _ref.inputComponent, onChange$1 = _ref.onChange, onKeyDown$1 = _ref.onKeyDown, rest = _objectWithoutProperties$8(_ref, _excluded$9);
  var internalRef = reactExports.useRef();
  var setRef = reactExports.useCallback(function(instance) {
    internalRef.current = instance;
    if (ref) {
      if (typeof ref === "function") {
        ref(instance);
      } else {
        ref.current = instance;
      }
    }
  }, [ref]);
  var _onChange = reactExports.useCallback(function(event) {
    return onChange(event, internalRef.current, parse2, format2, onChange$1);
  }, [internalRef, parse2, format2, onChange$1]);
  var _onKeyDown = reactExports.useCallback(function(event) {
    if (onKeyDown$1) {
      onKeyDown$1(event);
    }
    if (event.defaultPrevented) {
      return;
    }
    return onKeyDown(event, internalRef.current, parse2, format2, onChange$1);
  }, [internalRef, parse2, format2, onChange$1, onKeyDown$1]);
  return /* @__PURE__ */ React.createElement(InputComponent, _extends$8({}, rest, {
    ref: setRef,
    value: format2(isEmptyValue(value) ? "" : value).text,
    onKeyDown: _onKeyDown,
    onChange: _onChange
  }));
}
Input = /* @__PURE__ */ React.forwardRef(Input);
Input.propTypes = {
  // Parses a single characher of `<input/>` text.
  parse: PropTypes.func.isRequired,
  // Formats `value` into `<input/>` text.
  format: PropTypes.func.isRequired,
  // Renders `<input/>` by default.
  inputComponent: PropTypes.elementType.isRequired,
  // `<input/>` `type` attribute.
  type: PropTypes.string.isRequired,
  // Is parsed from <input/> text.
  value: PropTypes.string,
  // This handler is called each time `<input/>` text is changed.
  onChange: PropTypes.func.isRequired,
  // Passthrough
  onKeyDown: PropTypes.func,
  onCut: PropTypes.func,
  onPaste: PropTypes.func
};
Input.defaultProps = {
  // Renders `<input/>` by default.
  inputComponent: "input",
  // `<input/>` `type` attribute.
  type: "text"
};
const Input$1 = Input;
function isEmptyValue(value) {
  return value === void 0 || value === null;
}
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$2(obj);
}
function _defineProperties$9(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$9(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$9(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$9(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result2);
  };
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf$1(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
    return _setPrototypeOf$1(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct$1()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a3 = [null];
      a3.push.apply(a3, args2);
      var Constructor = Function.bind.apply(Parent2, a3);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$1(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf$1(o3, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$1(o3, p2);
}
function _getPrototypeOf$1(o3) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$1(o3);
}
var ParseError = /* @__PURE__ */ function(_Error) {
  _inherits$1(ParseError2, _Error);
  var _super = _createSuper$1(ParseError2);
  function ParseError2(code) {
    var _this;
    _classCallCheck$9(this, ParseError2);
    _this = _super.call(this, code);
    Object.setPrototypeOf(_assertThisInitialized$1(_this), ParseError2.prototype);
    _this.name = _this.constructor.name;
    return _this;
  }
  return _createClass$9(ParseError2);
}(/* @__PURE__ */ _wrapNativeSuper(Error));
var MIN_LENGTH_FOR_NSN = 2;
var MAX_LENGTH_FOR_NSN = 17;
var MAX_LENGTH_COUNTRY_CODE = 3;
var VALID_DIGITS = "0-9０-９٠-٩۰-۹";
var DASHES = "-‐-―−ー－";
var SLASHES = "／/";
var DOTS = "．.";
var WHITESPACE = "  ­​⁠　";
var BRACKETS = "()（）［］\\[\\]";
var TILDES = "~⁓∼～";
var VALID_PUNCTUATION = "".concat(DASHES).concat(SLASHES).concat(DOTS).concat(WHITESPACE).concat(BRACKETS).concat(TILDES);
var PLUS_CHARS = "+＋";
function compare(a3, b3) {
  a3 = a3.split("-");
  b3 = b3.split("-");
  var pa = a3[0].split(".");
  var pb = b3[0].split(".");
  for (var i2 = 0; i2 < 3; i2++) {
    var na = Number(pa[i2]);
    var nb = Number(pb[i2]);
    if (na > nb)
      return 1;
    if (nb > na)
      return -1;
    if (!isNaN(na) && isNaN(nb))
      return 1;
    if (isNaN(na) && !isNaN(nb))
      return -1;
  }
  if (a3[1] && b3[1]) {
    return a3[1] > b3[1] ? 1 : a3[1] < b3[1] ? -1 : 0;
  }
  return !a3[1] && b3[1] ? 1 : a3[1] && !b3[1] ? -1 : 0;
}
var objectConstructor = {}.constructor;
function isObject(object) {
  return object !== void 0 && object !== null && object.constructor === objectConstructor;
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$8(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$8(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$8(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$8(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var V3 = "1.2.0";
var V4 = "1.7.35";
var DEFAULT_EXT_PREFIX = " ext. ";
var CALLING_CODE_REG_EXP = /^\d+$/;
var Metadata = /* @__PURE__ */ function() {
  function Metadata2(metadata2) {
    _classCallCheck$8(this, Metadata2);
    validateMetadata(metadata2);
    this.metadata = metadata2;
    setVersion.call(this, metadata2);
  }
  _createClass$8(Metadata2, [{
    key: "getCountries",
    value: function getCountries2() {
      return Object.keys(this.metadata.countries).filter(function(_3) {
        return _3 !== "001";
      });
    }
  }, {
    key: "getCountryMetadata",
    value: function getCountryMetadata(countryCode) {
      return this.metadata.countries[countryCode];
    }
  }, {
    key: "nonGeographic",
    value: function nonGeographic() {
      if (this.v1 || this.v2 || this.v3)
        return;
      return this.metadata.nonGeographic || this.metadata.nonGeographical;
    }
  }, {
    key: "hasCountry",
    value: function hasCountry(country) {
      return this.getCountryMetadata(country) !== void 0;
    }
  }, {
    key: "hasCallingCode",
    value: function hasCallingCode(callingCode) {
      if (this.getCountryCodesForCallingCode(callingCode)) {
        return true;
      }
      if (this.nonGeographic()) {
        if (this.nonGeographic()[callingCode]) {
          return true;
        }
      } else {
        var countryCodes = this.countryCallingCodes()[callingCode];
        if (countryCodes && countryCodes.length === 1 && countryCodes[0] === "001") {
          return true;
        }
      }
    }
  }, {
    key: "isNonGeographicCallingCode",
    value: function isNonGeographicCallingCode(callingCode) {
      if (this.nonGeographic()) {
        return this.nonGeographic()[callingCode] ? true : false;
      } else {
        return this.getCountryCodesForCallingCode(callingCode) ? false : true;
      }
    }
    // Deprecated.
  }, {
    key: "country",
    value: function country(countryCode) {
      return this.selectNumberingPlan(countryCode);
    }
  }, {
    key: "selectNumberingPlan",
    value: function selectNumberingPlan(countryCode, callingCode) {
      if (countryCode && CALLING_CODE_REG_EXP.test(countryCode)) {
        callingCode = countryCode;
        countryCode = null;
      }
      if (countryCode && countryCode !== "001") {
        if (!this.hasCountry(countryCode)) {
          throw new Error("Unknown country: ".concat(countryCode));
        }
        this.numberingPlan = new NumberingPlan(this.getCountryMetadata(countryCode), this);
      } else if (callingCode) {
        if (!this.hasCallingCode(callingCode)) {
          throw new Error("Unknown calling code: ".concat(callingCode));
        }
        this.numberingPlan = new NumberingPlan(this.getNumberingPlanMetadata(callingCode), this);
      } else {
        this.numberingPlan = void 0;
      }
      return this;
    }
  }, {
    key: "getCountryCodesForCallingCode",
    value: function getCountryCodesForCallingCode(callingCode) {
      var countryCodes = this.countryCallingCodes()[callingCode];
      if (countryCodes) {
        if (countryCodes.length === 1 && countryCodes[0].length === 3) {
          return;
        }
        return countryCodes;
      }
    }
  }, {
    key: "getCountryCodeForCallingCode",
    value: function getCountryCodeForCallingCode(callingCode) {
      var countryCodes = this.getCountryCodesForCallingCode(callingCode);
      if (countryCodes) {
        return countryCodes[0];
      }
    }
  }, {
    key: "getNumberingPlanMetadata",
    value: function getNumberingPlanMetadata(callingCode) {
      var countryCode = this.getCountryCodeForCallingCode(callingCode);
      if (countryCode) {
        return this.getCountryMetadata(countryCode);
      }
      if (this.nonGeographic()) {
        var metadata2 = this.nonGeographic()[callingCode];
        if (metadata2) {
          return metadata2;
        }
      } else {
        var countryCodes = this.countryCallingCodes()[callingCode];
        if (countryCodes && countryCodes.length === 1 && countryCodes[0] === "001") {
          return this.metadata.countries["001"];
        }
      }
    }
    // Deprecated.
  }, {
    key: "countryCallingCode",
    value: function countryCallingCode() {
      return this.numberingPlan.callingCode();
    }
    // Deprecated.
  }, {
    key: "IDDPrefix",
    value: function IDDPrefix() {
      return this.numberingPlan.IDDPrefix();
    }
    // Deprecated.
  }, {
    key: "defaultIDDPrefix",
    value: function defaultIDDPrefix() {
      return this.numberingPlan.defaultIDDPrefix();
    }
    // Deprecated.
  }, {
    key: "nationalNumberPattern",
    value: function nationalNumberPattern() {
      return this.numberingPlan.nationalNumberPattern();
    }
    // Deprecated.
  }, {
    key: "possibleLengths",
    value: function possibleLengths() {
      return this.numberingPlan.possibleLengths();
    }
    // Deprecated.
  }, {
    key: "formats",
    value: function formats() {
      return this.numberingPlan.formats();
    }
    // Deprecated.
  }, {
    key: "nationalPrefixForParsing",
    value: function nationalPrefixForParsing() {
      return this.numberingPlan.nationalPrefixForParsing();
    }
    // Deprecated.
  }, {
    key: "nationalPrefixTransformRule",
    value: function nationalPrefixTransformRule() {
      return this.numberingPlan.nationalPrefixTransformRule();
    }
    // Deprecated.
  }, {
    key: "leadingDigits",
    value: function leadingDigits() {
      return this.numberingPlan.leadingDigits();
    }
    // Deprecated.
  }, {
    key: "hasTypes",
    value: function hasTypes() {
      return this.numberingPlan.hasTypes();
    }
    // Deprecated.
  }, {
    key: "type",
    value: function type(_type) {
      return this.numberingPlan.type(_type);
    }
    // Deprecated.
  }, {
    key: "ext",
    value: function ext() {
      return this.numberingPlan.ext();
    }
  }, {
    key: "countryCallingCodes",
    value: function countryCallingCodes() {
      if (this.v1)
        return this.metadata.country_phone_code_to_countries;
      return this.metadata.country_calling_codes;
    }
    // Deprecated.
  }, {
    key: "chooseCountryByCountryCallingCode",
    value: function chooseCountryByCountryCallingCode(callingCode) {
      return this.selectNumberingPlan(callingCode);
    }
  }, {
    key: "hasSelectedNumberingPlan",
    value: function hasSelectedNumberingPlan() {
      return this.numberingPlan !== void 0;
    }
  }]);
  return Metadata2;
}();
var NumberingPlan = /* @__PURE__ */ function() {
  function NumberingPlan2(metadata2, globalMetadataObject) {
    _classCallCheck$8(this, NumberingPlan2);
    this.globalMetadataObject = globalMetadataObject;
    this.metadata = metadata2;
    setVersion.call(this, globalMetadataObject.metadata);
  }
  _createClass$8(NumberingPlan2, [{
    key: "callingCode",
    value: function callingCode() {
      return this.metadata[0];
    }
    // Formatting information for regions which share
    // a country calling code is contained by only one region
    // for performance reasons. For example, for NANPA region
    // ("North American Numbering Plan Administration",
    //  which includes USA, Canada, Cayman Islands, Bahamas, etc)
    // it will be contained in the metadata for `US`.
  }, {
    key: "getDefaultCountryMetadataForRegion",
    value: function getDefaultCountryMetadataForRegion() {
      return this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode());
    }
    // Is always present.
  }, {
    key: "IDDPrefix",
    value: function IDDPrefix() {
      if (this.v1 || this.v2)
        return;
      return this.metadata[1];
    }
    // Is only present when a country supports multiple IDD prefixes.
  }, {
    key: "defaultIDDPrefix",
    value: function defaultIDDPrefix() {
      if (this.v1 || this.v2)
        return;
      return this.metadata[12];
    }
  }, {
    key: "nationalNumberPattern",
    value: function nationalNumberPattern() {
      if (this.v1 || this.v2)
        return this.metadata[1];
      return this.metadata[2];
    }
    // "possible length" data is always present in Google's metadata.
  }, {
    key: "possibleLengths",
    value: function possibleLengths() {
      if (this.v1)
        return;
      return this.metadata[this.v2 ? 2 : 3];
    }
  }, {
    key: "_getFormats",
    value: function _getFormats(metadata2) {
      return metadata2[this.v1 ? 2 : this.v2 ? 3 : 4];
    }
    // For countries of the same region (e.g. NANPA)
    // formats are all stored in the "main" country for that region.
    // E.g. "RU" and "KZ", "US" and "CA".
  }, {
    key: "formats",
    value: function formats() {
      var _this = this;
      var formats2 = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || [];
      return formats2.map(function(_3) {
        return new Format(_3, _this);
      });
    }
  }, {
    key: "nationalPrefix",
    value: function nationalPrefix() {
      return this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5];
    }
  }, {
    key: "_getNationalPrefixFormattingRule",
    value: function _getNationalPrefixFormattingRule(metadata2) {
      return metadata2[this.v1 ? 4 : this.v2 ? 5 : 6];
    }
    // For countries of the same region (e.g. NANPA)
    // national prefix formatting rule is stored in the "main" country for that region.
    // E.g. "RU" and "KZ", "US" and "CA".
  }, {
    key: "nationalPrefixFormattingRule",
    value: function nationalPrefixFormattingRule() {
      return this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion());
    }
  }, {
    key: "_nationalPrefixForParsing",
    value: function _nationalPrefixForParsing() {
      return this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7];
    }
  }, {
    key: "nationalPrefixForParsing",
    value: function nationalPrefixForParsing() {
      return this._nationalPrefixForParsing() || this.nationalPrefix();
    }
  }, {
    key: "nationalPrefixTransformRule",
    value: function nationalPrefixTransformRule() {
      return this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8];
    }
  }, {
    key: "_getNationalPrefixIsOptionalWhenFormatting",
    value: function _getNationalPrefixIsOptionalWhenFormatting() {
      return !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9];
    }
    // For countries of the same region (e.g. NANPA)
    // "national prefix is optional when formatting" flag is
    // stored in the "main" country for that region.
    // E.g. "RU" and "KZ", "US" and "CA".
  }, {
    key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
    value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
      return this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) || this._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion());
    }
  }, {
    key: "leadingDigits",
    value: function leadingDigits() {
      return this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10];
    }
  }, {
    key: "types",
    value: function types() {
      return this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11];
    }
  }, {
    key: "hasTypes",
    value: function hasTypes() {
      if (this.types() && this.types().length === 0) {
        return false;
      }
      return !!this.types();
    }
  }, {
    key: "type",
    value: function type(_type2) {
      if (this.hasTypes() && getType(this.types(), _type2)) {
        return new Type(getType(this.types(), _type2), this);
      }
    }
  }, {
    key: "ext",
    value: function ext() {
      if (this.v1 || this.v2)
        return DEFAULT_EXT_PREFIX;
      return this.metadata[13] || DEFAULT_EXT_PREFIX;
    }
  }]);
  return NumberingPlan2;
}();
var Format = /* @__PURE__ */ function() {
  function Format2(format2, metadata2) {
    _classCallCheck$8(this, Format2);
    this._format = format2;
    this.metadata = metadata2;
  }
  _createClass$8(Format2, [{
    key: "pattern",
    value: function pattern() {
      return this._format[0];
    }
  }, {
    key: "format",
    value: function format2() {
      return this._format[1];
    }
  }, {
    key: "leadingDigitsPatterns",
    value: function leadingDigitsPatterns() {
      return this._format[2] || [];
    }
  }, {
    key: "nationalPrefixFormattingRule",
    value: function nationalPrefixFormattingRule() {
      return this._format[3] || this.metadata.nationalPrefixFormattingRule();
    }
  }, {
    key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
    value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
      return !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
    }
  }, {
    key: "nationalPrefixIsMandatoryWhenFormattingInNationalFormat",
    value: function nationalPrefixIsMandatoryWhenFormattingInNationalFormat() {
      return this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
    }
    // Checks whether national prefix formatting rule contains national prefix.
  }, {
    key: "usesNationalPrefix",
    value: function usesNationalPrefix() {
      return this.nationalPrefixFormattingRule() && // Check that national prefix formatting rule is not a "dummy" one.
      !FIRST_GROUP_ONLY_PREFIX_PATTERN.test(this.nationalPrefixFormattingRule()) ? true : false;
    }
  }, {
    key: "internationalFormat",
    value: function internationalFormat() {
      return this._format[5] || this.format();
    }
  }]);
  return Format2;
}();
var FIRST_GROUP_ONLY_PREFIX_PATTERN = /^\(?\$1\)?$/;
var Type = /* @__PURE__ */ function() {
  function Type2(type, metadata2) {
    _classCallCheck$8(this, Type2);
    this.type = type;
    this.metadata = metadata2;
  }
  _createClass$8(Type2, [{
    key: "pattern",
    value: function pattern() {
      if (this.metadata.v1)
        return this.type;
      return this.type[0];
    }
  }, {
    key: "possibleLengths",
    value: function possibleLengths() {
      if (this.metadata.v1)
        return;
      return this.type[1] || this.metadata.possibleLengths();
    }
  }]);
  return Type2;
}();
function getType(types, type) {
  switch (type) {
    case "FIXED_LINE":
      return types[0];
    case "MOBILE":
      return types[1];
    case "TOLL_FREE":
      return types[2];
    case "PREMIUM_RATE":
      return types[3];
    case "PERSONAL_NUMBER":
      return types[4];
    case "VOICEMAIL":
      return types[5];
    case "UAN":
      return types[6];
    case "PAGER":
      return types[7];
    case "VOIP":
      return types[8];
    case "SHARED_COST":
      return types[9];
  }
}
function validateMetadata(metadata2) {
  if (!metadata2) {
    throw new Error("[libphonenumber-js] `metadata` argument not passed. Check your arguments.");
  }
  if (!isObject(metadata2) || !isObject(metadata2.countries)) {
    throw new Error("[libphonenumber-js] `metadata` argument was passed but it's not a valid metadata. Must be an object having `.countries` child object property. Got ".concat(isObject(metadata2) ? "an object of shape: { " + Object.keys(metadata2).join(", ") + " }" : "a " + typeOf(metadata2) + ": " + metadata2, "."));
  }
}
var typeOf = function typeOf2(_3) {
  return _typeof$1(_3);
};
function getCountryCallingCode(country, metadata2) {
  metadata2 = new Metadata(metadata2);
  if (metadata2.hasCountry(country)) {
    return metadata2.country(country).countryCallingCode();
  }
  throw new Error("Unknown country: ".concat(country));
}
function isSupportedCountry(country, metadata2) {
  return metadata2.countries.hasOwnProperty(country);
}
function setVersion(metadata2) {
  var version = metadata2.version;
  if (typeof version === "number") {
    this.v1 = version === 1;
    this.v2 = version === 2;
    this.v3 = version === 3;
    this.v4 = version === 4;
  } else {
    if (!version) {
      this.v1 = true;
    } else if (compare(version, V3) === -1) {
      this.v2 = true;
    } else if (compare(version, V4) === -1) {
      this.v3 = true;
    } else {
      this.v4 = true;
    }
  }
}
var RFC3966_EXTN_PREFIX = ";ext=";
var getExtensionDigitsPattern = function getExtensionDigitsPattern2(maxLength) {
  return "([".concat(VALID_DIGITS, "]{1,").concat(maxLength, "})");
};
function createExtensionPattern(purpose) {
  var extLimitAfterExplicitLabel = "20";
  var extLimitAfterLikelyLabel = "15";
  var extLimitAfterAmbiguousChar = "9";
  var extLimitWhenNotSure = "6";
  var possibleSeparatorsBetweenNumberAndExtLabel = "[  \\t,]*";
  var possibleCharsAfterExtLabel = "[:\\.．]?[  \\t,-]*";
  var optionalExtnSuffix = "#?";
  var explicitExtLabels = "(?:e?xt(?:ensi(?:ó?|ó))?n?|ｅ?ｘｔｎ?|доб|anexo)";
  var ambiguousExtLabels = "(?:[xｘ#＃~～]|int|ｉｎｔ)";
  var ambiguousSeparator = "[- ]+";
  var possibleSeparatorsNumberExtLabelNoComma = "[  \\t]*";
  var autoDiallingAndExtLabelsFound = "(?:,{2}|;)";
  var rfcExtn = RFC3966_EXTN_PREFIX + getExtensionDigitsPattern(extLimitAfterExplicitLabel);
  var explicitExtn = possibleSeparatorsBetweenNumberAndExtLabel + explicitExtLabels + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterExplicitLabel) + optionalExtnSuffix;
  var ambiguousExtn = possibleSeparatorsBetweenNumberAndExtLabel + ambiguousExtLabels + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterAmbiguousChar) + optionalExtnSuffix;
  var americanStyleExtnWithSuffix = ambiguousSeparator + getExtensionDigitsPattern(extLimitWhenNotSure) + "#";
  var autoDiallingExtn = possibleSeparatorsNumberExtLabelNoComma + autoDiallingAndExtLabelsFound + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterLikelyLabel) + optionalExtnSuffix;
  var onlyCommasExtn = possibleSeparatorsNumberExtLabelNoComma + "(?:,)+" + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterAmbiguousChar) + optionalExtnSuffix;
  return rfcExtn + "|" + explicitExtn + "|" + ambiguousExtn + "|" + americanStyleExtnWithSuffix + "|" + autoDiallingExtn + "|" + onlyCommasExtn;
}
var MIN_LENGTH_PHONE_NUMBER_PATTERN = "[" + VALID_DIGITS + "]{" + MIN_LENGTH_FOR_NSN + "}";
var VALID_PHONE_NUMBER = "[" + PLUS_CHARS + "]{0,1}(?:[" + VALID_PUNCTUATION + "]*[" + VALID_DIGITS + "]){3,}[" + VALID_PUNCTUATION + VALID_DIGITS + "]*";
var VALID_PHONE_NUMBER_START_REG_EXP = new RegExp("^[" + PLUS_CHARS + "]{0,1}(?:[" + VALID_PUNCTUATION + "]*[" + VALID_DIGITS + "]){1,2}$", "i");
var VALID_PHONE_NUMBER_WITH_EXTENSION = VALID_PHONE_NUMBER + // Phone number extensions
"(?:" + createExtensionPattern() + ")?";
var VALID_PHONE_NUMBER_PATTERN = new RegExp(
  // Either a short two-digit-only phone number
  "^" + MIN_LENGTH_PHONE_NUMBER_PATTERN + "$|^" + VALID_PHONE_NUMBER_WITH_EXTENSION + "$",
  "i"
);
function isViablePhoneNumber(number) {
  return number.length >= MIN_LENGTH_FOR_NSN && VALID_PHONE_NUMBER_PATTERN.test(number);
}
function isViablePhoneNumberStart(number) {
  return VALID_PHONE_NUMBER_START_REG_EXP.test(number);
}
var EXTN_PATTERN = new RegExp("(?:" + createExtensionPattern() + ")$", "i");
function extractExtension(number) {
  var start = number.search(EXTN_PATTERN);
  if (start < 0) {
    return {};
  }
  var numberWithoutExtension = number.slice(0, start);
  var matches = number.match(EXTN_PATTERN);
  var i2 = 1;
  while (i2 < matches.length) {
    if (matches[i2]) {
      return {
        number: numberWithoutExtension,
        ext: matches[i2]
      };
    }
    i2++;
  }
}
function _createForOfIteratorHelperLoose$b(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2)
    return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray$e(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
    if (it2)
      o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length)
        return { done: true };
      return { done: false, value: o3[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$e(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$e(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$e(o3, minLen);
}
function _arrayLikeToArray$e(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
var DIGITS = {
  "0": "0",
  "1": "1",
  "2": "2",
  "3": "3",
  "4": "4",
  "5": "5",
  "6": "6",
  "7": "7",
  "8": "8",
  "9": "9",
  "０": "0",
  // Fullwidth digit 0
  "１": "1",
  // Fullwidth digit 1
  "２": "2",
  // Fullwidth digit 2
  "３": "3",
  // Fullwidth digit 3
  "４": "4",
  // Fullwidth digit 4
  "５": "5",
  // Fullwidth digit 5
  "６": "6",
  // Fullwidth digit 6
  "７": "7",
  // Fullwidth digit 7
  "８": "8",
  // Fullwidth digit 8
  "９": "9",
  // Fullwidth digit 9
  "٠": "0",
  // Arabic-indic digit 0
  "١": "1",
  // Arabic-indic digit 1
  "٢": "2",
  // Arabic-indic digit 2
  "٣": "3",
  // Arabic-indic digit 3
  "٤": "4",
  // Arabic-indic digit 4
  "٥": "5",
  // Arabic-indic digit 5
  "٦": "6",
  // Arabic-indic digit 6
  "٧": "7",
  // Arabic-indic digit 7
  "٨": "8",
  // Arabic-indic digit 8
  "٩": "9",
  // Arabic-indic digit 9
  "۰": "0",
  // Eastern-Arabic digit 0
  "۱": "1",
  // Eastern-Arabic digit 1
  "۲": "2",
  // Eastern-Arabic digit 2
  "۳": "3",
  // Eastern-Arabic digit 3
  "۴": "4",
  // Eastern-Arabic digit 4
  "۵": "5",
  // Eastern-Arabic digit 5
  "۶": "6",
  // Eastern-Arabic digit 6
  "۷": "7",
  // Eastern-Arabic digit 7
  "۸": "8",
  // Eastern-Arabic digit 8
  "۹": "9"
  // Eastern-Arabic digit 9
};
function parseDigit(character) {
  return DIGITS[character];
}
function parseDigits(string) {
  var result2 = "";
  for (var _iterator = _createForOfIteratorHelperLoose$b(string.split("")), _step; !(_step = _iterator()).done; ) {
    var character = _step.value;
    var digit = parseDigit(character);
    if (digit) {
      result2 += digit;
    }
  }
  return result2;
}
function _createForOfIteratorHelperLoose$a(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2)
    return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray$d(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
    if (it2)
      o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length)
        return { done: true };
      return { done: false, value: o3[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$d(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$d(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$d(o3, minLen);
}
function _arrayLikeToArray$d(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function parseIncompletePhoneNumber(string) {
  var result2 = "";
  for (var _iterator = _createForOfIteratorHelperLoose$a(string.split("")), _step; !(_step = _iterator()).done; ) {
    var character = _step.value;
    result2 += parsePhoneNumberCharacter(character, result2) || "";
  }
  return result2;
}
function parsePhoneNumberCharacter(character, prevParsedCharacters, emitEvent) {
  if (character === "+") {
    if (prevParsedCharacters) {
      if (typeof emitEvent === "function") {
        emitEvent("end");
      }
      return;
    }
    return "+";
  }
  return parseDigit(character);
}
function _createForOfIteratorHelperLoose$9(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2)
    return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray$c(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
    if (it2)
      o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length)
        return { done: true };
      return { done: false, value: o3[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$c(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$c(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$c(o3, minLen);
}
function _arrayLikeToArray$c(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function mergeArrays(a3, b3) {
  var merged = a3.slice();
  for (var _iterator = _createForOfIteratorHelperLoose$9(b3), _step; !(_step = _iterator()).done; ) {
    var element = _step.value;
    if (a3.indexOf(element) < 0) {
      merged.push(element);
    }
  }
  return merged.sort(function(a4, b4) {
    return a4 - b4;
  });
}
function checkNumberLength(nationalNumber, metadata2) {
  return checkNumberLengthForType(nationalNumber, void 0, metadata2);
}
function checkNumberLengthForType(nationalNumber, type, metadata2) {
  var type_info = metadata2.type(type);
  var possible_lengths = type_info && type_info.possibleLengths() || metadata2.possibleLengths();
  if (!possible_lengths) {
    return "IS_POSSIBLE";
  }
  if (type === "FIXED_LINE_OR_MOBILE") {
    if (!metadata2.type("FIXED_LINE")) {
      return checkNumberLengthForType(nationalNumber, "MOBILE", metadata2);
    }
    var mobile_type = metadata2.type("MOBILE");
    if (mobile_type) {
      possible_lengths = mergeArrays(possible_lengths, mobile_type.possibleLengths());
    }
  } else if (type && !type_info) {
    return "INVALID_LENGTH";
  }
  var actual_length = nationalNumber.length;
  var minimum_length = possible_lengths[0];
  if (minimum_length === actual_length) {
    return "IS_POSSIBLE";
  }
  if (minimum_length > actual_length) {
    return "TOO_SHORT";
  }
  if (possible_lengths[possible_lengths.length - 1] < actual_length) {
    return "TOO_LONG";
  }
  return possible_lengths.indexOf(actual_length, 1) >= 0 ? "IS_POSSIBLE" : "INVALID_LENGTH";
}
function isPossiblePhoneNumber(input, options, metadata2) {
  if (options === void 0) {
    options = {};
  }
  metadata2 = new Metadata(metadata2);
  if (options.v2) {
    if (!input.countryCallingCode) {
      throw new Error("Invalid phone number object passed");
    }
    metadata2.selectNumberingPlan(input.countryCallingCode);
  } else {
    if (!input.phone) {
      return false;
    }
    if (input.country) {
      if (!metadata2.hasCountry(input.country)) {
        throw new Error("Unknown country: ".concat(input.country));
      }
      metadata2.country(input.country);
    } else {
      if (!input.countryCallingCode) {
        throw new Error("Invalid phone number object passed");
      }
      metadata2.selectNumberingPlan(input.countryCallingCode);
    }
  }
  if (metadata2.possibleLengths()) {
    return isPossibleNumber(input.phone || input.nationalNumber, metadata2);
  } else {
    if (input.countryCallingCode && metadata2.isNonGeographicCallingCode(input.countryCallingCode)) {
      return true;
    } else {
      throw new Error('Missing "possibleLengths" in metadata. Perhaps the metadata has been generated before v1.0.18.');
    }
  }
}
function isPossibleNumber(nationalNumber, metadata2) {
  switch (checkNumberLength(nationalNumber, metadata2)) {
    case "IS_POSSIBLE":
      return true;
    default:
      return false;
  }
}
function matchesEntirely(text, regular_expression) {
  text = text || "";
  return new RegExp("^(?:" + regular_expression + ")$").test(text);
}
function _createForOfIteratorHelperLoose$8(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2)
    return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray$b(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
    if (it2)
      o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length)
        return { done: true };
      return { done: false, value: o3[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$b(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$b(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$b(o3, minLen);
}
function _arrayLikeToArray$b(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
var NON_FIXED_LINE_PHONE_TYPES = ["MOBILE", "PREMIUM_RATE", "TOLL_FREE", "SHARED_COST", "VOIP", "PERSONAL_NUMBER", "PAGER", "UAN", "VOICEMAIL"];
function getNumberType(input, options, metadata2) {
  options = options || {};
  if (!input.country && !input.countryCallingCode) {
    return;
  }
  metadata2 = new Metadata(metadata2);
  metadata2.selectNumberingPlan(input.country, input.countryCallingCode);
  var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
  if (!matchesEntirely(nationalNumber, metadata2.nationalNumberPattern())) {
    return;
  }
  if (isNumberTypeEqualTo(nationalNumber, "FIXED_LINE", metadata2)) {
    if (metadata2.type("MOBILE") && metadata2.type("MOBILE").pattern() === "") {
      return "FIXED_LINE_OR_MOBILE";
    }
    if (!metadata2.type("MOBILE")) {
      return "FIXED_LINE_OR_MOBILE";
    }
    if (isNumberTypeEqualTo(nationalNumber, "MOBILE", metadata2)) {
      return "FIXED_LINE_OR_MOBILE";
    }
    return "FIXED_LINE";
  }
  for (var _iterator = _createForOfIteratorHelperLoose$8(NON_FIXED_LINE_PHONE_TYPES), _step; !(_step = _iterator()).done; ) {
    var type = _step.value;
    if (isNumberTypeEqualTo(nationalNumber, type, metadata2)) {
      return type;
    }
  }
}
function isNumberTypeEqualTo(nationalNumber, type, metadata2) {
  type = metadata2.type(type);
  if (!type || !type.pattern()) {
    return false;
  }
  if (type.possibleLengths() && type.possibleLengths().indexOf(nationalNumber.length) < 0) {
    return false;
  }
  return matchesEntirely(nationalNumber, type.pattern());
}
function isValidNumber(input, options, metadata2) {
  options = options || {};
  metadata2 = new Metadata(metadata2);
  metadata2.selectNumberingPlan(input.country, input.countryCallingCode);
  if (metadata2.hasTypes()) {
    return getNumberType(input, options, metadata2.metadata) !== void 0;
  }
  var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
  return matchesEntirely(nationalNumber, metadata2.nationalNumberPattern());
}
function getPossibleCountriesForNumber(callingCode, nationalNumber, metadata2) {
  var _metadata = new Metadata(metadata2);
  var possibleCountries = _metadata.getCountryCodesForCallingCode(callingCode);
  if (!possibleCountries) {
    return [];
  }
  return possibleCountries.filter(function(country) {
    return couldNationalNumberBelongToCountry(nationalNumber, country, metadata2);
  });
}
function couldNationalNumberBelongToCountry(nationalNumber, country, metadata2) {
  var _metadata = new Metadata(metadata2);
  _metadata.selectNumberingPlan(country);
  if (_metadata.numberingPlan.possibleLengths().indexOf(nationalNumber.length) >= 0) {
    return true;
  }
  return false;
}
function applyInternationalSeparatorStyle(formattedNumber) {
  return formattedNumber.replace(new RegExp("[".concat(VALID_PUNCTUATION, "]+"), "g"), " ").trim();
}
var FIRST_GROUP_PATTERN = /(\$\d)/;
function formatNationalNumberUsingFormat(number, format2, _ref) {
  var useInternationalFormat = _ref.useInternationalFormat, withNationalPrefix = _ref.withNationalPrefix;
  _ref.carrierCode;
  _ref.metadata;
  var formattedNumber = number.replace(new RegExp(format2.pattern()), useInternationalFormat ? format2.internationalFormat() : (
    // This library doesn't use `domestic_carrier_code_formatting_rule`,
    // because that one is only used when formatting phone numbers
    // for dialing from a mobile phone, and this is not a dialing library.
    // carrierCode && format.domesticCarrierCodeFormattingRule()
    // 	// First, replace the $CC in the formatting rule with the desired carrier code.
    // 	// Then, replace the $FG in the formatting rule with the first group
    // 	// and the carrier code combined in the appropriate way.
    // 	? format.format().replace(FIRST_GROUP_PATTERN, format.domesticCarrierCodeFormattingRule().replace('$CC', carrierCode))
    // 	: (
    // 		withNationalPrefix && format.nationalPrefixFormattingRule()
    // 			? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())
    // 			: format.format()
    // 	)
    withNationalPrefix && format2.nationalPrefixFormattingRule() ? format2.format().replace(FIRST_GROUP_PATTERN, format2.nationalPrefixFormattingRule()) : format2.format()
  ));
  if (useInternationalFormat) {
    return applyInternationalSeparatorStyle(formattedNumber);
  }
  return formattedNumber;
}
var SINGLE_IDD_PREFIX_REG_EXP = /^[\d]+(?:[~\u2053\u223C\uFF5E][\d]+)?$/;
function getIddPrefix(country, callingCode, metadata2) {
  var countryMetadata = new Metadata(metadata2);
  countryMetadata.selectNumberingPlan(country, callingCode);
  if (countryMetadata.defaultIDDPrefix()) {
    return countryMetadata.defaultIDDPrefix();
  }
  if (SINGLE_IDD_PREFIX_REG_EXP.test(countryMetadata.IDDPrefix())) {
    return countryMetadata.IDDPrefix();
  }
}
function formatRFC3966(_ref) {
  var number = _ref.number, ext = _ref.ext;
  if (!number) {
    return "";
  }
  if (number[0] !== "+") {
    throw new Error('"formatRFC3966()" expects "number" to be in E.164 format.');
  }
  return "tel:".concat(number).concat(ext ? ";ext=" + ext : "");
}
function _createForOfIteratorHelperLoose$7(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2)
    return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray$a(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
    if (it2)
      o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length)
        return { done: true };
      return { done: false, value: o3[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$a(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$a(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$a(o3, minLen);
}
function _arrayLikeToArray$a(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$6(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$6(Object(source), true).forEach(function(key) {
      _defineProperty$7(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DEFAULT_OPTIONS = {
  formatExtension: function formatExtension(formattedNumber, extension, metadata2) {
    return "".concat(formattedNumber).concat(metadata2.ext()).concat(extension);
  }
};
function formatNumber(input, format2, options, metadata2) {
  if (options) {
    options = _objectSpread$6(_objectSpread$6({}, DEFAULT_OPTIONS), options);
  } else {
    options = DEFAULT_OPTIONS;
  }
  metadata2 = new Metadata(metadata2);
  if (input.country && input.country !== "001") {
    if (!metadata2.hasCountry(input.country)) {
      throw new Error("Unknown country: ".concat(input.country));
    }
    metadata2.country(input.country);
  } else if (input.countryCallingCode) {
    metadata2.selectNumberingPlan(input.countryCallingCode);
  } else
    return input.phone || "";
  var countryCallingCode = metadata2.countryCallingCode();
  var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
  var number;
  switch (format2) {
    case "NATIONAL":
      if (!nationalNumber) {
        return "";
      }
      number = formatNationalNumber$1(nationalNumber, input.carrierCode, "NATIONAL", metadata2, options);
      return addExtension(number, input.ext, metadata2, options.formatExtension);
    case "INTERNATIONAL":
      if (!nationalNumber) {
        return "+".concat(countryCallingCode);
      }
      number = formatNationalNumber$1(nationalNumber, null, "INTERNATIONAL", metadata2, options);
      number = "+".concat(countryCallingCode, " ").concat(number);
      return addExtension(number, input.ext, metadata2, options.formatExtension);
    case "E.164":
      return "+".concat(countryCallingCode).concat(nationalNumber);
    case "RFC3966":
      return formatRFC3966({
        number: "+".concat(countryCallingCode).concat(nationalNumber),
        ext: input.ext
      });
    case "IDD":
      if (!options.fromCountry) {
        return;
      }
      var formattedNumber = formatIDD(nationalNumber, input.carrierCode, countryCallingCode, options.fromCountry, metadata2);
      return addExtension(formattedNumber, input.ext, metadata2, options.formatExtension);
    default:
      throw new Error('Unknown "format" argument passed to "formatNumber()": "'.concat(format2, '"'));
  }
}
function formatNationalNumber$1(number, carrierCode, formatAs, metadata2, options) {
  var format2 = chooseFormatForNumber(metadata2.formats(), number);
  if (!format2) {
    return number;
  }
  return formatNationalNumberUsingFormat(number, format2, {
    useInternationalFormat: formatAs === "INTERNATIONAL",
    withNationalPrefix: format2.nationalPrefixIsOptionalWhenFormattingInNationalFormat() && options && options.nationalPrefix === false ? false : true,
    carrierCode,
    metadata: metadata2
  });
}
function chooseFormatForNumber(availableFormats, nationalNnumber) {
  for (var _iterator = _createForOfIteratorHelperLoose$7(availableFormats), _step; !(_step = _iterator()).done; ) {
    var format2 = _step.value;
    if (format2.leadingDigitsPatterns().length > 0) {
      var lastLeadingDigitsPattern = format2.leadingDigitsPatterns()[format2.leadingDigitsPatterns().length - 1];
      if (nationalNnumber.search(lastLeadingDigitsPattern) !== 0) {
        continue;
      }
    }
    if (matchesEntirely(nationalNnumber, format2.pattern())) {
      return format2;
    }
  }
}
function addExtension(formattedNumber, ext, metadata2, formatExtension2) {
  return ext ? formatExtension2(formattedNumber, ext, metadata2) : formattedNumber;
}
function formatIDD(nationalNumber, carrierCode, countryCallingCode, fromCountry, metadata2) {
  var fromCountryCallingCode = getCountryCallingCode(fromCountry, metadata2.metadata);
  if (fromCountryCallingCode === countryCallingCode) {
    var formattedNumber = formatNationalNumber$1(nationalNumber, carrierCode, "NATIONAL", metadata2);
    if (countryCallingCode === "1") {
      return countryCallingCode + " " + formattedNumber;
    }
    return formattedNumber;
  }
  var iddPrefix = getIddPrefix(fromCountry, void 0, metadata2.metadata);
  if (iddPrefix) {
    return "".concat(iddPrefix, " ").concat(countryCallingCode, " ").concat(formatNationalNumber$1(nationalNumber, null, "INTERNATIONAL", metadata2));
  }
}
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$5(Object(source), true).forEach(function(key) {
      _defineProperty$6(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$7(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$7(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$7(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$7(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var PhoneNumber = /* @__PURE__ */ function() {
  function PhoneNumber2(countryOrCountryCallingCode, nationalNumber, metadata2) {
    _classCallCheck$7(this, PhoneNumber2);
    if (!countryOrCountryCallingCode) {
      throw new TypeError("`country` or `countryCallingCode` not passed");
    }
    if (!nationalNumber) {
      throw new TypeError("`nationalNumber` not passed");
    }
    if (!metadata2) {
      throw new TypeError("`metadata` not passed");
    }
    var _getCountryAndCountry = getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadata2), country = _getCountryAndCountry.country, countryCallingCode = _getCountryAndCountry.countryCallingCode;
    this.country = country;
    this.countryCallingCode = countryCallingCode;
    this.nationalNumber = nationalNumber;
    this.number = "+" + this.countryCallingCode + this.nationalNumber;
    this.getMetadata = function() {
      return metadata2;
    };
  }
  _createClass$7(PhoneNumber2, [{
    key: "setExt",
    value: function setExt(ext) {
      this.ext = ext;
    }
  }, {
    key: "getPossibleCountries",
    value: function getPossibleCountries() {
      if (this.country) {
        return [this.country];
      }
      return getPossibleCountriesForNumber(this.countryCallingCode, this.nationalNumber, this.getMetadata());
    }
  }, {
    key: "isPossible",
    value: function isPossible() {
      return isPossiblePhoneNumber(this, {
        v2: true
      }, this.getMetadata());
    }
  }, {
    key: "isValid",
    value: function isValid() {
      return isValidNumber(this, {
        v2: true
      }, this.getMetadata());
    }
  }, {
    key: "isNonGeographic",
    value: function isNonGeographic() {
      var metadata2 = new Metadata(this.getMetadata());
      return metadata2.isNonGeographicCallingCode(this.countryCallingCode);
    }
  }, {
    key: "isEqual",
    value: function isEqual(phoneNumber) {
      return this.number === phoneNumber.number && this.ext === phoneNumber.ext;
    }
    // This function was originally meant to be an equivalent for `validatePhoneNumberLength()`,
    // but later it was found out that it doesn't include the possible `TOO_SHORT` result
    // returned from `parsePhoneNumberWithError()` in the original `validatePhoneNumberLength()`,
    // so eventually I simply commented out this method from the `PhoneNumber` class
    // and just left the `validatePhoneNumberLength()` function, even though that one would require
    // and additional step to also validate the actual country / calling code of the phone number.
    // validateLength() {
    // 	const metadata = new Metadata(this.getMetadata())
    // 	metadata.selectNumberingPlan(this.countryCallingCode)
    // 	const result = checkNumberLength(this.nationalNumber, metadata)
    // 	if (result !== 'IS_POSSIBLE') {
    // 		return result
    // 	}
    // }
  }, {
    key: "getType",
    value: function getType2() {
      return getNumberType(this, {
        v2: true
      }, this.getMetadata());
    }
  }, {
    key: "format",
    value: function format2(_format, options) {
      return formatNumber(this, _format, options ? _objectSpread$5(_objectSpread$5({}, options), {}, {
        v2: true
      }) : {
        v2: true
      }, this.getMetadata());
    }
  }, {
    key: "formatNational",
    value: function formatNational(options) {
      return this.format("NATIONAL", options);
    }
  }, {
    key: "formatInternational",
    value: function formatInternational(options) {
      return this.format("INTERNATIONAL", options);
    }
  }, {
    key: "getURI",
    value: function getURI(options) {
      return this.format("RFC3966", options);
    }
  }]);
  return PhoneNumber2;
}();
var isCountryCode = function isCountryCode2(value) {
  return /^[A-Z]{2}$/.test(value);
};
function getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadataJson) {
  var country;
  var countryCallingCode;
  var metadata2 = new Metadata(metadataJson);
  if (isCountryCode(countryOrCountryCallingCode)) {
    country = countryOrCountryCallingCode;
    metadata2.selectNumberingPlan(country);
    countryCallingCode = metadata2.countryCallingCode();
  } else {
    countryCallingCode = countryOrCountryCallingCode;
  }
  return {
    country,
    countryCallingCode
  };
}
var CAPTURING_DIGIT_PATTERN = new RegExp("([" + VALID_DIGITS + "])");
function stripIddPrefix(number, country, callingCode, metadata2) {
  if (!country) {
    return;
  }
  var countryMetadata = new Metadata(metadata2);
  countryMetadata.selectNumberingPlan(country, callingCode);
  var IDDPrefixPattern = new RegExp(countryMetadata.IDDPrefix());
  if (number.search(IDDPrefixPattern) !== 0) {
    return;
  }
  number = number.slice(number.match(IDDPrefixPattern)[0].length);
  var matchedGroups = number.match(CAPTURING_DIGIT_PATTERN);
  if (matchedGroups && matchedGroups[1] != null && matchedGroups[1].length > 0) {
    if (matchedGroups[1] === "0") {
      return;
    }
  }
  return number;
}
function extractNationalNumberFromPossiblyIncompleteNumber(number, metadata2) {
  if (number && metadata2.numberingPlan.nationalPrefixForParsing()) {
    var prefixPattern = new RegExp("^(?:" + metadata2.numberingPlan.nationalPrefixForParsing() + ")");
    var prefixMatch = prefixPattern.exec(number);
    if (prefixMatch) {
      var nationalNumber;
      var carrierCode;
      var capturedGroupsCount = prefixMatch.length - 1;
      var hasCapturedGroups = capturedGroupsCount > 0 && prefixMatch[capturedGroupsCount];
      if (metadata2.nationalPrefixTransformRule() && hasCapturedGroups) {
        nationalNumber = number.replace(prefixPattern, metadata2.nationalPrefixTransformRule());
        if (capturedGroupsCount > 1) {
          carrierCode = prefixMatch[1];
        }
      } else {
        var prefixBeforeNationalNumber = prefixMatch[0];
        nationalNumber = number.slice(prefixBeforeNationalNumber.length);
        if (hasCapturedGroups) {
          carrierCode = prefixMatch[1];
        }
      }
      var nationalPrefix;
      if (hasCapturedGroups) {
        var possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[1]);
        var possibleNationalPrefix = number.slice(0, possiblePositionOfTheFirstCapturedGroup);
        if (possibleNationalPrefix === metadata2.numberingPlan.nationalPrefix()) {
          nationalPrefix = metadata2.numberingPlan.nationalPrefix();
        }
      } else {
        nationalPrefix = prefixMatch[0];
      }
      return {
        nationalNumber,
        nationalPrefix,
        carrierCode
      };
    }
  }
  return {
    nationalNumber: number
  };
}
function extractNationalNumber(number, metadata2) {
  var _extractNationalNumbe = extractNationalNumberFromPossiblyIncompleteNumber(number, metadata2), carrierCode = _extractNationalNumbe.carrierCode, nationalNumber = _extractNationalNumbe.nationalNumber;
  if (nationalNumber !== number) {
    if (!shouldHaveExtractedNationalPrefix(number, nationalNumber, metadata2)) {
      return {
        nationalNumber: number
      };
    }
    if (metadata2.possibleLengths()) {
      if (!isPossibleIncompleteNationalNumber(nationalNumber, metadata2)) {
        return {
          nationalNumber: number
        };
      }
    }
  }
  return {
    nationalNumber,
    carrierCode
  };
}
function shouldHaveExtractedNationalPrefix(nationalNumberBefore, nationalNumberAfter, metadata2) {
  if (matchesEntirely(nationalNumberBefore, metadata2.nationalNumberPattern()) && !matchesEntirely(nationalNumberAfter, metadata2.nationalNumberPattern())) {
    return false;
  }
  return true;
}
function isPossibleIncompleteNationalNumber(nationalNumber, metadata2) {
  switch (checkNumberLength(nationalNumber, metadata2)) {
    case "TOO_SHORT":
    case "INVALID_LENGTH":
      return false;
    default:
      return true;
  }
}
function extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(number, country, callingCode, metadata2) {
  var countryCallingCode = country ? getCountryCallingCode(country, metadata2) : callingCode;
  if (number.indexOf(countryCallingCode) === 0) {
    metadata2 = new Metadata(metadata2);
    metadata2.selectNumberingPlan(country, callingCode);
    var possibleShorterNumber = number.slice(countryCallingCode.length);
    var _extractNationalNumbe = extractNationalNumber(possibleShorterNumber, metadata2), possibleShorterNationalNumber = _extractNationalNumbe.nationalNumber;
    var _extractNationalNumbe2 = extractNationalNumber(number, metadata2), nationalNumber = _extractNationalNumbe2.nationalNumber;
    if (!matchesEntirely(nationalNumber, metadata2.nationalNumberPattern()) && matchesEntirely(possibleShorterNationalNumber, metadata2.nationalNumberPattern()) || checkNumberLength(nationalNumber, metadata2) === "TOO_LONG") {
      return {
        countryCallingCode,
        number: possibleShorterNumber
      };
    }
  }
  return {
    number
  };
}
function extractCountryCallingCode(number, country, callingCode, metadata2) {
  if (!number) {
    return {};
  }
  var isNumberWithIddPrefix;
  if (number[0] !== "+") {
    var numberWithoutIDD = stripIddPrefix(number, country, callingCode, metadata2);
    if (numberWithoutIDD && numberWithoutIDD !== number) {
      isNumberWithIddPrefix = true;
      number = "+" + numberWithoutIDD;
    } else {
      if (country || callingCode) {
        var _extractCountryCallin = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(number, country, callingCode, metadata2), countryCallingCode = _extractCountryCallin.countryCallingCode, shorterNumber = _extractCountryCallin.number;
        if (countryCallingCode) {
          return {
            countryCallingCodeSource: "FROM_NUMBER_WITHOUT_PLUS_SIGN",
            countryCallingCode,
            number: shorterNumber
          };
        }
      }
      return {
        // No need to set it to `UNSPECIFIED`. It can be just `undefined`.
        // countryCallingCodeSource: 'UNSPECIFIED',
        number
      };
    }
  }
  if (number[1] === "0") {
    return {};
  }
  metadata2 = new Metadata(metadata2);
  var i2 = 2;
  while (i2 - 1 <= MAX_LENGTH_COUNTRY_CODE && i2 <= number.length) {
    var _countryCallingCode = number.slice(1, i2);
    if (metadata2.hasCallingCode(_countryCallingCode)) {
      metadata2.selectNumberingPlan(_countryCallingCode);
      return {
        countryCallingCodeSource: isNumberWithIddPrefix ? "FROM_NUMBER_WITH_IDD" : "FROM_NUMBER_WITH_PLUS_SIGN",
        countryCallingCode: _countryCallingCode,
        number: number.slice(i2)
      };
    }
    i2++;
  }
  return {};
}
function _createForOfIteratorHelperLoose$6(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2)
    return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray$9(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
    if (it2)
      o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length)
        return { done: true };
      return { done: false, value: o3[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$9(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$9(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$9(o3, minLen);
}
function _arrayLikeToArray$9(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function getCountryByNationalNumber(nationalPhoneNumber, _ref) {
  var countries = _ref.countries, defaultCountry = _ref.defaultCountry, metadata2 = _ref.metadata;
  metadata2 = new Metadata(metadata2);
  var matchingCountries = [];
  for (var _iterator = _createForOfIteratorHelperLoose$6(countries), _step; !(_step = _iterator()).done; ) {
    var country = _step.value;
    metadata2.country(country);
    if (metadata2.leadingDigits()) {
      if (nationalPhoneNumber && nationalPhoneNumber.search(metadata2.leadingDigits()) === 0) {
        return country;
      }
    } else if (getNumberType({
      phone: nationalPhoneNumber,
      country
    }, void 0, metadata2.metadata)) {
      if (defaultCountry) {
        if (country === defaultCountry) {
          return country;
        }
        matchingCountries.push(country);
      } else {
        return country;
      }
    }
  }
  if (matchingCountries.length > 0) {
    return matchingCountries[0];
  }
}
var USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;
function getCountryByCallingCode(callingCode, _ref) {
  var nationalPhoneNumber = _ref.nationalNumber, defaultCountry = _ref.defaultCountry, metadata2 = _ref.metadata;
  if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
    if (metadata2.isNonGeographicCallingCode(callingCode)) {
      return "001";
    }
  }
  var possibleCountries = metadata2.getCountryCodesForCallingCode(callingCode);
  if (!possibleCountries) {
    return;
  }
  if (possibleCountries.length === 1) {
    return possibleCountries[0];
  }
  return getCountryByNationalNumber(nationalPhoneNumber, {
    countries: possibleCountries,
    defaultCountry,
    metadata: metadata2.metadata
  });
}
var PLUS_SIGN = "+";
var RFC3966_VISUAL_SEPARATOR_ = "[\\-\\.\\(\\)]?";
var RFC3966_PHONE_DIGIT_ = "([" + VALID_DIGITS + "]|" + RFC3966_VISUAL_SEPARATOR_ + ")";
var RFC3966_GLOBAL_NUMBER_DIGITS_ = "^\\" + PLUS_SIGN + RFC3966_PHONE_DIGIT_ + "*[" + VALID_DIGITS + "]" + RFC3966_PHONE_DIGIT_ + "*$";
var RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_ = new RegExp(RFC3966_GLOBAL_NUMBER_DIGITS_, "g");
var ALPHANUM_ = VALID_DIGITS;
var RFC3966_DOMAINLABEL_ = "[" + ALPHANUM_ + "]+((\\-)*[" + ALPHANUM_ + "])*";
var VALID_ALPHA_ = "a-zA-Z";
var RFC3966_TOPLABEL_ = "[" + VALID_ALPHA_ + "]+((\\-)*[" + ALPHANUM_ + "])*";
var RFC3966_DOMAINNAME_ = "^(" + RFC3966_DOMAINLABEL_ + "\\.)*" + RFC3966_TOPLABEL_ + "\\.?$";
var RFC3966_DOMAINNAME_PATTERN_ = new RegExp(RFC3966_DOMAINNAME_, "g");
var RFC3966_PREFIX_ = "tel:";
var RFC3966_PHONE_CONTEXT_ = ";phone-context=";
var RFC3966_ISDN_SUBADDRESS_ = ";isub=";
function extractPhoneContext(numberToExtractFrom) {
  var indexOfPhoneContext = numberToExtractFrom.indexOf(RFC3966_PHONE_CONTEXT_);
  if (indexOfPhoneContext < 0) {
    return null;
  }
  var phoneContextStart = indexOfPhoneContext + RFC3966_PHONE_CONTEXT_.length;
  if (phoneContextStart >= numberToExtractFrom.length) {
    return "";
  }
  var phoneContextEnd = numberToExtractFrom.indexOf(";", phoneContextStart);
  if (phoneContextEnd >= 0) {
    return numberToExtractFrom.substring(phoneContextStart, phoneContextEnd);
  } else {
    return numberToExtractFrom.substring(phoneContextStart);
  }
}
function isPhoneContextValid(phoneContext) {
  if (phoneContext === null) {
    return true;
  }
  if (phoneContext.length === 0) {
    return false;
  }
  return RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_.test(phoneContext) || RFC3966_DOMAINNAME_PATTERN_.test(phoneContext);
}
function extractFormattedPhoneNumberFromPossibleRfc3966NumberUri(numberToParse, _ref) {
  var extractFormattedPhoneNumber2 = _ref.extractFormattedPhoneNumber;
  var phoneContext = extractPhoneContext(numberToParse);
  if (!isPhoneContextValid(phoneContext)) {
    throw new ParseError("NOT_A_NUMBER");
  }
  var phoneNumberString;
  if (phoneContext === null) {
    phoneNumberString = extractFormattedPhoneNumber2(numberToParse) || "";
  } else {
    phoneNumberString = "";
    if (phoneContext.charAt(0) === PLUS_SIGN) {
      phoneNumberString += phoneContext;
    }
    var indexOfRfc3966Prefix = numberToParse.indexOf(RFC3966_PREFIX_);
    var indexOfNationalNumber;
    if (indexOfRfc3966Prefix >= 0) {
      indexOfNationalNumber = indexOfRfc3966Prefix + RFC3966_PREFIX_.length;
    } else {
      indexOfNationalNumber = 0;
    }
    var indexOfPhoneContext = numberToParse.indexOf(RFC3966_PHONE_CONTEXT_);
    phoneNumberString += numberToParse.substring(indexOfNationalNumber, indexOfPhoneContext);
  }
  var indexOfIsdn = phoneNumberString.indexOf(RFC3966_ISDN_SUBADDRESS_);
  if (indexOfIsdn > 0) {
    phoneNumberString = phoneNumberString.substring(0, indexOfIsdn);
  }
  if (phoneNumberString !== "") {
    return phoneNumberString;
  }
}
var MAX_INPUT_STRING_LENGTH = 250;
var PHONE_NUMBER_START_PATTERN = new RegExp("[" + PLUS_CHARS + VALID_DIGITS + "]");
var AFTER_PHONE_NUMBER_END_PATTERN = new RegExp("[^" + VALID_DIGITS + "#]+$");
function parse(text, options, metadata2) {
  options = options || {};
  metadata2 = new Metadata(metadata2);
  if (options.defaultCountry && !metadata2.hasCountry(options.defaultCountry)) {
    if (options.v2) {
      throw new ParseError("INVALID_COUNTRY");
    }
    throw new Error("Unknown country: ".concat(options.defaultCountry));
  }
  var _parseInput = parseInput(text, options.v2, options.extract), formattedPhoneNumber = _parseInput.number, ext = _parseInput.ext, error = _parseInput.error;
  if (!formattedPhoneNumber) {
    if (options.v2) {
      if (error === "TOO_SHORT") {
        throw new ParseError("TOO_SHORT");
      }
      throw new ParseError("NOT_A_NUMBER");
    }
    return {};
  }
  var _parsePhoneNumber = parsePhoneNumber$3(formattedPhoneNumber, options.defaultCountry, options.defaultCallingCode, metadata2), country = _parsePhoneNumber.country, nationalNumber = _parsePhoneNumber.nationalNumber, countryCallingCode = _parsePhoneNumber.countryCallingCode, countryCallingCodeSource = _parsePhoneNumber.countryCallingCodeSource, carrierCode = _parsePhoneNumber.carrierCode;
  if (!metadata2.hasSelectedNumberingPlan()) {
    if (options.v2) {
      throw new ParseError("INVALID_COUNTRY");
    }
    return {};
  }
  if (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {
    if (options.v2) {
      throw new ParseError("TOO_SHORT");
    }
    return {};
  }
  if (nationalNumber.length > MAX_LENGTH_FOR_NSN) {
    if (options.v2) {
      throw new ParseError("TOO_LONG");
    }
    return {};
  }
  if (options.v2) {
    var phoneNumber = new PhoneNumber(countryCallingCode, nationalNumber, metadata2.metadata);
    if (country) {
      phoneNumber.country = country;
    }
    if (carrierCode) {
      phoneNumber.carrierCode = carrierCode;
    }
    if (ext) {
      phoneNumber.ext = ext;
    }
    phoneNumber.__countryCallingCodeSource = countryCallingCodeSource;
    return phoneNumber;
  }
  var valid = (options.extended ? metadata2.hasSelectedNumberingPlan() : country) ? matchesEntirely(nationalNumber, metadata2.nationalNumberPattern()) : false;
  if (!options.extended) {
    return valid ? result(country, nationalNumber, ext) : {};
  }
  return {
    country,
    countryCallingCode,
    carrierCode,
    valid,
    possible: valid ? true : options.extended === true && metadata2.possibleLengths() && isPossibleNumber(nationalNumber, metadata2) ? true : false,
    phone: nationalNumber,
    ext
  };
}
function _extractFormattedPhoneNumber(text, extract, throwOnError) {
  if (!text) {
    return;
  }
  if (text.length > MAX_INPUT_STRING_LENGTH) {
    if (throwOnError) {
      throw new ParseError("TOO_LONG");
    }
    return;
  }
  if (extract === false) {
    return text;
  }
  var startsAt = text.search(PHONE_NUMBER_START_PATTERN);
  if (startsAt < 0) {
    return;
  }
  return text.slice(startsAt).replace(AFTER_PHONE_NUMBER_END_PATTERN, "");
}
function parseInput(text, v2, extract) {
  var number = extractFormattedPhoneNumberFromPossibleRfc3966NumberUri(text, {
    extractFormattedPhoneNumber: function extractFormattedPhoneNumber2(text2) {
      return _extractFormattedPhoneNumber(text2, extract, v2);
    }
  });
  if (!number) {
    return {};
  }
  if (!isViablePhoneNumber(number)) {
    if (isViablePhoneNumberStart(number)) {
      return {
        error: "TOO_SHORT"
      };
    }
    return {};
  }
  var withExtensionStripped = extractExtension(number);
  if (withExtensionStripped.ext) {
    return withExtensionStripped;
  }
  return {
    number
  };
}
function result(country, nationalNumber, ext) {
  var result2 = {
    country,
    phone: nationalNumber
  };
  if (ext) {
    result2.ext = ext;
  }
  return result2;
}
function parsePhoneNumber$3(formattedPhoneNumber, defaultCountry, defaultCallingCode, metadata2) {
  var _extractCountryCallin = extractCountryCallingCode(parseIncompletePhoneNumber(formattedPhoneNumber), defaultCountry, defaultCallingCode, metadata2.metadata), countryCallingCodeSource = _extractCountryCallin.countryCallingCodeSource, countryCallingCode = _extractCountryCallin.countryCallingCode, number = _extractCountryCallin.number;
  var country;
  if (countryCallingCode) {
    metadata2.selectNumberingPlan(countryCallingCode);
  } else if (number && (defaultCountry || defaultCallingCode)) {
    metadata2.selectNumberingPlan(defaultCountry, defaultCallingCode);
    if (defaultCountry) {
      country = defaultCountry;
    }
    countryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata2.metadata);
  } else
    return {};
  if (!number) {
    return {
      countryCallingCodeSource,
      countryCallingCode
    };
  }
  var _extractNationalNumbe = extractNationalNumber(parseIncompletePhoneNumber(number), metadata2), nationalNumber = _extractNationalNumbe.nationalNumber, carrierCode = _extractNationalNumbe.carrierCode;
  var exactCountry = getCountryByCallingCode(countryCallingCode, {
    nationalNumber,
    defaultCountry,
    metadata: metadata2
  });
  if (exactCountry) {
    country = exactCountry;
    if (exactCountry === "001")
      ;
    else {
      metadata2.country(country);
    }
  }
  return {
    country,
    countryCallingCode,
    countryCallingCodeSource,
    nationalNumber,
    carrierCode
  };
}
function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$4(Object(source), true).forEach(function(key) {
      _defineProperty$5(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function parsePhoneNumberWithError(text, options, metadata2) {
  return parse(text, _objectSpread$4(_objectSpread$4({}, options), {}, {
    v2: true
  }), metadata2);
}
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray$2(arr, i2) {
  return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i2) || _unsupportedIterableToArray$8(arr, i2) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$8(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$8(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$8(o3, minLen);
}
function _arrayLikeToArray$8(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit$2(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles$2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function normalizeArguments(args) {
  var _Array$prototype$slic = Array.prototype.slice.call(args), _Array$prototype$slic2 = _slicedToArray$2(_Array$prototype$slic, 4), arg_1 = _Array$prototype$slic2[0], arg_2 = _Array$prototype$slic2[1], arg_3 = _Array$prototype$slic2[2], arg_4 = _Array$prototype$slic2[3];
  var text;
  var options;
  var metadata2;
  if (typeof arg_1 === "string") {
    text = arg_1;
  } else
    throw new TypeError("A text for parsing must be a string.");
  if (!arg_2 || typeof arg_2 === "string") {
    if (arg_4) {
      options = arg_3;
      metadata2 = arg_4;
    } else {
      options = void 0;
      metadata2 = arg_3;
    }
    if (arg_2) {
      options = _objectSpread$3({
        defaultCountry: arg_2
      }, options);
    }
  } else if (isObject(arg_2)) {
    if (arg_3) {
      options = arg_2;
      metadata2 = arg_3;
    } else {
      metadata2 = arg_2;
    }
  } else
    throw new Error("Invalid second argument: ".concat(arg_2));
  return {
    text,
    options,
    metadata: metadata2
  };
}
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty$3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function parsePhoneNumber$2(text, options, metadata2) {
  if (options && options.defaultCountry && !isSupportedCountry(options.defaultCountry, metadata2)) {
    options = _objectSpread$2(_objectSpread$2({}, options), {}, {
      defaultCountry: void 0
    });
  }
  try {
    return parsePhoneNumberWithError(text, options, metadata2);
  } catch (error) {
    if (error instanceof ParseError)
      ;
    else {
      throw error;
    }
  }
}
function parsePhoneNumber$1() {
  var _normalizeArguments = normalizeArguments(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata2 = _normalizeArguments.metadata;
  return parsePhoneNumber$2(text, options, metadata2);
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$6(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$6(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$6(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$6(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var AsYouTypeState = /* @__PURE__ */ function() {
  function AsYouTypeState2(_ref) {
    var onCountryChange = _ref.onCountryChange, onCallingCodeChange = _ref.onCallingCodeChange;
    _classCallCheck$6(this, AsYouTypeState2);
    this.onCountryChange = onCountryChange;
    this.onCallingCodeChange = onCallingCodeChange;
  }
  _createClass$6(AsYouTypeState2, [{
    key: "reset",
    value: function reset(_ref2) {
      var country = _ref2.country, callingCode = _ref2.callingCode;
      this.international = false;
      this.missingPlus = false;
      this.IDDPrefix = void 0;
      this.callingCode = void 0;
      this.digits = "";
      this.resetNationalSignificantNumber();
      this.initCountryAndCallingCode(country, callingCode);
    }
  }, {
    key: "resetNationalSignificantNumber",
    value: function resetNationalSignificantNumber() {
      this.nationalSignificantNumber = this.getNationalDigits();
      this.nationalSignificantNumberMatchesInput = true;
      this.nationalPrefix = void 0;
      this.carrierCode = void 0;
      this.complexPrefixBeforeNationalSignificantNumber = void 0;
    }
  }, {
    key: "update",
    value: function update(properties) {
      for (var _i = 0, _Object$keys = Object.keys(properties); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        this[key] = properties[key];
      }
    }
  }, {
    key: "initCountryAndCallingCode",
    value: function initCountryAndCallingCode(country, callingCode) {
      this.setCountry(country);
      this.setCallingCode(callingCode);
    }
  }, {
    key: "setCountry",
    value: function setCountry(country) {
      this.country = country;
      this.onCountryChange(country);
    }
  }, {
    key: "setCallingCode",
    value: function setCallingCode(callingCode) {
      this.callingCode = callingCode;
      this.onCallingCodeChange(callingCode, this.country);
    }
  }, {
    key: "startInternationalNumber",
    value: function startInternationalNumber(country, callingCode) {
      this.international = true;
      this.initCountryAndCallingCode(country, callingCode);
    }
  }, {
    key: "appendDigits",
    value: function appendDigits(nextDigits) {
      this.digits += nextDigits;
    }
  }, {
    key: "appendNationalSignificantNumberDigits",
    value: function appendNationalSignificantNumberDigits(nextDigits) {
      this.nationalSignificantNumber += nextDigits;
    }
    /**
     * Returns the part of `this.digits` that corresponds to the national number.
     * Basically, all digits that have been input by the user, except for the
     * international prefix and the country calling code part
     * (if the number is an international one).
     * @return {string}
     */
  }, {
    key: "getNationalDigits",
    value: function getNationalDigits() {
      if (this.international) {
        return this.digits.slice((this.IDDPrefix ? this.IDDPrefix.length : 0) + (this.callingCode ? this.callingCode.length : 0));
      }
      return this.digits;
    }
  }, {
    key: "getDigitsWithoutInternationalPrefix",
    value: function getDigitsWithoutInternationalPrefix() {
      if (this.international) {
        if (this.IDDPrefix) {
          return this.digits.slice(this.IDDPrefix.length);
        }
      }
      return this.digits;
    }
  }]);
  return AsYouTypeState2;
}();
function _createForOfIteratorHelperLoose$5(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2)
    return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray$7(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
    if (it2)
      o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length)
        return { done: true };
      return { done: false, value: o3[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$7(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$7(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$7(o3, minLen);
}
function _arrayLikeToArray$7(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
var DIGIT_PLACEHOLDER = "x";
var DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER);
function repeat(string, times) {
  if (times < 1) {
    return "";
  }
  var result2 = "";
  while (times > 1) {
    if (times & 1) {
      result2 += string;
    }
    times >>= 1;
    string += string;
  }
  return result2 + string;
}
function cutAndStripNonPairedParens(string, cutBeforeIndex) {
  if (string[cutBeforeIndex] === ")") {
    cutBeforeIndex++;
  }
  return stripNonPairedParens(string.slice(0, cutBeforeIndex));
}
function stripNonPairedParens(string) {
  var dangling_braces = [];
  var i2 = 0;
  while (i2 < string.length) {
    if (string[i2] === "(") {
      dangling_braces.push(i2);
    } else if (string[i2] === ")") {
      dangling_braces.pop();
    }
    i2++;
  }
  var start = 0;
  var cleared_string = "";
  dangling_braces.push(string.length);
  for (var _i = 0, _dangling_braces = dangling_braces; _i < _dangling_braces.length; _i++) {
    var index2 = _dangling_braces[_i];
    cleared_string += string.slice(start, index2);
    start = index2 + 1;
  }
  return cleared_string;
}
function populateTemplateWithDigits(template, position, digits) {
  for (var _iterator2 = _createForOfIteratorHelperLoose$5(digits.split("")), _step2; !(_step2 = _iterator2()).done; ) {
    var digit = _step2.value;
    if (template.slice(position + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {
      return;
    }
    position = template.search(DIGIT_PLACEHOLDER_MATCHER);
    template = template.replace(DIGIT_PLACEHOLDER_MATCHER, digit);
  }
  return [template, position];
}
function formatCompleteNumber(state, format2, _ref) {
  var metadata2 = _ref.metadata, shouldTryNationalPrefixFormattingRule = _ref.shouldTryNationalPrefixFormattingRule, getSeparatorAfterNationalPrefix = _ref.getSeparatorAfterNationalPrefix;
  var matcher = new RegExp("^(?:".concat(format2.pattern(), ")$"));
  if (matcher.test(state.nationalSignificantNumber)) {
    return formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format2, {
      metadata: metadata2,
      shouldTryNationalPrefixFormattingRule,
      getSeparatorAfterNationalPrefix
    });
  }
}
function canFormatCompleteNumber(nationalSignificantNumber, metadata2) {
  return checkNumberLength(nationalSignificantNumber, metadata2) === "IS_POSSIBLE";
}
function formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format2, _ref2) {
  var metadata2 = _ref2.metadata, shouldTryNationalPrefixFormattingRule = _ref2.shouldTryNationalPrefixFormattingRule, getSeparatorAfterNationalPrefix = _ref2.getSeparatorAfterNationalPrefix;
  state.nationalSignificantNumber;
  state.international;
  state.nationalPrefix;
  state.carrierCode;
  if (shouldTryNationalPrefixFormattingRule(format2)) {
    var formattedNumber = formatNationalNumber(state, format2, {
      useNationalPrefixFormattingRule: true,
      getSeparatorAfterNationalPrefix,
      metadata: metadata2
    });
    if (formattedNumber) {
      return formattedNumber;
    }
  }
  return formatNationalNumber(state, format2, {
    useNationalPrefixFormattingRule: false,
    getSeparatorAfterNationalPrefix,
    metadata: metadata2
  });
}
function formatNationalNumber(state, format2, _ref3) {
  var metadata2 = _ref3.metadata, useNationalPrefixFormattingRule = _ref3.useNationalPrefixFormattingRule, getSeparatorAfterNationalPrefix = _ref3.getSeparatorAfterNationalPrefix;
  var formattedNationalNumber = formatNationalNumberUsingFormat(state.nationalSignificantNumber, format2, {
    carrierCode: state.carrierCode,
    useInternationalFormat: state.international,
    withNationalPrefix: useNationalPrefixFormattingRule,
    metadata: metadata2
  });
  if (!useNationalPrefixFormattingRule) {
    if (state.nationalPrefix) {
      formattedNationalNumber = state.nationalPrefix + getSeparatorAfterNationalPrefix(format2) + formattedNationalNumber;
    } else if (state.complexPrefixBeforeNationalSignificantNumber) {
      formattedNationalNumber = state.complexPrefixBeforeNationalSignificantNumber + " " + formattedNationalNumber;
    }
  }
  if (isValidFormattedNationalNumber(formattedNationalNumber, state)) {
    return formattedNationalNumber;
  }
}
function isValidFormattedNationalNumber(formattedNationalNumber, state) {
  return parseDigits(formattedNationalNumber) === state.getNationalDigits();
}
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$5(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var PatternParser = /* @__PURE__ */ function() {
  function PatternParser2() {
    _classCallCheck$5(this, PatternParser2);
  }
  _createClass$5(PatternParser2, [{
    key: "parse",
    value: function parse2(pattern) {
      this.context = [{
        or: true,
        instructions: []
      }];
      this.parsePattern(pattern);
      if (this.context.length !== 1) {
        throw new Error("Non-finalized contexts left when pattern parse ended");
      }
      var _this$context$ = this.context[0], branches = _this$context$.branches, instructions = _this$context$.instructions;
      if (branches) {
        return {
          op: "|",
          args: branches.concat([expandSingleElementArray(instructions)])
        };
      }
      if (instructions.length === 0) {
        throw new Error("Pattern is required");
      }
      if (instructions.length === 1) {
        return instructions[0];
      }
      return instructions;
    }
  }, {
    key: "startContext",
    value: function startContext(context) {
      this.context.push(context);
    }
  }, {
    key: "endContext",
    value: function endContext() {
      this.context.pop();
    }
  }, {
    key: "getContext",
    value: function getContext() {
      return this.context[this.context.length - 1];
    }
  }, {
    key: "parsePattern",
    value: function parsePattern(pattern) {
      if (!pattern) {
        throw new Error("Pattern is required");
      }
      var match = pattern.match(OPERATOR);
      if (!match) {
        if (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {
          throw new Error("Illegal characters found in a pattern: ".concat(pattern));
        }
        this.getContext().instructions = this.getContext().instructions.concat(pattern.split(""));
        return;
      }
      var operator = match[1];
      var before = pattern.slice(0, match.index);
      var rightPart = pattern.slice(match.index + operator.length);
      switch (operator) {
        case "(?:":
          if (before) {
            this.parsePattern(before);
          }
          this.startContext({
            or: true,
            instructions: [],
            branches: []
          });
          break;
        case ")":
          if (!this.getContext().or) {
            throw new Error('")" operator must be preceded by "(?:" operator');
          }
          if (before) {
            this.parsePattern(before);
          }
          if (this.getContext().instructions.length === 0) {
            throw new Error('No instructions found after "|" operator in an "or" group');
          }
          var _this$getContext = this.getContext(), branches = _this$getContext.branches;
          branches.push(expandSingleElementArray(this.getContext().instructions));
          this.endContext();
          this.getContext().instructions.push({
            op: "|",
            args: branches
          });
          break;
        case "|":
          if (!this.getContext().or) {
            throw new Error('"|" operator can only be used inside "or" groups');
          }
          if (before) {
            this.parsePattern(before);
          }
          if (!this.getContext().branches) {
            if (this.context.length === 1) {
              this.getContext().branches = [];
            } else {
              throw new Error('"branches" not found in an "or" group context');
            }
          }
          this.getContext().branches.push(expandSingleElementArray(this.getContext().instructions));
          this.getContext().instructions = [];
          break;
        case "[":
          if (before) {
            this.parsePattern(before);
          }
          this.startContext({
            oneOfSet: true
          });
          break;
        case "]":
          if (!this.getContext().oneOfSet) {
            throw new Error('"]" operator must be preceded by "[" operator');
          }
          this.endContext();
          this.getContext().instructions.push({
            op: "[]",
            args: parseOneOfSet(before)
          });
          break;
        default:
          throw new Error("Unknown operator: ".concat(operator));
      }
      if (rightPart) {
        this.parsePattern(rightPart);
      }
    }
  }]);
  return PatternParser2;
}();
function parseOneOfSet(pattern) {
  var values = [];
  var i2 = 0;
  while (i2 < pattern.length) {
    if (pattern[i2] === "-") {
      if (i2 === 0 || i2 === pattern.length - 1) {
        throw new Error("Couldn't parse a one-of set pattern: ".concat(pattern));
      }
      var prevValue = pattern[i2 - 1].charCodeAt(0) + 1;
      var nextValue = pattern[i2 + 1].charCodeAt(0) - 1;
      var value = prevValue;
      while (value <= nextValue) {
        values.push(String.fromCharCode(value));
        value++;
      }
    } else {
      values.push(pattern[i2]);
    }
    i2++;
  }
  return values;
}
var ILLEGAL_CHARACTER_REGEXP = /[\(\)\[\]\?\:\|]/;
var OPERATOR = new RegExp(
  // any of:
  "(\\||\\(\\?\\:|\\)|\\[|\\])"
);
function expandSingleElementArray(array) {
  if (array.length === 1) {
    return array[0];
  }
  return array;
}
function _createForOfIteratorHelperLoose$4(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2)
    return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray$6(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
    if (it2)
      o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length)
        return { done: true };
      return { done: false, value: o3[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$6(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$6(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$6(o3, minLen);
}
function _arrayLikeToArray$6(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$4(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var PatternMatcher = /* @__PURE__ */ function() {
  function PatternMatcher2(pattern) {
    _classCallCheck$4(this, PatternMatcher2);
    this.matchTree = new PatternParser().parse(pattern);
  }
  _createClass$4(PatternMatcher2, [{
    key: "match",
    value: function match(string) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, allowOverflow = _ref.allowOverflow;
      if (!string) {
        throw new Error("String is required");
      }
      var result2 = _match(string.split(""), this.matchTree, true);
      if (result2 && result2.match) {
        delete result2.matchedChars;
      }
      if (result2 && result2.overflow) {
        if (!allowOverflow) {
          return;
        }
      }
      return result2;
    }
  }]);
  return PatternMatcher2;
}();
function _match(characters, tree, last) {
  if (typeof tree === "string") {
    var characterString = characters.join("");
    if (tree.indexOf(characterString) === 0) {
      if (characters.length === tree.length) {
        return {
          match: true,
          matchedChars: characters
        };
      }
      return {
        partialMatch: true
        // matchedChars: characters
      };
    }
    if (characterString.indexOf(tree) === 0) {
      if (last) {
        if (characters.length > tree.length) {
          return {
            overflow: true
          };
        }
      }
      return {
        match: true,
        matchedChars: characters.slice(0, tree.length)
      };
    }
    return;
  }
  if (Array.isArray(tree)) {
    var restCharacters = characters.slice();
    var i2 = 0;
    while (i2 < tree.length) {
      var subtree = tree[i2];
      var result2 = _match(restCharacters, subtree, last && i2 === tree.length - 1);
      if (!result2) {
        return;
      } else if (result2.overflow) {
        return result2;
      } else if (result2.match) {
        restCharacters = restCharacters.slice(result2.matchedChars.length);
        if (restCharacters.length === 0) {
          if (i2 === tree.length - 1) {
            return {
              match: true,
              matchedChars: characters
            };
          } else {
            return {
              partialMatch: true
              // matchedChars: characters
            };
          }
        }
      } else {
        if (result2.partialMatch) {
          return {
            partialMatch: true
            // matchedChars: characters
          };
        } else {
          throw new Error("Unsupported match result:\n".concat(JSON.stringify(result2, null, 2)));
        }
      }
      i2++;
    }
    if (last) {
      return {
        overflow: true
      };
    }
    return {
      match: true,
      matchedChars: characters.slice(0, characters.length - restCharacters.length)
    };
  }
  switch (tree.op) {
    case "|":
      var partialMatch;
      for (var _iterator = _createForOfIteratorHelperLoose$4(tree.args), _step; !(_step = _iterator()).done; ) {
        var branch = _step.value;
        var _result = _match(characters, branch, last);
        if (_result) {
          if (_result.overflow) {
            return _result;
          } else if (_result.match) {
            return {
              match: true,
              matchedChars: _result.matchedChars
            };
          } else {
            if (_result.partialMatch) {
              partialMatch = true;
            } else {
              throw new Error("Unsupported match result:\n".concat(JSON.stringify(_result, null, 2)));
            }
          }
        }
      }
      if (partialMatch) {
        return {
          partialMatch: true
          // matchedChars: ...
        };
      }
      return;
    case "[]":
      for (var _iterator2 = _createForOfIteratorHelperLoose$4(tree.args), _step2; !(_step2 = _iterator2()).done; ) {
        var _char = _step2.value;
        if (characters[0] === _char) {
          if (characters.length === 1) {
            return {
              match: true,
              matchedChars: characters
            };
          }
          if (last) {
            return {
              overflow: true
            };
          }
          return {
            match: true,
            matchedChars: [_char]
          };
        }
      }
      return;
    default:
      throw new Error("Unsupported instruction tree: ".concat(tree));
  }
}
function _createForOfIteratorHelperLoose$3(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2)
    return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray$5(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
    if (it2)
      o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length)
        return { done: true };
      return { done: false, value: o3[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$5(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$5(o3, minLen);
}
function _arrayLikeToArray$5(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var DUMMY_DIGIT = "9";
var LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15;
var LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH);
var NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/;
var CREATE_CHARACTER_CLASS_PATTERN = function() {
  return /\[([^\[\]])*\]/g;
};
var CREATE_STANDALONE_DIGIT_PATTERN = function() {
  return /\d(?=[^,}][^,}])/g;
};
var NON_ALTERING_FORMAT_REG_EXP = new RegExp("[" + VALID_PUNCTUATION + "]*\\$1[" + VALID_PUNCTUATION + "]*(\\$\\d[" + VALID_PUNCTUATION + "]*)*$");
var MIN_LEADING_DIGITS_LENGTH = 3;
var AsYouTypeFormatter = /* @__PURE__ */ function() {
  function AsYouTypeFormatter2(_ref) {
    _ref.state;
    var metadata2 = _ref.metadata;
    _classCallCheck$3(this, AsYouTypeFormatter2);
    this.metadata = metadata2;
    this.resetFormat();
  }
  _createClass$3(AsYouTypeFormatter2, [{
    key: "resetFormat",
    value: function resetFormat() {
      this.chosenFormat = void 0;
      this.template = void 0;
      this.nationalNumberTemplate = void 0;
      this.populatedNationalNumberTemplate = void 0;
      this.populatedNationalNumberTemplatePosition = -1;
    }
  }, {
    key: "reset",
    value: function reset(numberingPlan, state) {
      this.resetFormat();
      if (numberingPlan) {
        this.isNANP = numberingPlan.callingCode() === "1";
        this.matchingFormats = numberingPlan.formats();
        if (state.nationalSignificantNumber) {
          this.narrowDownMatchingFormats(state);
        }
      } else {
        this.isNANP = void 0;
        this.matchingFormats = [];
      }
    }
    /**
     * Formats an updated phone number.
     * @param  {string} nextDigits — Additional phone number digits.
     * @param  {object} state — `AsYouType` state.
     * @return {[string]} Returns undefined if the updated phone number can't be formatted using any of the available formats.
     */
  }, {
    key: "format",
    value: function format2(nextDigits, state) {
      var _this = this;
      if (canFormatCompleteNumber(state.nationalSignificantNumber, this.metadata)) {
        for (var _iterator = _createForOfIteratorHelperLoose$3(this.matchingFormats), _step; !(_step = _iterator()).done; ) {
          var format3 = _step.value;
          var formattedCompleteNumber = formatCompleteNumber(state, format3, {
            metadata: this.metadata,
            shouldTryNationalPrefixFormattingRule: function shouldTryNationalPrefixFormattingRule(format4) {
              return _this.shouldTryNationalPrefixFormattingRule(format4, {
                international: state.international,
                nationalPrefix: state.nationalPrefix
              });
            },
            getSeparatorAfterNationalPrefix: function getSeparatorAfterNationalPrefix(format4) {
              return _this.getSeparatorAfterNationalPrefix(format4);
            }
          });
          if (formattedCompleteNumber) {
            this.resetFormat();
            this.chosenFormat = format3;
            this.setNationalNumberTemplate(formattedCompleteNumber.replace(/\d/g, DIGIT_PLACEHOLDER), state);
            this.populatedNationalNumberTemplate = formattedCompleteNumber;
            this.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(DIGIT_PLACEHOLDER);
            return formattedCompleteNumber;
          }
        }
      }
      return this.formatNationalNumberWithNextDigits(nextDigits, state);
    }
    // Formats the next phone number digits.
  }, {
    key: "formatNationalNumberWithNextDigits",
    value: function formatNationalNumberWithNextDigits(nextDigits, state) {
      var previouslyChosenFormat = this.chosenFormat;
      var newlyChosenFormat = this.chooseFormat(state);
      if (newlyChosenFormat) {
        if (newlyChosenFormat === previouslyChosenFormat) {
          return this.formatNextNationalNumberDigits(nextDigits);
        } else {
          return this.formatNextNationalNumberDigits(state.getNationalDigits());
        }
      }
    }
  }, {
    key: "narrowDownMatchingFormats",
    value: function narrowDownMatchingFormats(_ref2) {
      var _this2 = this;
      var nationalSignificantNumber = _ref2.nationalSignificantNumber, nationalPrefix = _ref2.nationalPrefix, international = _ref2.international;
      var leadingDigits = nationalSignificantNumber;
      var leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH;
      if (leadingDigitsPatternIndex < 0) {
        leadingDigitsPatternIndex = 0;
      }
      this.matchingFormats = this.matchingFormats.filter(function(format2) {
        return _this2.formatSuits(format2, international, nationalPrefix) && _this2.formatMatches(format2, leadingDigits, leadingDigitsPatternIndex);
      });
      if (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {
        this.resetFormat();
      }
    }
  }, {
    key: "formatSuits",
    value: function formatSuits(format2, international, nationalPrefix) {
      if (nationalPrefix && !format2.usesNationalPrefix() && // !format.domesticCarrierCodeFormattingRule() &&
      !format2.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {
        return false;
      }
      if (!international && !nationalPrefix && format2.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {
        return false;
      }
      return true;
    }
  }, {
    key: "formatMatches",
    value: function formatMatches(format2, leadingDigits, leadingDigitsPatternIndex) {
      var leadingDigitsPatternsCount = format2.leadingDigitsPatterns().length;
      if (leadingDigitsPatternsCount === 0) {
        return true;
      }
      leadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1);
      var leadingDigitsPattern = format2.leadingDigitsPatterns()[leadingDigitsPatternIndex];
      if (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {
        try {
          return new PatternMatcher(leadingDigitsPattern).match(leadingDigits, {
            allowOverflow: true
          }) !== void 0;
        } catch (error) {
          console.error(error);
          return true;
        }
      }
      return new RegExp("^(".concat(leadingDigitsPattern, ")")).test(leadingDigits);
    }
  }, {
    key: "getFormatFormat",
    value: function getFormatFormat(format2, international) {
      return international ? format2.internationalFormat() : format2.format();
    }
  }, {
    key: "chooseFormat",
    value: function chooseFormat(state) {
      var _this3 = this;
      var _loop = function _loop2() {
        var format2 = _step2.value;
        if (_this3.chosenFormat === format2) {
          return "break";
        }
        if (!NON_ALTERING_FORMAT_REG_EXP.test(_this3.getFormatFormat(format2, state.international))) {
          return "continue";
        }
        if (!_this3.createTemplateForFormat(format2, state)) {
          _this3.matchingFormats = _this3.matchingFormats.filter(function(_3) {
            return _3 !== format2;
          });
          return "continue";
        }
        _this3.chosenFormat = format2;
        return "break";
      };
      for (var _iterator2 = _createForOfIteratorHelperLoose$3(this.matchingFormats.slice()), _step2; !(_step2 = _iterator2()).done; ) {
        var _ret = _loop();
        if (_ret === "break")
          break;
        if (_ret === "continue")
          continue;
      }
      if (!this.chosenFormat) {
        this.resetFormat();
      }
      return this.chosenFormat;
    }
  }, {
    key: "createTemplateForFormat",
    value: function createTemplateForFormat(format2, state) {
      if (format2.pattern().indexOf("|") >= 0) {
        return;
      }
      var template = this.getTemplateForFormat(format2, state);
      if (template) {
        this.setNationalNumberTemplate(template, state);
        return true;
      }
    }
  }, {
    key: "getSeparatorAfterNationalPrefix",
    value: function getSeparatorAfterNationalPrefix(format2) {
      if (this.isNANP) {
        return " ";
      }
      if (format2 && format2.nationalPrefixFormattingRule() && NATIONAL_PREFIX_SEPARATORS_PATTERN.test(format2.nationalPrefixFormattingRule())) {
        return " ";
      }
      return "";
    }
  }, {
    key: "getInternationalPrefixBeforeCountryCallingCode",
    value: function getInternationalPrefixBeforeCountryCallingCode(_ref3, options) {
      var IDDPrefix = _ref3.IDDPrefix, missingPlus = _ref3.missingPlus;
      if (IDDPrefix) {
        return options && options.spacing === false ? IDDPrefix : IDDPrefix + " ";
      }
      if (missingPlus) {
        return "";
      }
      return "+";
    }
  }, {
    key: "getTemplate",
    value: function getTemplate(state) {
      if (!this.template) {
        return;
      }
      var index2 = -1;
      var i2 = 0;
      var internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, {
        spacing: false
      }) : "";
      while (i2 < internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length) {
        index2 = this.template.indexOf(DIGIT_PLACEHOLDER, index2 + 1);
        i2++;
      }
      return cutAndStripNonPairedParens(this.template, index2 + 1);
    }
  }, {
    key: "setNationalNumberTemplate",
    value: function setNationalNumberTemplate(template, state) {
      this.nationalNumberTemplate = template;
      this.populatedNationalNumberTemplate = template;
      this.populatedNationalNumberTemplatePosition = -1;
      if (state.international) {
        this.template = this.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[\d\+]/g, DIGIT_PLACEHOLDER) + repeat(DIGIT_PLACEHOLDER, state.callingCode.length) + " " + template;
      } else {
        this.template = template;
      }
    }
    /**
     * Generates formatting template for a national phone number,
     * optionally containing a national prefix, for a format.
     * @param  {Format} format
     * @param  {string} nationalPrefix
     * @return {string}
     */
  }, {
    key: "getTemplateForFormat",
    value: function getTemplateForFormat(format2, _ref4) {
      var nationalSignificantNumber = _ref4.nationalSignificantNumber, international = _ref4.international, nationalPrefix = _ref4.nationalPrefix, complexPrefixBeforeNationalSignificantNumber = _ref4.complexPrefixBeforeNationalSignificantNumber;
      var pattern = format2.pattern();
      {
        pattern = pattern.replace(CREATE_CHARACTER_CLASS_PATTERN(), "\\d").replace(CREATE_STANDALONE_DIGIT_PATTERN(), "\\d");
      }
      var digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0];
      if (nationalSignificantNumber.length > digits.length) {
        return;
      }
      var strictPattern = new RegExp("^" + pattern + "$");
      var nationalNumberDummyDigits = nationalSignificantNumber.replace(/\d/g, DUMMY_DIGIT);
      if (strictPattern.test(nationalNumberDummyDigits)) {
        digits = nationalNumberDummyDigits;
      }
      var numberFormat = this.getFormatFormat(format2, international);
      var nationalPrefixIncludedInTemplate;
      if (this.shouldTryNationalPrefixFormattingRule(format2, {
        international,
        nationalPrefix
      })) {
        var numberFormatWithNationalPrefix = numberFormat.replace(FIRST_GROUP_PATTERN, format2.nationalPrefixFormattingRule());
        if (parseDigits(format2.nationalPrefixFormattingRule()) === (nationalPrefix || "") + parseDigits("$1")) {
          numberFormat = numberFormatWithNationalPrefix;
          nationalPrefixIncludedInTemplate = true;
          if (nationalPrefix) {
            var i2 = nationalPrefix.length;
            while (i2 > 0) {
              numberFormat = numberFormat.replace(/\d/, DIGIT_PLACEHOLDER);
              i2--;
            }
          }
        }
      }
      var template = digits.replace(new RegExp(pattern), numberFormat).replace(new RegExp(DUMMY_DIGIT, "g"), DIGIT_PLACEHOLDER);
      if (!nationalPrefixIncludedInTemplate) {
        if (complexPrefixBeforeNationalSignificantNumber) {
          template = repeat(DIGIT_PLACEHOLDER, complexPrefixBeforeNationalSignificantNumber.length) + " " + template;
        } else if (nationalPrefix) {
          template = repeat(DIGIT_PLACEHOLDER, nationalPrefix.length) + this.getSeparatorAfterNationalPrefix(format2) + template;
        }
      }
      if (international) {
        template = applyInternationalSeparatorStyle(template);
      }
      return template;
    }
  }, {
    key: "formatNextNationalNumberDigits",
    value: function formatNextNationalNumberDigits(digits) {
      var result2 = populateTemplateWithDigits(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition, digits);
      if (!result2) {
        this.resetFormat();
        return;
      }
      this.populatedNationalNumberTemplate = result2[0];
      this.populatedNationalNumberTemplatePosition = result2[1];
      return cutAndStripNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1);
    }
  }, {
    key: "shouldTryNationalPrefixFormattingRule",
    value: function shouldTryNationalPrefixFormattingRule(format2, _ref5) {
      var international = _ref5.international, nationalPrefix = _ref5.nationalPrefix;
      if (format2.nationalPrefixFormattingRule()) {
        var usesNationalPrefix = format2.usesNationalPrefix();
        if (usesNationalPrefix && nationalPrefix || !usesNationalPrefix && !international) {
          return true;
        }
      }
    }
  }]);
  return AsYouTypeFormatter2;
}();
function _slicedToArray$1(arr, i2) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i2) || _unsupportedIterableToArray$4(arr, i2) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$4(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$4(o3, minLen);
}
function _arrayLikeToArray$4(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit$1(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART = "[" + VALID_PUNCTUATION + VALID_DIGITS + "]+";
var VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN = new RegExp("^" + VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART + "$", "i");
var VALID_FORMATTED_PHONE_NUMBER_PART = "(?:[" + PLUS_CHARS + "][" + VALID_PUNCTUATION + VALID_DIGITS + "]*|[" + VALID_PUNCTUATION + VALID_DIGITS + "]+)";
var AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = new RegExp("[^" + VALID_PUNCTUATION + VALID_DIGITS + "]+.*$");
var COMPLEX_NATIONAL_PREFIX = /[^\d\[\]]/;
var AsYouTypeParser = /* @__PURE__ */ function() {
  function AsYouTypeParser2(_ref) {
    var defaultCountry = _ref.defaultCountry, defaultCallingCode = _ref.defaultCallingCode, metadata2 = _ref.metadata, onNationalSignificantNumberChange = _ref.onNationalSignificantNumberChange;
    _classCallCheck$2(this, AsYouTypeParser2);
    this.defaultCountry = defaultCountry;
    this.defaultCallingCode = defaultCallingCode;
    this.metadata = metadata2;
    this.onNationalSignificantNumberChange = onNationalSignificantNumberChange;
  }
  _createClass$2(AsYouTypeParser2, [{
    key: "input",
    value: function input(text, state) {
      var _extractFormattedDigi = extractFormattedDigitsAndPlus(text), _extractFormattedDigi2 = _slicedToArray$1(_extractFormattedDigi, 2), formattedDigits = _extractFormattedDigi2[0], hasPlus = _extractFormattedDigi2[1];
      var digits = parseDigits(formattedDigits);
      var justLeadingPlus;
      if (hasPlus) {
        if (!state.digits) {
          state.startInternationalNumber();
          if (!digits) {
            justLeadingPlus = true;
          }
        }
      }
      if (digits) {
        this.inputDigits(digits, state);
      }
      return {
        digits,
        justLeadingPlus
      };
    }
    /**
     * Inputs "next" phone number digits.
     * @param  {string} digits
     * @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means "don't format the national phone number at this stage".
     */
  }, {
    key: "inputDigits",
    value: function inputDigits(nextDigits, state) {
      var digits = state.digits;
      var hasReceivedThreeLeadingDigits = digits.length < 3 && digits.length + nextDigits.length >= 3;
      state.appendDigits(nextDigits);
      if (hasReceivedThreeLeadingDigits) {
        this.extractIddPrefix(state);
      }
      if (this.isWaitingForCountryCallingCode(state)) {
        if (!this.extractCountryCallingCode(state)) {
          return;
        }
      } else {
        state.appendNationalSignificantNumberDigits(nextDigits);
      }
      if (!state.international) {
        if (!this.hasExtractedNationalSignificantNumber) {
          this.extractNationalSignificantNumber(state.getNationalDigits(), function(stateUpdate) {
            return state.update(stateUpdate);
          });
        }
      }
    }
  }, {
    key: "isWaitingForCountryCallingCode",
    value: function isWaitingForCountryCallingCode(_ref2) {
      var international = _ref2.international, callingCode = _ref2.callingCode;
      return international && !callingCode;
    }
    // Extracts a country calling code from a number
    // being entered in internatonal format.
  }, {
    key: "extractCountryCallingCode",
    value: function extractCountryCallingCode$1(state) {
      var _extractCountryCallin = extractCountryCallingCode("+" + state.getDigitsWithoutInternationalPrefix(), this.defaultCountry, this.defaultCallingCode, this.metadata.metadata), countryCallingCode = _extractCountryCallin.countryCallingCode, number = _extractCountryCallin.number;
      if (countryCallingCode) {
        state.setCallingCode(countryCallingCode);
        state.update({
          nationalSignificantNumber: number
        });
        return true;
      }
    }
  }, {
    key: "reset",
    value: function reset(numberingPlan) {
      if (numberingPlan) {
        this.hasSelectedNumberingPlan = true;
        var nationalPrefixForParsing = numberingPlan._nationalPrefixForParsing();
        this.couldPossiblyExtractAnotherNationalSignificantNumber = nationalPrefixForParsing && COMPLEX_NATIONAL_PREFIX.test(nationalPrefixForParsing);
      } else {
        this.hasSelectedNumberingPlan = void 0;
        this.couldPossiblyExtractAnotherNationalSignificantNumber = void 0;
      }
    }
    /**
     * Extracts a national (significant) number from user input.
     * Google's library is different in that it only applies `national_prefix_for_parsing`
     * and doesn't apply `national_prefix_transform_rule` after that.
     * https://github.com/google/libphonenumber/blob/a3d70b0487875475e6ad659af404943211d26456/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L539
     * @return {boolean} [extracted]
     */
  }, {
    key: "extractNationalSignificantNumber",
    value: function extractNationalSignificantNumber(nationalDigits, setState) {
      if (!this.hasSelectedNumberingPlan) {
        return;
      }
      var _extractNationalNumbe = extractNationalNumberFromPossiblyIncompleteNumber(nationalDigits, this.metadata), nationalPrefix = _extractNationalNumbe.nationalPrefix, nationalNumber = _extractNationalNumbe.nationalNumber, carrierCode = _extractNationalNumbe.carrierCode;
      if (nationalNumber === nationalDigits) {
        return;
      }
      this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);
      return true;
    }
    /**
     * In Google's code this function is called "attempt to extract longer NDD".
     * "Some national prefixes are a substring of others", they say.
     * @return {boolean} [result] — Returns `true` if extracting a national prefix produced different results from what they were.
     */
  }, {
    key: "extractAnotherNationalSignificantNumber",
    value: function extractAnotherNationalSignificantNumber(nationalDigits, prevNationalSignificantNumber, setState) {
      if (!this.hasExtractedNationalSignificantNumber) {
        return this.extractNationalSignificantNumber(nationalDigits, setState);
      }
      if (!this.couldPossiblyExtractAnotherNationalSignificantNumber) {
        return;
      }
      var _extractNationalNumbe2 = extractNationalNumberFromPossiblyIncompleteNumber(nationalDigits, this.metadata), nationalPrefix = _extractNationalNumbe2.nationalPrefix, nationalNumber = _extractNationalNumbe2.nationalNumber, carrierCode = _extractNationalNumbe2.carrierCode;
      if (nationalNumber === prevNationalSignificantNumber) {
        return;
      }
      this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);
      return true;
    }
  }, {
    key: "onExtractedNationalNumber",
    value: function onExtractedNationalNumber(nationalPrefix, carrierCode, nationalSignificantNumber, nationalDigits, setState) {
      var complexPrefixBeforeNationalSignificantNumber;
      var nationalSignificantNumberMatchesInput;
      var nationalSignificantNumberIndex = nationalDigits.lastIndexOf(nationalSignificantNumber);
      if (nationalSignificantNumberIndex >= 0 && nationalSignificantNumberIndex === nationalDigits.length - nationalSignificantNumber.length) {
        nationalSignificantNumberMatchesInput = true;
        var prefixBeforeNationalNumber = nationalDigits.slice(0, nationalSignificantNumberIndex);
        if (prefixBeforeNationalNumber !== nationalPrefix) {
          complexPrefixBeforeNationalSignificantNumber = prefixBeforeNationalNumber;
        }
      }
      setState({
        nationalPrefix,
        carrierCode,
        nationalSignificantNumber,
        nationalSignificantNumberMatchesInput,
        complexPrefixBeforeNationalSignificantNumber
      });
      this.hasExtractedNationalSignificantNumber = true;
      this.onNationalSignificantNumberChange();
    }
  }, {
    key: "reExtractNationalSignificantNumber",
    value: function reExtractNationalSignificantNumber(state) {
      if (this.extractAnotherNationalSignificantNumber(state.getNationalDigits(), state.nationalSignificantNumber, function(stateUpdate) {
        return state.update(stateUpdate);
      })) {
        return true;
      }
      if (this.extractIddPrefix(state)) {
        this.extractCallingCodeAndNationalSignificantNumber(state);
        return true;
      }
      if (this.fixMissingPlus(state)) {
        this.extractCallingCodeAndNationalSignificantNumber(state);
        return true;
      }
    }
  }, {
    key: "extractIddPrefix",
    value: function extractIddPrefix(state) {
      var international = state.international, IDDPrefix = state.IDDPrefix, digits = state.digits;
      state.nationalSignificantNumber;
      if (international || IDDPrefix) {
        return;
      }
      var numberWithoutIDD = stripIddPrefix(digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata);
      if (numberWithoutIDD !== void 0 && numberWithoutIDD !== digits) {
        state.update({
          IDDPrefix: digits.slice(0, digits.length - numberWithoutIDD.length)
        });
        this.startInternationalNumber(state, {
          country: void 0,
          callingCode: void 0
        });
        return true;
      }
    }
  }, {
    key: "fixMissingPlus",
    value: function fixMissingPlus(state) {
      if (!state.international) {
        var _extractCountryCallin2 = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(state.digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata), newCallingCode = _extractCountryCallin2.countryCallingCode;
        _extractCountryCallin2.number;
        if (newCallingCode) {
          state.update({
            missingPlus: true
          });
          this.startInternationalNumber(state, {
            country: state.country,
            callingCode: newCallingCode
          });
          return true;
        }
      }
    }
  }, {
    key: "startInternationalNumber",
    value: function startInternationalNumber(state, _ref3) {
      var country = _ref3.country, callingCode = _ref3.callingCode;
      state.startInternationalNumber(country, callingCode);
      if (state.nationalSignificantNumber) {
        state.resetNationalSignificantNumber();
        this.onNationalSignificantNumberChange();
        this.hasExtractedNationalSignificantNumber = void 0;
      }
    }
  }, {
    key: "extractCallingCodeAndNationalSignificantNumber",
    value: function extractCallingCodeAndNationalSignificantNumber(state) {
      if (this.extractCountryCallingCode(state)) {
        this.extractNationalSignificantNumber(state.getNationalDigits(), function(stateUpdate) {
          return state.update(stateUpdate);
        });
      }
    }
  }]);
  return AsYouTypeParser2;
}();
function extractFormattedPhoneNumber(text) {
  var startsAt = text.search(VALID_FORMATTED_PHONE_NUMBER_PART);
  if (startsAt < 0) {
    return;
  }
  text = text.slice(startsAt);
  var hasPlus;
  if (text[0] === "+") {
    hasPlus = true;
    text = text.slice("+".length);
  }
  text = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, "");
  if (hasPlus) {
    text = "+" + text;
  }
  return text;
}
function _extractFormattedDigitsAndPlus(text) {
  var extractedNumber = extractFormattedPhoneNumber(text) || "";
  if (extractedNumber[0] === "+") {
    return [extractedNumber.slice("+".length), true];
  }
  return [extractedNumber];
}
function extractFormattedDigitsAndPlus(text) {
  var _extractFormattedDigi3 = _extractFormattedDigitsAndPlus(text), _extractFormattedDigi4 = _slicedToArray$1(_extractFormattedDigi3, 2), formattedDigits = _extractFormattedDigi4[0], hasPlus = _extractFormattedDigi4[1];
  if (!VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN.test(formattedDigits)) {
    formattedDigits = "";
  }
  return [formattedDigits, hasPlus];
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray$3(arr, i2) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$3(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$3(o3, minLen);
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var AsYouType = /* @__PURE__ */ function() {
  function AsYouType2(optionsOrDefaultCountry, metadata2) {
    _classCallCheck$1(this, AsYouType2);
    this.metadata = new Metadata(metadata2);
    var _this$getCountryAndCa = this.getCountryAndCallingCode(optionsOrDefaultCountry), _this$getCountryAndCa2 = _slicedToArray(_this$getCountryAndCa, 2), defaultCountry = _this$getCountryAndCa2[0], defaultCallingCode = _this$getCountryAndCa2[1];
    this.defaultCountry = defaultCountry;
    this.defaultCallingCode = defaultCallingCode;
    this.reset();
  }
  _createClass$1(AsYouType2, [{
    key: "getCountryAndCallingCode",
    value: function getCountryAndCallingCode(optionsOrDefaultCountry) {
      var defaultCountry;
      var defaultCallingCode;
      if (optionsOrDefaultCountry) {
        if (isObject(optionsOrDefaultCountry)) {
          defaultCountry = optionsOrDefaultCountry.defaultCountry;
          defaultCallingCode = optionsOrDefaultCountry.defaultCallingCode;
        } else {
          defaultCountry = optionsOrDefaultCountry;
        }
      }
      if (defaultCountry && !this.metadata.hasCountry(defaultCountry)) {
        defaultCountry = void 0;
      }
      return [defaultCountry, defaultCallingCode];
    }
    /**
     * Inputs "next" phone number characters.
     * @param  {string} text
     * @return {string} Formatted phone number characters that have been input so far.
     */
  }, {
    key: "input",
    value: function input(text) {
      var _this$parser$input = this.parser.input(text, this.state), digits = _this$parser$input.digits, justLeadingPlus = _this$parser$input.justLeadingPlus;
      if (justLeadingPlus) {
        this.formattedOutput = "+";
      } else if (digits) {
        this.determineTheCountryIfNeeded();
        if (this.state.nationalSignificantNumber) {
          this.formatter.narrowDownMatchingFormats(this.state);
        }
        var formattedNationalNumber;
        if (this.metadata.hasSelectedNumberingPlan()) {
          formattedNationalNumber = this.formatter.format(digits, this.state);
        }
        if (formattedNationalNumber === void 0) {
          if (this.parser.reExtractNationalSignificantNumber(this.state)) {
            this.determineTheCountryIfNeeded();
            var nationalDigits = this.state.getNationalDigits();
            if (nationalDigits) {
              formattedNationalNumber = this.formatter.format(nationalDigits, this.state);
            }
          }
        }
        this.formattedOutput = formattedNationalNumber ? this.getFullNumber(formattedNationalNumber) : this.getNonFormattedNumber();
      }
      return this.formattedOutput;
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this = this;
      this.state = new AsYouTypeState({
        onCountryChange: function onCountryChange(country) {
          _this.country = country;
        },
        onCallingCodeChange: function onCallingCodeChange(callingCode, country) {
          _this.metadata.selectNumberingPlan(country, callingCode);
          _this.formatter.reset(_this.metadata.numberingPlan, _this.state);
          _this.parser.reset(_this.metadata.numberingPlan);
        }
      });
      this.formatter = new AsYouTypeFormatter({
        state: this.state,
        metadata: this.metadata
      });
      this.parser = new AsYouTypeParser({
        defaultCountry: this.defaultCountry,
        defaultCallingCode: this.defaultCallingCode,
        metadata: this.metadata,
        state: this.state,
        onNationalSignificantNumberChange: function onNationalSignificantNumberChange() {
          _this.determineTheCountryIfNeeded();
          _this.formatter.reset(_this.metadata.numberingPlan, _this.state);
        }
      });
      this.state.reset({
        country: this.defaultCountry,
        callingCode: this.defaultCallingCode
      });
      this.formattedOutput = "";
      return this;
    }
    /**
     * Returns `true` if the phone number is being input in international format.
     * In other words, returns `true` if and only if the parsed phone number starts with a `"+"`.
     * @return {boolean}
     */
  }, {
    key: "isInternational",
    value: function isInternational() {
      return this.state.international;
    }
    /**
     * Returns the "calling code" part of the phone number when it's being input
     * in an international format.
     * If no valid calling code has been entered so far, returns `undefined`.
     * @return {string} [callingCode]
     */
  }, {
    key: "getCallingCode",
    value: function getCallingCode() {
      if (this.isInternational()) {
        return this.state.callingCode;
      }
    }
    // A legacy alias.
  }, {
    key: "getCountryCallingCode",
    value: function getCountryCallingCode2() {
      return this.getCallingCode();
    }
    /**
     * Returns a two-letter country code of the phone number.
     * Returns `undefined` for "non-geographic" phone numbering plans.
     * Returns `undefined` if no phone number has been input yet.
     * @return {string} [country]
     */
  }, {
    key: "getCountry",
    value: function getCountry() {
      var digits = this.state.digits;
      if (digits) {
        return this._getCountry();
      }
    }
    /**
     * Returns a two-letter country code of the phone number.
     * Returns `undefined` for "non-geographic" phone numbering plans.
     * @return {string} [country]
     */
  }, {
    key: "_getCountry",
    value: function _getCountry() {
      var country = this.state.country;
      return country;
    }
  }, {
    key: "determineTheCountryIfNeeded",
    value: function determineTheCountryIfNeeded() {
      if (!this.state.country || this.isCountryCallingCodeAmbiguous()) {
        this.determineTheCountry();
      }
    }
    // Prepends `+CountryCode ` in case of an international phone number
  }, {
    key: "getFullNumber",
    value: function getFullNumber(formattedNationalNumber) {
      var _this2 = this;
      if (this.isInternational()) {
        var prefix = function prefix2(text) {
          return _this2.formatter.getInternationalPrefixBeforeCountryCallingCode(_this2.state, {
            spacing: text ? true : false
          }) + text;
        };
        var callingCode = this.state.callingCode;
        if (!callingCode) {
          return prefix("".concat(this.state.getDigitsWithoutInternationalPrefix()));
        }
        if (!formattedNationalNumber) {
          return prefix(callingCode);
        }
        return prefix("".concat(callingCode, " ").concat(formattedNationalNumber));
      }
      return formattedNationalNumber;
    }
  }, {
    key: "getNonFormattedNationalNumberWithPrefix",
    value: function getNonFormattedNationalNumberWithPrefix() {
      var _this$state = this.state, nationalSignificantNumber = _this$state.nationalSignificantNumber, complexPrefixBeforeNationalSignificantNumber = _this$state.complexPrefixBeforeNationalSignificantNumber, nationalPrefix = _this$state.nationalPrefix;
      var number = nationalSignificantNumber;
      var prefix = complexPrefixBeforeNationalSignificantNumber || nationalPrefix;
      if (prefix) {
        number = prefix + number;
      }
      return number;
    }
  }, {
    key: "getNonFormattedNumber",
    value: function getNonFormattedNumber() {
      var nationalSignificantNumberMatchesInput = this.state.nationalSignificantNumberMatchesInput;
      return this.getFullNumber(nationalSignificantNumberMatchesInput ? this.getNonFormattedNationalNumberWithPrefix() : this.state.getNationalDigits());
    }
  }, {
    key: "getNonFormattedTemplate",
    value: function getNonFormattedTemplate() {
      var number = this.getNonFormattedNumber();
      if (number) {
        return number.replace(/[\+\d]/g, DIGIT_PLACEHOLDER);
      }
    }
  }, {
    key: "isCountryCallingCodeAmbiguous",
    value: function isCountryCallingCodeAmbiguous() {
      var callingCode = this.state.callingCode;
      var countryCodes = this.metadata.getCountryCodesForCallingCode(callingCode);
      return countryCodes && countryCodes.length > 1;
    }
    // Determines the country of the phone number
    // entered so far based on the country phone code
    // and the national phone number.
  }, {
    key: "determineTheCountry",
    value: function determineTheCountry() {
      this.state.setCountry(getCountryByCallingCode(this.isInternational() ? this.state.callingCode : this.defaultCallingCode, {
        nationalNumber: this.state.nationalSignificantNumber,
        defaultCountry: this.defaultCountry,
        metadata: this.metadata
      }));
    }
    /**
     * Returns a E.164 phone number value for the user's input.
     *
     * For example, for country `"US"` and input `"(222) 333-4444"`
     * it will return `"+12223334444"`.
     *
     * For international phone number input, it will also auto-correct
     * some minor errors such as using a national prefix when writing
     * an international phone number. For example, if the user inputs
     * `"+44 0 7400 000000"` then it will return an auto-corrected
     * `"+447400000000"` phone number value.
     *
     * Will return `undefined` if no digits have been input,
     * or when inputting a phone number in national format and no
     * default country or default "country calling code" have been set.
     *
     * @return {string} [value]
     */
  }, {
    key: "getNumberValue",
    value: function getNumberValue() {
      var _this$state2 = this.state, digits = _this$state2.digits, callingCode = _this$state2.callingCode, country = _this$state2.country, nationalSignificantNumber = _this$state2.nationalSignificantNumber;
      if (!digits) {
        return;
      }
      if (this.isInternational()) {
        if (callingCode) {
          return "+" + callingCode + nationalSignificantNumber;
        } else {
          return "+" + digits;
        }
      } else {
        if (country || callingCode) {
          var callingCode_ = country ? this.metadata.countryCallingCode() : callingCode;
          return "+" + callingCode_ + nationalSignificantNumber;
        }
      }
    }
    /**
     * Returns an instance of `PhoneNumber` class.
     * Will return `undefined` if no national (significant) number
     * digits have been entered so far, or if no `defaultCountry` has been
     * set and the user enters a phone number not in international format.
     */
  }, {
    key: "getNumber",
    value: function getNumber() {
      var _this$state3 = this.state, nationalSignificantNumber = _this$state3.nationalSignificantNumber, carrierCode = _this$state3.carrierCode, callingCode = _this$state3.callingCode;
      var country = this._getCountry();
      if (!nationalSignificantNumber) {
        return;
      }
      if (!country && !callingCode) {
        return;
      }
      if (country) {
        if (country === this.defaultCountry) {
          var metadata2 = new Metadata(this.metadata.metadata);
          metadata2.selectNumberingPlan(country);
          var _callingCode = metadata2.numberingPlan.callingCode();
          var ambiguousCountries = this.metadata.getCountryCodesForCallingCode(_callingCode);
          if (ambiguousCountries.length > 1) {
            var exactCountry = getCountryByNationalNumber(nationalSignificantNumber, {
              countries: ambiguousCountries,
              defaultCountry: this.defaultCountry,
              metadata: this.metadata.metadata
            });
            if (exactCountry) {
              country = exactCountry;
            }
          }
        }
      }
      var phoneNumber = new PhoneNumber(country || callingCode, nationalSignificantNumber, this.metadata.metadata);
      if (carrierCode) {
        phoneNumber.carrierCode = carrierCode;
      }
      return phoneNumber;
    }
    /**
     * Returns `true` if the phone number is "possible".
     * Is just a shortcut for `PhoneNumber.isPossible()`.
     * @return {boolean}
     */
  }, {
    key: "isPossible",
    value: function isPossible() {
      var phoneNumber = this.getNumber();
      if (!phoneNumber) {
        return false;
      }
      return phoneNumber.isPossible();
    }
    /**
     * Returns `true` if the phone number is "valid".
     * Is just a shortcut for `PhoneNumber.isValid()`.
     * @return {boolean}
     */
  }, {
    key: "isValid",
    value: function isValid() {
      var phoneNumber = this.getNumber();
      if (!phoneNumber) {
        return false;
      }
      return phoneNumber.isValid();
    }
    /**
     * @deprecated
     * This method is used in `react-phone-number-input/source/input-control.js`
     * in versions before `3.0.16`.
     */
  }, {
    key: "getNationalNumber",
    value: function getNationalNumber() {
      return this.state.nationalSignificantNumber;
    }
    /**
     * Returns the phone number characters entered by the user.
     * @return {string}
     */
  }, {
    key: "getChars",
    value: function getChars() {
      return (this.state.international ? "+" : "") + this.state.digits;
    }
    /**
     * Returns the template for the formatted phone number.
     * @return {string}
     */
  }, {
    key: "getTemplate",
    value: function getTemplate() {
      return this.formatter.getTemplate(this.state) || this.getNonFormattedTemplate() || "";
    }
  }]);
  return AsYouType2;
}();
function getCountries(metadata2) {
  return new Metadata(metadata2).getCountries();
}
function formatIncompletePhoneNumber(value, optionsOrDefaultCountry, metadata2) {
  if (!metadata2) {
    metadata2 = optionsOrDefaultCountry;
    optionsOrDefaultCountry = void 0;
  }
  return new AsYouType(optionsOrDefaultCountry, metadata2).input(value);
}
function getInputValuePrefix(_ref) {
  var country = _ref.country, international = _ref.international, withCountryCallingCode = _ref.withCountryCallingCode, metadata2 = _ref.metadata;
  return country && international && !withCountryCallingCode ? "+".concat(getCountryCallingCode(country, metadata2)) : "";
}
function removeInputValuePrefix(value, prefix) {
  if (prefix) {
    value = value.slice(prefix.length);
    if (value[0] === " ") {
      value = value.slice(1);
    }
  }
  return value;
}
function parsePhoneNumberCharacter_(character, prevParsedCharacters, context) {
  if (context && context.ignoreRest) {
    return;
  }
  var emitEvent = function emitEvent2(eventName) {
    if (context) {
      switch (eventName) {
        case "end":
          context.ignoreRest = true;
          break;
      }
    }
  };
  return parsePhoneNumberCharacter(character, prevParsedCharacters, emitEvent);
}
function useInputKeyDownHandler(_ref) {
  var onKeyDown2 = _ref.onKeyDown, international = _ref.international;
  return reactExports.useCallback(function(event) {
    if (event.keyCode === BACKSPACE_KEY_CODE && international) {
      if (event.target instanceof HTMLInputElement) {
        if (getCaretPosition(event.target) === AFTER_LEADING_PLUS_CARET_POSITION) {
          event.preventDefault();
          return;
        }
      }
    }
    if (onKeyDown2) {
      onKeyDown2(event);
    }
  }, [onKeyDown2, international]);
}
var BACKSPACE_KEY_CODE = 8;
function getCaretPosition(element) {
  return element.selectionStart;
}
var AFTER_LEADING_PLUS_CARET_POSITION = "+".length;
var _excluded$8 = ["onKeyDown", "country", "international", "withCountryCallingCode", "metadata"];
function _extends$7() {
  _extends$7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$7.apply(this, arguments);
}
function _objectWithoutProperties$7(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$7(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$7(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createInput$1(defaultMetadata) {
  function InputSmart2(_ref, ref) {
    var onKeyDown2 = _ref.onKeyDown, country = _ref.country, international = _ref.international, withCountryCallingCode = _ref.withCountryCallingCode, _ref$metadata = _ref.metadata, metadata2 = _ref$metadata === void 0 ? defaultMetadata : _ref$metadata, rest = _objectWithoutProperties$7(_ref, _excluded$8);
    var format2 = reactExports.useCallback(function(value) {
      var formatter = new AsYouType(country, metadata2);
      var prefix = getInputValuePrefix({
        country,
        international,
        withCountryCallingCode,
        metadata: metadata2
      });
      var text = formatter.input(prefix + value);
      var template = formatter.getTemplate();
      if (prefix) {
        text = removeInputValuePrefix(text, prefix);
        if (template) {
          template = removeInputValuePrefix(template, prefix);
        }
      }
      return {
        text,
        template
      };
    }, [country, metadata2]);
    var _onKeyDown = useInputKeyDownHandler({
      onKeyDown: onKeyDown2,
      international
    });
    return /* @__PURE__ */ React.createElement(Input$1, _extends$7({}, rest, {
      ref,
      parse: parsePhoneNumberCharacter_,
      format: format2,
      onKeyDown: _onKeyDown
    }));
  }
  InputSmart2 = /* @__PURE__ */ React.forwardRef(InputSmart2);
  InputSmart2.propTypes = {
    /**
     * The parsed phone number.
     * "Parsed" not in a sense of "E.164"
     * but rather in a sense of "having only
     * digits and possibly a leading plus character".
     * Examples: `""`, `"+"`, `"+123"`, `"123"`.
     */
    value: PropTypes.string.isRequired,
    /**
     * A function of `value: string`.
     * Updates the `value` property.
     */
    onChange: PropTypes.func.isRequired,
    /**
     * A function of `event: Event`.
     * Handles `keydown` events.
     */
    onKeyDown: PropTypes.func,
    /**
     * A two-letter country code for formatting `value`
     * as a national phone number (e.g. `(800) 555 35 35`).
     * E.g. "US", "RU", etc.
     * If no `country` is passed then `value`
     * is formatted as an international phone number.
     * (e.g. `+7 800 555 35 35`)
     * Perhaps the `country` property should have been called `defaultCountry`
     * because if `value` is an international number then `country` is ignored.
     */
    country: PropTypes.string,
    /**
     * If `country` property is passed along with `international={true}` property
     * then the phone number will be input in "international" format for that `country`
     * (without "country calling code").
     * For example, if `country="US"` property is passed to "without country select" input
     * then the phone number will be input in the "national" format for `US` (`(213) 373-4253`).
     * But if both `country="US"` and `international={true}` properties are passed then
     * the phone number will be input in the "international" format for `US` (`213 373 4253`)
     * (without "country calling code" `+1`).
     */
    international: PropTypes.bool,
    /**
     * If `country` and `international` properties are set,
     * then by default it won't include "country calling code" in the input field.
     * To change that, pass `withCountryCallingCode` property,
     * and it will include "country calling code" in the input field.
     */
    withCountryCallingCode: PropTypes.bool,
    /**
     * `libphonenumber-js` metadata.
     */
    metadata: PropTypes.object
  };
  return InputSmart2;
}
const InputSmart = createInput$1();
var _excluded$7 = ["value", "onChange", "onKeyDown", "country", "international", "withCountryCallingCode", "metadata", "inputComponent"];
function _extends$6() {
  _extends$6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$6.apply(this, arguments);
}
function _objectWithoutProperties$6(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$6(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$6(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createInput(defaultMetadata) {
  function InputBasic2(_ref, ref) {
    var value = _ref.value, onChange2 = _ref.onChange, onKeyDown2 = _ref.onKeyDown, country = _ref.country, international = _ref.international, withCountryCallingCode = _ref.withCountryCallingCode, _ref$metadata = _ref.metadata, metadata2 = _ref$metadata === void 0 ? defaultMetadata : _ref$metadata, _ref$inputComponent = _ref.inputComponent, Input2 = _ref$inputComponent === void 0 ? "input" : _ref$inputComponent, rest = _objectWithoutProperties$6(_ref, _excluded$7);
    var prefix = getInputValuePrefix({
      country,
      international,
      withCountryCallingCode,
      metadata: metadata2
    });
    var _onChange = reactExports.useCallback(function(event) {
      var newValue = parseIncompletePhoneNumber(event.target.value);
      if (newValue === value) {
        var newValueFormatted = format(prefix, newValue, country, metadata2);
        if (newValueFormatted.indexOf(event.target.value) === 0) {
          newValue = newValue.slice(0, -1);
        }
      }
      onChange2(newValue);
    }, [prefix, value, onChange2, country, metadata2]);
    var _onKeyDown = useInputKeyDownHandler({
      onKeyDown: onKeyDown2,
      international
    });
    return /* @__PURE__ */ React.createElement(Input2, _extends$6({}, rest, {
      ref,
      value: format(prefix, value, country, metadata2),
      onChange: _onChange,
      onKeyDown: _onKeyDown
    }));
  }
  InputBasic2 = /* @__PURE__ */ React.forwardRef(InputBasic2);
  InputBasic2.propTypes = {
    /**
     * The parsed phone number.
     * "Parsed" not in a sense of "E.164"
     * but rather in a sense of "having only
     * digits and possibly a leading plus character".
     * Examples: `""`, `"+"`, `"+123"`, `"123"`.
     */
    value: PropTypes.string.isRequired,
    /**
     * A function of `value: string`.
     * Updates the `value` property.
     */
    onChange: PropTypes.func.isRequired,
    /**
     * A function of `event: Event`.
     * Handles `keydown` events.
     */
    onKeyDown: PropTypes.func,
    /**
     * A two-letter country code for formatting `value`
     * as a national phone number (e.g. `(800) 555 35 35`).
     * E.g. "US", "RU", etc.
     * If no `country` is passed then `value`
     * is formatted as an international phone number.
     * (e.g. `+7 800 555 35 35`)
     * Perhaps the `country` property should have been called `defaultCountry`
     * because if `value` is an international number then `country` is ignored.
     */
    country: PropTypes.string,
    /**
     * If `country` property is passed along with `international={true}` property
     * then the phone number will be input in "international" format for that `country`
     * (without "country calling code").
     * For example, if `country="US"` property is passed to "without country select" input
     * then the phone number will be input in the "national" format for `US` (`(213) 373-4253`).
     * But if both `country="US"` and `international={true}` properties are passed then
     * the phone number will be input in the "international" format for `US` (`213 373 4253`)
     * (without "country calling code" `+1`).
     */
    international: PropTypes.bool,
    /**
     * If `country` and `international` properties are set,
     * then by default it won't include "country calling code" in the input field.
     * To change that, pass `withCountryCallingCode` property,
     * and it will include "country calling code" in the input field.
     */
    withCountryCallingCode: PropTypes.bool,
    /**
     * `libphonenumber-js` metadata.
     */
    metadata: PropTypes.object,
    /**
     * The `<input/>` component.
     */
    inputComponent: PropTypes.elementType
  };
  return InputBasic2;
}
const InputBasic = createInput();
function format(prefix, value, country, metadata2) {
  return removeInputValuePrefix(formatIncompletePhoneNumber(prefix + value, country, metadata2), prefix);
}
function getCountryFlag(country) {
  return getRegionalIndicatorSymbol(country[0]) + getRegionalIndicatorSymbol(country[1]);
}
function getRegionalIndicatorSymbol(letter) {
  return String.fromCodePoint(127462 - 65 + letter.toUpperCase().charCodeAt(0));
}
var _excluded$6 = ["value", "onChange", "options", "disabled", "readOnly"], _excluded2$1 = ["value", "options", "className", "iconComponent", "getIconAspectRatio", "arrowComponent", "unicodeFlags"];
function _createForOfIteratorHelperLoose$2(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2)
    return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray$2(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
    if (it2)
      o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length)
        return { done: true };
      return { done: false, value: o3[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$2(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$2(o3, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _extends$5() {
  _extends$5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
function _objectWithoutProperties$5(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$5(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$5(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function CountrySelect(_ref) {
  var value = _ref.value, onChange2 = _ref.onChange, options = _ref.options, disabled = _ref.disabled, readOnly = _ref.readOnly, rest = _objectWithoutProperties$5(_ref, _excluded$6);
  var onChange_ = reactExports.useCallback(function(event) {
    var value2 = event.target.value;
    onChange2(value2 === "ZZ" ? void 0 : value2);
  }, [onChange2]);
  reactExports.useMemo(function() {
    return getSelectedOption(options, value);
  }, [options, value]);
  return /* @__PURE__ */ React.createElement("select", _extends$5({}, rest, {
    disabled: disabled || readOnly,
    readOnly,
    value: value || "ZZ",
    onChange: onChange_
  }), options.map(function(_ref2) {
    var value2 = _ref2.value, label = _ref2.label, divider = _ref2.divider;
    return /* @__PURE__ */ React.createElement("option", {
      key: divider ? "|" : value2 || "ZZ",
      value: divider ? "|" : value2 || "ZZ",
      disabled: divider ? true : false,
      style: divider ? DIVIDER_STYLE : void 0
    }, label);
  }));
}
CountrySelect.propTypes = {
  /**
   * A two-letter country code.
   * Example: "US", "RU", etc.
   */
  value: PropTypes.string,
  /**
   * A function of `value: string`.
   * Updates the `value` property.
   */
  onChange: PropTypes.func.isRequired,
  // `<select/>` options.
  options: PropTypes.arrayOf(PropTypes.shape({
    value: PropTypes.string,
    label: PropTypes.string,
    divider: PropTypes.bool
  })).isRequired,
  // `readonly` attribute doesn't work on a `<select/>`.
  // https://github.com/catamphetamine/react-phone-number-input/issues/419#issuecomment-1764384480
  // https://www.delftstack.com/howto/html/html-select-readonly/
  // To work around that, if `readOnly: true` property is passed
  // to this component, it behaves analogous to `disabled: true`.
  disabled: PropTypes.bool,
  readOnly: PropTypes.bool
};
var DIVIDER_STYLE = {
  fontSize: "1px",
  backgroundColor: "currentColor",
  color: "inherit"
};
function CountrySelectWithIcon(_ref3) {
  var value = _ref3.value, options = _ref3.options, className = _ref3.className, Icon = _ref3.iconComponent;
  _ref3.getIconAspectRatio;
  var _ref3$arrowComponent = _ref3.arrowComponent, Arrow = _ref3$arrowComponent === void 0 ? DefaultArrowComponent : _ref3$arrowComponent, unicodeFlags = _ref3.unicodeFlags, rest = _objectWithoutProperties$5(_ref3, _excluded2$1);
  var selectedOption = reactExports.useMemo(function() {
    return getSelectedOption(options, value);
  }, [options, value]);
  return /* @__PURE__ */ React.createElement("div", {
    className: "PhoneInputCountry"
  }, /* @__PURE__ */ React.createElement(CountrySelect, _extends$5({}, rest, {
    value,
    options,
    className: classNames("PhoneInputCountrySelect", className)
  })), unicodeFlags && value && /* @__PURE__ */ React.createElement("div", {
    className: "PhoneInputCountryIconUnicode"
  }, getCountryFlag(value)), !(unicodeFlags && value) && /* @__PURE__ */ React.createElement(Icon, {
    "aria-hidden": true,
    country: value,
    label: selectedOption && selectedOption.label,
    aspectRatio: unicodeFlags ? 1 : void 0
  }), /* @__PURE__ */ React.createElement(Arrow, null));
}
CountrySelectWithIcon.propTypes = {
  // Country flag component.
  iconComponent: PropTypes.elementType,
  // Select arrow component.
  arrowComponent: PropTypes.elementType,
  // Set to `true` to render Unicode flag icons instead of SVG images.
  unicodeFlags: PropTypes.bool
};
function DefaultArrowComponent() {
  return /* @__PURE__ */ React.createElement("div", {
    className: "PhoneInputCountrySelectArrow"
  });
}
function getSelectedOption(options, value) {
  for (var _iterator = _createForOfIteratorHelperLoose$2(options), _step; !(_step = _iterator()).done; ) {
    var option = _step.value;
    if (!option.divider && option.value === value) {
      return option;
    }
  }
}
var _excluded$5 = ["country", "countryName", "flags", "flagUrl"];
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function _objectWithoutProperties$4(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$4(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$4(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function FlagComponent(_ref) {
  var country = _ref.country, countryName = _ref.countryName, flags = _ref.flags, flagUrl = _ref.flagUrl, rest = _objectWithoutProperties$4(_ref, _excluded$5);
  if (flags && flags[country]) {
    return flags[country]({
      title: countryName
    });
  }
  return /* @__PURE__ */ React.createElement("img", _extends$4({}, rest, {
    alt: countryName,
    role: countryName ? void 0 : "presentation",
    src: flagUrl.replace("{XX}", country).replace("{xx}", country.toLowerCase())
  }));
}
FlagComponent.propTypes = {
  // The country to be selected by default.
  // Two-letter country code ("ISO 3166-1 alpha-2").
  country: PropTypes.string.isRequired,
  // Will be HTML `title` attribute of the `<img/>`.
  countryName: PropTypes.string.isRequired,
  // Country flag icon components.
  // By default flag icons are inserted as `<img/>`s
  // with their `src` pointed to `country-flag-icons` gitlab pages website.
  // There might be cases (e.g. an offline application)
  // where having a large (3 megabyte) `<svg/>` flags
  // bundle is more appropriate.
  // `import flags from 'react-phone-number-input/flags'`.
  flags: PropTypes.objectOf(PropTypes.elementType),
  // A URL for a country flag icon.
  // By default it points to `country-flag-icons` gitlab pages website.
  flagUrl: PropTypes.string.isRequired
};
var _excluded$4 = ["aspectRatio"], _excluded2 = ["title"], _excluded3 = ["title"];
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function _objectWithoutProperties$3(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$3(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function InternationalIcon(_ref) {
  var aspectRatio = _ref.aspectRatio, rest = _objectWithoutProperties$3(_ref, _excluded$4);
  if (aspectRatio === 1) {
    return /* @__PURE__ */ React.createElement(InternationalIcon1x1, rest);
  } else {
    return /* @__PURE__ */ React.createElement(InternationalIcon3x2, rest);
  }
}
InternationalIcon.propTypes = {
  title: PropTypes.string.isRequired,
  aspectRatio: PropTypes.number
};
function InternationalIcon3x2(_ref2) {
  var title = _ref2.title, rest = _objectWithoutProperties$3(_ref2, _excluded2);
  return /* @__PURE__ */ React.createElement("svg", _extends$3({}, rest, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 75 50"
  }), /* @__PURE__ */ React.createElement("title", null, title), /* @__PURE__ */ React.createElement("g", {
    className: "PhoneInputInternationalIconGlobe",
    stroke: "currentColor",
    fill: "none",
    strokeWidth: "2",
    strokeMiterlimit: "10"
  }, /* @__PURE__ */ React.createElement("path", {
    strokeLinecap: "round",
    d: "M47.2,36.1C48.1,36,49,36,50,36c7.4,0,14,1.7,18.5,4.3"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M68.6,9.6C64.2,12.3,57.5,14,50,14c-7.4,0-14-1.7-18.5-4.3"
  }), /* @__PURE__ */ React.createElement("line", {
    x1: "26",
    y1: "25",
    x2: "74",
    y2: "25"
  }), /* @__PURE__ */ React.createElement("line", {
    x1: "50",
    y1: "1",
    x2: "50",
    y2: "49"
  }), /* @__PURE__ */ React.createElement("path", {
    strokeLinecap: "round",
    d: "M46.3,48.7c1.2,0.2,2.5,0.3,3.7,0.3c13.3,0,24-10.7,24-24S63.3,1,50,1S26,11.7,26,25c0,2,0.3,3.9,0.7,5.8"
  }), /* @__PURE__ */ React.createElement("path", {
    strokeLinecap: "round",
    d: "M46.8,48.2c1,0.6,2.1,0.8,3.2,0.8c6.6,0,12-10.7,12-24S56.6,1,50,1S38,11.7,38,25c0,1.4,0.1,2.7,0.2,4c0,0.1,0,0.2,0,0.2"
  })), /* @__PURE__ */ React.createElement("path", {
    className: "PhoneInputInternationalIconPhone",
    stroke: "none",
    fill: "currentColor",
    d: "M12.4,17.9c2.9-2.9,5.4-4.8,0.3-11.2S4.1,5.2,1.3,8.1C-2,11.4,1.1,23.5,13.1,35.6s24.3,15.2,27.5,11.9c2.8-2.8,7.8-6.3,1.4-11.5s-8.3-2.6-11.2,0.3c-2,2-7.2-2.2-11.7-6.7S10.4,19.9,12.4,17.9z"
  }));
}
InternationalIcon3x2.propTypes = {
  title: PropTypes.string.isRequired
};
function InternationalIcon1x1(_ref3) {
  var title = _ref3.title, rest = _objectWithoutProperties$3(_ref3, _excluded3);
  return /* @__PURE__ */ React.createElement("svg", _extends$3({}, rest, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 50 50"
  }), /* @__PURE__ */ React.createElement("title", null, title), /* @__PURE__ */ React.createElement("g", {
    className: "PhoneInputInternationalIconGlobe",
    stroke: "currentColor",
    fill: "none",
    strokeWidth: "2",
    strokeLinecap: "round"
  }, /* @__PURE__ */ React.createElement("path", {
    d: "M8.45,13A21.44,21.44,0,1,1,37.08,41.56"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M19.36,35.47a36.9,36.9,0,0,1-2.28-13.24C17.08,10.39,21.88.85,27.8.85s10.72,9.54,10.72,21.38c0,6.48-1.44,12.28-3.71,16.21"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M17.41,33.4A39,39,0,0,1,27.8,32.06c6.62,0,12.55,1.5,16.48,3.86"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M44.29,8.53c-3.93,2.37-9.86,3.88-16.49,3.88S15.25,10.9,11.31,8.54"
  }), /* @__PURE__ */ React.createElement("line", {
    x1: "27.8",
    y1: "0.85",
    x2: "27.8",
    y2: "34.61"
  }), /* @__PURE__ */ React.createElement("line", {
    x1: "15.2",
    y1: "22.23",
    x2: "49.15",
    y2: "22.23"
  })), /* @__PURE__ */ React.createElement("path", {
    className: "PhoneInputInternationalIconPhone",
    stroke: "transparent",
    fill: "currentColor",
    d: "M9.42,26.64c2.22-2.22,4.15-3.59.22-8.49S3.08,17,.93,19.17c-2.49,2.48-.13,11.74,9,20.89s18.41,11.5,20.89,9c2.15-2.15,5.91-4.77,1-8.71s-6.27-2-8.49.22c-1.55,1.55-5.48-1.69-8.86-5.08S7.87,28.19,9.42,26.64Z"
  }));
}
InternationalIcon1x1.propTypes = {
  title: PropTypes.string.isRequired
};
function _createForOfIteratorHelperLoose$1(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2)
    return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray$1(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
    if (it2)
      o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length)
        return { done: true };
      return { done: false, value: o3[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$1(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray$1(o3, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function sortCountryOptions(options, order) {
  if (!order) {
    return options;
  }
  var optionsOnTop = [];
  var optionsOnBottom = [];
  var appendTo = optionsOnTop;
  for (var _iterator = _createForOfIteratorHelperLoose$1(order), _step; !(_step = _iterator()).done; ) {
    var element = _step.value;
    if (element === "|") {
      appendTo.push({
        divider: true
      });
    } else if (element === "..." || element === "…") {
      appendTo = optionsOnBottom;
    } else {
      (function() {
        var countryCode = void 0;
        if (element === "🌐") {
          countryCode = void 0;
        } else {
          countryCode = element;
        }
        var index2 = options.indexOf(options.filter(function(option2) {
          return option2.value === countryCode;
        })[0]);
        var option = options[index2];
        options.splice(index2, 1);
        appendTo.push(option);
      })();
    }
  }
  return optionsOnTop.concat(options).concat(optionsOnBottom);
}
function getSupportedCountryOptions(countryOptions, metadata2) {
  if (countryOptions) {
    countryOptions = countryOptions.filter(function(option) {
      switch (option) {
        case "🌐":
        case "|":
        case "...":
        case "…":
          return true;
        default:
          return isCountrySupportedWithError(option, metadata2);
      }
    });
    if (countryOptions.length > 0) {
      return countryOptions;
    }
  }
}
function isCountrySupportedWithError(country, metadata2) {
  if (isSupportedCountry(country, metadata2)) {
    return true;
  } else {
    console.error("Country not found: ".concat(country));
    return false;
  }
}
function getSupportedCountries(countries, metadata2) {
  if (countries) {
    countries = countries.filter(function(country) {
      return isCountrySupportedWithError(country, metadata2);
    });
    if (countries.length === 0) {
      countries = void 0;
    }
  }
  return countries;
}
var _excluded$3 = ["country", "label", "aspectRatio"];
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function _objectWithoutProperties$2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$2(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createCountryIconComponent(_ref) {
  var flags = _ref.flags, flagUrl = _ref.flagUrl, FlagComponent2 = _ref.flagComponent, InternationalIcon$1 = _ref.internationalIcon;
  function CountryIcon(_ref2) {
    var country = _ref2.country, label = _ref2.label, aspectRatio = _ref2.aspectRatio, rest = _objectWithoutProperties$2(_ref2, _excluded$3);
    var _aspectRatio = InternationalIcon$1 === InternationalIcon ? aspectRatio : void 0;
    return /* @__PURE__ */ React.createElement("div", _extends$2({}, rest, {
      className: classNames("PhoneInputCountryIcon", {
        "PhoneInputCountryIcon--square": _aspectRatio === 1,
        "PhoneInputCountryIcon--border": country
      })
    }), country ? /* @__PURE__ */ React.createElement(FlagComponent2, {
      country,
      countryName: label,
      flags,
      flagUrl,
      className: "PhoneInputCountryIconImg"
    }) : /* @__PURE__ */ React.createElement(InternationalIcon$1, {
      title: label,
      aspectRatio: _aspectRatio,
      className: "PhoneInputCountryIconImg"
    }));
  }
  CountryIcon.propTypes = {
    country: PropTypes.string,
    label: PropTypes.string.isRequired,
    aspectRatio: PropTypes.number
  };
  return CountryIcon;
}
createCountryIconComponent({
  // Must be equal to `defaultProps.flagUrl` in `./PhoneInputWithCountry.js`.
  flagUrl: "https://purecatamphetamine.github.io/country-flag-icons/3x2/{XX}.svg",
  flagComponent: FlagComponent,
  internationalIcon: InternationalIcon
});
function _createForOfIteratorHelperLoose(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2)
    return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
    if (it2)
      o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length)
        return { done: true };
      return { done: false, value: o3[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor)
    n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set")
    return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
    return _arrayLikeToArray(o3, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function setRefsValue(refs, value) {
  for (var _iterator = _createForOfIteratorHelperLoose(refs), _step; !(_step = _iterator()).done; ) {
    var ref = _step.value;
    if (ref) {
      setRefValue(ref, value);
    }
  }
}
function setRefValue(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else {
    ref.current = value;
  }
}
var metadata = PropTypes.shape({
  country_calling_codes: PropTypes.object.isRequired,
  countries: PropTypes.object.isRequired
});
var labels = PropTypes.objectOf(PropTypes.string);
function getInternationalPhoneNumberPrefix(country, metadata2) {
  var prefix = "+" + getCountryCallingCode(country, metadata2);
  return prefix;
}
function getPreSelectedCountry(_ref) {
  var value = _ref.value, phoneNumber = _ref.phoneNumber, defaultCountry = _ref.defaultCountry, getAnyCountry = _ref.getAnyCountry, countries = _ref.countries, required = _ref.required, metadata2 = _ref.metadata;
  var country;
  if (phoneNumber && phoneNumber.country) {
    country = phoneNumber.country;
  } else if (defaultCountry) {
    if (!value || couldNumberBelongToCountry(value, defaultCountry, metadata2)) {
      country = defaultCountry;
    }
  }
  if (countries && countries.indexOf(country) < 0) {
    country = void 0;
  }
  if (!country && required && countries && countries.length > 0) {
    country = getAnyCountry();
  }
  return country;
}
function getCountrySelectOptions(_ref2) {
  var countries = _ref2.countries, countryNames = _ref2.countryNames, addInternationalOption = _ref2.addInternationalOption, compareStringsLocales = _ref2.compareStringsLocales, _compareStrings = _ref2.compareStrings;
  if (!_compareStrings) {
    _compareStrings = compareStrings;
  }
  var countrySelectOptions = countries.map(function(country) {
    return {
      value: country,
      // All `locale` country names included in this library
      // include all countries (this is checked at build time).
      // The only case when a country name might be missing
      // is when a developer supplies their own `labels` property.
      // To guard against such cases, a missing country name
      // is substituted by country code.
      label: countryNames[country] || country
    };
  });
  countrySelectOptions.sort(function(a3, b3) {
    return _compareStrings(a3.label, b3.label, compareStringsLocales);
  });
  if (addInternationalOption) {
    countrySelectOptions.unshift({
      label: countryNames.ZZ
    });
  }
  return countrySelectOptions;
}
function parsePhoneNumber(value, metadata2) {
  return parsePhoneNumber$1(value || "", metadata2);
}
function generateNationalNumberDigits(phoneNumber) {
  return phoneNumber.formatNational().replace(/\D/g, "");
}
function getPhoneDigitsForNewCountry(phoneDigits, _ref3) {
  var prevCountry = _ref3.prevCountry, newCountry = _ref3.newCountry, metadata2 = _ref3.metadata, useNationalFormat = _ref3.useNationalFormat;
  if (prevCountry === newCountry) {
    return phoneDigits;
  }
  if (!phoneDigits) {
    if (useNationalFormat) {
      return "";
    } else {
      if (newCountry) {
        return getInternationalPhoneNumberPrefix(newCountry, metadata2);
      }
      return "";
    }
  }
  if (newCountry) {
    if (phoneDigits[0] === "+") {
      if (useNationalFormat) {
        if (phoneDigits.indexOf("+" + getCountryCallingCode(newCountry, metadata2)) === 0) {
          return stripCountryCallingCode(phoneDigits, newCountry, metadata2);
        }
        return "";
      }
      if (prevCountry) {
        var newCountryPrefix = getInternationalPhoneNumberPrefix(newCountry, metadata2);
        if (phoneDigits.indexOf(newCountryPrefix) === 0) {
          return phoneDigits;
        } else {
          return newCountryPrefix;
        }
      } else {
        var defaultValue = getInternationalPhoneNumberPrefix(newCountry, metadata2);
        if (phoneDigits.indexOf(defaultValue) === 0) {
          return phoneDigits;
        }
        return defaultValue;
      }
    }
  } else {
    if (phoneDigits[0] !== "+") {
      return e164(phoneDigits, prevCountry, metadata2) || "";
    }
  }
  return phoneDigits;
}
function e164(number, country, metadata2) {
  if (!number) {
    return;
  }
  if (number[0] === "+") {
    if (number === "+") {
      return;
    }
    var asYouType = new AsYouType(country, metadata2);
    asYouType.input(number);
    return asYouType.getNumberValue();
  }
  if (!country) {
    return;
  }
  var partial_national_significant_number = getNationalSignificantNumberDigits(number, country, metadata2);
  return "+".concat(getCountryCallingCode(country, metadata2)).concat(partial_national_significant_number || "");
}
function trimNumber(number, country, metadata2) {
  var nationalSignificantNumberPart = getNationalSignificantNumberDigits(number, country, metadata2);
  if (nationalSignificantNumberPart) {
    var overflowDigitsCount = nationalSignificantNumberPart.length - getMaxNumberLength(country, metadata2);
    if (overflowDigitsCount > 0) {
      return number.slice(0, number.length - overflowDigitsCount);
    }
  }
  return number;
}
function getMaxNumberLength(country, metadata2) {
  metadata2 = new Metadata(metadata2);
  metadata2.selectNumberingPlan(country);
  return metadata2.numberingPlan.possibleLengths()[metadata2.numberingPlan.possibleLengths().length - 1];
}
function getCountryForPartialE164Number(partialE164Number, _ref4) {
  var country = _ref4.country, countries = _ref4.countries, required = _ref4.required, metadata2 = _ref4.metadata;
  if (partialE164Number === "+") {
    return country;
  }
  var derived_country = getCountryFromPossiblyIncompleteInternationalPhoneNumber(partialE164Number, metadata2);
  if (derived_country && (!countries || countries.indexOf(derived_country) >= 0)) {
    return derived_country;
  } else if (country && !required && !couldNumberBelongToCountry(partialE164Number, country, metadata2)) {
    return void 0;
  }
  return country;
}
function onPhoneDigitsChange(phoneDigits, _ref5) {
  var prevPhoneDigits = _ref5.prevPhoneDigits, country = _ref5.country, defaultCountry = _ref5.defaultCountry, countryRequired = _ref5.countryRequired, getAnyCountry = _ref5.getAnyCountry, countries = _ref5.countries, international = _ref5.international, limitMaxLength = _ref5.limitMaxLength, countryCallingCodeEditable = _ref5.countryCallingCodeEditable, metadata2 = _ref5.metadata;
  if (international && countryCallingCodeEditable === false) {
    if (country) {
      var prefix = getInternationalPhoneNumberPrefix(country, metadata2);
      if (phoneDigits.indexOf(prefix) !== 0) {
        var _value;
        var hasStartedTypingInNationalNumberDigitsHavingInputValueSelected = phoneDigits && phoneDigits[0] !== "+";
        if (hasStartedTypingInNationalNumberDigitsHavingInputValueSelected) {
          phoneDigits = prefix + phoneDigits;
          _value = e164(phoneDigits, country, metadata2);
        } else {
          phoneDigits = prefix;
        }
        return {
          phoneDigits,
          value: _value,
          country
        };
      }
    }
  }
  if (international === false && country && phoneDigits && phoneDigits[0] === "+") {
    phoneDigits = convertInternationalPhoneDigitsToNational(phoneDigits, country, metadata2);
  }
  if (phoneDigits && country && limitMaxLength) {
    phoneDigits = trimNumber(phoneDigits, country, metadata2);
  }
  if (phoneDigits && phoneDigits[0] !== "+" && (!country || international)) {
    phoneDigits = "+" + phoneDigits;
  }
  if (!phoneDigits && prevPhoneDigits && prevPhoneDigits[0] === "+") {
    if (international) {
      country = void 0;
    } else {
      country = defaultCountry;
    }
  }
  if (phoneDigits === "+" && prevPhoneDigits && prevPhoneDigits[0] === "+" && prevPhoneDigits.length > "+".length) {
    country = void 0;
  }
  var value;
  if (phoneDigits) {
    if (phoneDigits[0] === "+") {
      if (phoneDigits === "+") {
        value = void 0;
      } else if (country && getInternationalPhoneNumberPrefix(country, metadata2).indexOf(phoneDigits) === 0) {
        value = void 0;
      } else {
        value = e164(phoneDigits, country, metadata2);
      }
    } else {
      value = e164(phoneDigits, country, metadata2);
    }
  }
  if (value) {
    country = getCountryForPartialE164Number(value, {
      country,
      countries,
      metadata: metadata2
    });
    if (international === false && country && phoneDigits && phoneDigits[0] === "+") {
      phoneDigits = convertInternationalPhoneDigitsToNational(phoneDigits, country, metadata2);
      value = e164(phoneDigits, country, metadata2);
    }
  }
  if (!country && countryRequired) {
    country = defaultCountry || getAnyCountry();
  }
  return {
    // `phoneDigits` returned here are a "normalized" version of the original `phoneDigits`.
    // The returned `phoneDigits` shouldn't be used anywhere except for passing it as
    // `prevPhoneDigits` parameter to this same function on next input change event.
    phoneDigits,
    country,
    value
  };
}
function convertInternationalPhoneDigitsToNational(input, country, metadata2) {
  if (input.indexOf(getInternationalPhoneNumberPrefix(country, metadata2)) === 0) {
    var formatter = new AsYouType(country, metadata2);
    formatter.input(input);
    var phoneNumber = formatter.getNumber();
    if (phoneNumber) {
      return phoneNumber.formatNational().replace(/\D/g, "");
    } else {
      return "";
    }
  } else {
    return input.replace(/\D/g, "");
  }
}
function getCountryFromPossiblyIncompleteInternationalPhoneNumber(number, metadata2) {
  var formatter = new AsYouType(null, metadata2);
  formatter.input(number);
  return formatter.getCountry();
}
function compareStrings(a3, b3, locales) {
  if (String.prototype.localeCompare) {
    return a3.localeCompare(b3, locales);
  }
  return a3 < b3 ? -1 : a3 > b3 ? 1 : 0;
}
function stripCountryCallingCode(number, country, metadata2) {
  if (country) {
    var countryCallingCodePrefix = "+" + getCountryCallingCode(country, metadata2);
    if (number.length < countryCallingCodePrefix.length) {
      if (countryCallingCodePrefix.indexOf(number) === 0) {
        return "";
      }
    } else {
      if (number.indexOf(countryCallingCodePrefix) === 0) {
        return number.slice(countryCallingCodePrefix.length);
      }
    }
  }
  for (var _i = 0, _Object$keys = Object.keys(metadata2.country_calling_codes); _i < _Object$keys.length; _i++) {
    var country_calling_code = _Object$keys[_i];
    if (number.indexOf(country_calling_code) === "+".length) {
      return number.slice("+".length + country_calling_code.length);
    }
  }
  return "";
}
function getNationalSignificantNumberDigits(number, country, metadata2) {
  var formatter = new AsYouType(country, metadata2);
  formatter.input(number);
  var phoneNumber = formatter.getNumber();
  return phoneNumber && phoneNumber.nationalNumber;
}
function couldNumberBelongToCountry(number, country, metadata2) {
  var intlPhoneNumberPrefix = getInternationalPhoneNumberPrefix(country, metadata2);
  var i2 = 0;
  while (i2 < number.length && i2 < intlPhoneNumberPrefix.length) {
    if (number[i2] !== intlPhoneNumberPrefix[i2]) {
      return false;
    }
    i2++;
  }
  return true;
}
function getInitialPhoneDigits(_ref6) {
  var value = _ref6.value, phoneNumber = _ref6.phoneNumber, defaultCountry = _ref6.defaultCountry, international = _ref6.international, useNationalFormat = _ref6.useNationalFormat, metadata2 = _ref6.metadata;
  if ((international === false || useNationalFormat) && phoneNumber && phoneNumber.country) {
    return generateNationalNumberDigits(phoneNumber);
  }
  if (!value && international && defaultCountry) {
    return getInternationalPhoneNumberPrefix(defaultCountry, metadata2);
  }
  return value;
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function getPhoneInputWithCountryStateUpdateFromNewProps(props, prevProps, state) {
  var metadata2 = props.metadata, countries = props.countries, newDefaultCountry = props.defaultCountry, newValue = props.value, newReset = props.reset, international = props.international, displayInitialValueAsLocalNumber = props.displayInitialValueAsLocalNumber, initialValueFormat = props.initialValueFormat;
  var prevDefaultCountry = prevProps.defaultCountry, prevValue = prevProps.value, prevReset = prevProps.reset;
  state.country;
  var value = state.value, hasUserSelectedACountry = state.hasUserSelectedACountry;
  var _getInitialPhoneDigits = function _getInitialPhoneDigits2(parameters) {
    return getInitialPhoneDigits(_objectSpread$1(_objectSpread$1({}, parameters), {}, {
      international,
      useNationalFormat: displayInitialValueAsLocalNumber || initialValueFormat === "national",
      metadata: metadata2
    }));
  };
  if (newReset !== prevReset) {
    return {
      phoneDigits: _getInitialPhoneDigits({
        value: void 0,
        defaultCountry: newDefaultCountry
      }),
      value: void 0,
      country: newDefaultCountry,
      hasUserSelectedACountry: void 0
    };
  }
  if (newDefaultCountry !== prevDefaultCountry) {
    var isNewDefaultCountrySupported = !newDefaultCountry || isCountrySupportedWithError(newDefaultCountry, metadata2);
    var noValueHasBeenEnteredByTheUser = (
      // By default, "no value has been entered" means `value` is `undefined`.
      !value || // When `international` is `true`, and some country has been pre-selected,
      // then the `<input/>` contains a pre-filled value of `+${countryCallingCode}${leadingDigits}`,
      // so in case of `international` being `true`, "the user hasn't entered anything" situation
      // doesn't just mean `value` is `undefined`, but could also mean `value` is `+${countryCallingCode}`.
      international && value === _getInitialPhoneDigits({
        value: void 0,
        defaultCountry: prevDefaultCountry
      })
    );
    var noValueHasBeenEntered = !newValue && noValueHasBeenEnteredByTheUser;
    if (!hasUserSelectedACountry && isNewDefaultCountrySupported && noValueHasBeenEntered) {
      return {
        country: newDefaultCountry,
        // If `phoneDigits` is empty, then automatically select the new `country`
        // and set `phoneDigits` to `+{getCountryCallingCode(newCountry)}`.
        // The code assumes that "no phone number has been entered by the user",
        // and no `value` property has been passed, so the `phoneNumber` parameter
        // of `_getInitialPhoneDigits({ value, phoneNumber, ... })` is `undefined`.
        phoneDigits: _getInitialPhoneDigits({
          value: void 0,
          defaultCountry: newDefaultCountry
        }),
        // `value` is `undefined` and it stays so.
        value: void 0
      };
    }
  }
  if (!valuesAreEqual(newValue, prevValue) && !valuesAreEqual(newValue, value)) {
    var phoneNumber;
    var parsedCountry;
    if (newValue) {
      phoneNumber = parsePhoneNumber(newValue, metadata2);
      var supportedCountries = getSupportedCountries(countries, metadata2);
      if (phoneNumber && phoneNumber.country) {
        if (!supportedCountries || supportedCountries.indexOf(phoneNumber.country) >= 0) {
          parsedCountry = phoneNumber.country;
        }
      } else {
        parsedCountry = getCountryForPartialE164Number(newValue, {
          country: void 0,
          countries: supportedCountries,
          metadata: metadata2
        });
        if (!parsedCountry) {
          if (newDefaultCountry) {
            if (newValue.indexOf(getInternationalPhoneNumberPrefix(newDefaultCountry, metadata2)) === 0) {
              parsedCountry = newDefaultCountry;
            }
          }
        }
      }
    }
    var hasUserSelectedACountryUpdate;
    if (!newValue) {
      hasUserSelectedACountryUpdate = {
        hasUserSelectedACountry: void 0
      };
    }
    return _objectSpread$1(_objectSpread$1({}, hasUserSelectedACountryUpdate), {}, {
      phoneDigits: _getInitialPhoneDigits({
        phoneNumber,
        value: newValue,
        defaultCountry: newDefaultCountry
      }),
      value: newValue,
      country: newValue ? parsedCountry : newDefaultCountry
    });
  }
}
function valuesAreEqual(value1, value2) {
  if (value1 === null) {
    value1 = void 0;
  }
  if (value2 === null) {
    value2 = void 0;
  }
  return value1 === value2;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var _excluded$2 = ["name", "disabled", "readOnly", "autoComplete", "style", "className", "inputRef", "inputComponent", "numberInputProps", "smartCaret", "countrySelectComponent", "countrySelectProps", "containerComponent", "containerComponentProps", "defaultCountry", "countries", "countryOptionsOrder", "labels", "flags", "flagComponent", "flagUrl", "addInternationalOption", "internationalIcon", "displayInitialValueAsLocalNumber", "initialValueFormat", "onCountryChange", "limitMaxLength", "countryCallingCodeEditable", "focusInputOnCountrySelection", "reset", "metadata", "international", "locales"];
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _objectWithoutProperties$1(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o3, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf(o3, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result2);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf(o3) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf(o3);
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var PhoneNumberInput_ = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits(PhoneNumberInput_2, _React$PureComponent);
  var _super = _createSuper(PhoneNumberInput_2);
  function PhoneNumberInput_2(props) {
    var _this;
    _classCallCheck(this, PhoneNumberInput_2);
    _this = _super.call(this, props);
    _defineProperty$1(_assertThisInitialized(_this), "setInputRef", function(instance) {
      setRefsValue([_this.props.inputRef, _this.inputRef], instance);
    });
    _defineProperty$1(_assertThisInitialized(_this), "isCountrySupportedWithError", function(country) {
      var metadata2 = _this.props.metadata;
      return isCountrySupportedWithError(country, metadata2);
    });
    _defineProperty$1(_assertThisInitialized(_this), "onCountryChange", function(newCountry) {
      var _this$props = _this.props, international = _this$props.international, metadata2 = _this$props.metadata, onChange2 = _this$props.onChange, focusInputOnCountrySelection = _this$props.focusInputOnCountrySelection;
      var _this$state = _this.state, prevPhoneDigits = _this$state.phoneDigits, prevCountry = _this$state.country;
      var newPhoneDigits = getPhoneDigitsForNewCountry(prevPhoneDigits, {
        prevCountry,
        newCountry,
        metadata: metadata2,
        // Convert the phone number to "national" format
        // when the user changes the selected country by hand.
        useNationalFormat: !international
      });
      var newValue = e164(newPhoneDigits, newCountry, metadata2);
      if (focusInputOnCountrySelection) {
        _this.inputRef.current.focus();
      }
      _this.setState({
        country: newCountry,
        hasUserSelectedACountry: true,
        phoneDigits: newPhoneDigits,
        value: newValue
      }, function() {
        onChange2(newValue);
      });
    });
    _defineProperty$1(_assertThisInitialized(_this), "onChange", function(_phoneDigits) {
      var _this$props2 = _this.props, defaultCountry = _this$props2.defaultCountry, onChange2 = _this$props2.onChange, addInternationalOption = _this$props2.addInternationalOption, international = _this$props2.international, limitMaxLength = _this$props2.limitMaxLength, countryCallingCodeEditable = _this$props2.countryCallingCodeEditable, metadata2 = _this$props2.metadata;
      var _this$state2 = _this.state, countries = _this$state2.countries, prevPhoneDigits = _this$state2.phoneDigits, currentlySelectedCountry = _this$state2.country;
      var _onPhoneDigitsChange = onPhoneDigitsChange(_phoneDigits, {
        prevPhoneDigits,
        country: currentlySelectedCountry,
        countryRequired: !addInternationalOption,
        defaultCountry,
        getAnyCountry: function getAnyCountry() {
          return _this.getFirstSupportedCountry({
            countries
          });
        },
        countries,
        international,
        limitMaxLength,
        countryCallingCodeEditable,
        metadata: metadata2
      }), phoneDigits = _onPhoneDigitsChange.phoneDigits, country = _onPhoneDigitsChange.country, value = _onPhoneDigitsChange.value;
      var stateUpdate = {
        phoneDigits,
        value,
        country
      };
      if (countryCallingCodeEditable === false) {
        if (!value && phoneDigits === _this.state.phoneDigits) {
          stateUpdate.forceRerender = {};
        }
      }
      _this.setState(
        stateUpdate,
        // Update the new `value` property.
        // Doing it after the `state` has been updated
        // because `onChange()` will trigger `getDerivedStateFromProps()`
        // with the new `value` which will be compared to `state.value` there.
        function() {
          return onChange2(value);
        }
      );
    });
    _defineProperty$1(_assertThisInitialized(_this), "_onFocus", function() {
      return _this.setState({
        isFocused: true
      });
    });
    _defineProperty$1(_assertThisInitialized(_this), "_onBlur", function() {
      return _this.setState({
        isFocused: false
      });
    });
    _defineProperty$1(_assertThisInitialized(_this), "onFocus", function(event) {
      _this._onFocus();
      var onFocus = _this.props.onFocus;
      if (onFocus) {
        onFocus(event);
      }
    });
    _defineProperty$1(_assertThisInitialized(_this), "onBlur", function(event) {
      var onBlur = _this.props.onBlur;
      _this._onBlur();
      if (onBlur) {
        onBlur(event);
      }
    });
    _defineProperty$1(_assertThisInitialized(_this), "onCountryFocus", function(event) {
      _this._onFocus();
      var countrySelectProps = _this.props.countrySelectProps;
      if (countrySelectProps) {
        var onFocus = countrySelectProps.onFocus;
        if (onFocus) {
          onFocus(event);
        }
      }
    });
    _defineProperty$1(_assertThisInitialized(_this), "onCountryBlur", function(event) {
      _this._onBlur();
      var countrySelectProps = _this.props.countrySelectProps;
      if (countrySelectProps) {
        var onBlur = countrySelectProps.onBlur;
        if (onBlur) {
          onBlur(event);
        }
      }
    });
    _this.inputRef = /* @__PURE__ */ React.createRef();
    var _this$props3 = _this.props, _value = _this$props3.value;
    _this$props3.labels;
    var _international = _this$props3.international, _addInternationalOption = _this$props3.addInternationalOption, displayInitialValueAsLocalNumber = _this$props3.displayInitialValueAsLocalNumber, initialValueFormat = _this$props3.initialValueFormat, _metadata = _this$props3.metadata;
    var _this$props4 = _this.props, _defaultCountry = _this$props4.defaultCountry, _countries = _this$props4.countries;
    if (_defaultCountry) {
      if (!_this.isCountrySupportedWithError(_defaultCountry)) {
        _defaultCountry = void 0;
      }
    }
    _countries = getSupportedCountries(_countries, _metadata);
    var phoneNumber = parsePhoneNumber(_value, _metadata);
    _this.CountryIcon = createCountryIconComponent(_this.props);
    var preSelectedCountry = getPreSelectedCountry({
      value: _value,
      phoneNumber,
      defaultCountry: _defaultCountry,
      required: !_addInternationalOption,
      countries: _countries || getCountries(_metadata),
      getAnyCountry: function getAnyCountry() {
        return _this.getFirstSupportedCountry({
          countries: _countries
        });
      },
      metadata: _metadata
    });
    _this.state = {
      // Workaround for `this.props` inside `getDerivedStateFromProps()`.
      props: _this.props,
      // The country selected.
      country: preSelectedCountry,
      // `countries` are stored in `this.state` because they're filtered.
      // For example, a developer might theoretically pass some unsupported
      // countries as part of the `countries` property, and because of that
      // the component uses `this.state.countries` (which are filtered)
      // instead of `this.props.countries`
      // (which could potentially contain unsupported countries).
      countries: _countries,
      // `phoneDigits` state property holds non-formatted user's input.
      // The reason is that there's no way of finding out
      // in which form should `value` be displayed: international or national.
      // E.g. if `value` is `+78005553535` then it could be input
      // by a user both as `8 (800) 555-35-35` and `+7 800 555 35 35`.
      // Hence storing just `value` is not sufficient for correct formatting.
      // E.g. if a user entered `8 (800) 555-35-35`
      // then value is `+78005553535` and `phoneDigits` are `88005553535`
      // and if a user entered `+7 800 555 35 35`
      // then value is `+78005553535` and `phoneDigits` are `+78005553535`.
      phoneDigits: getInitialPhoneDigits({
        value: _value,
        phoneNumber,
        defaultCountry: _defaultCountry,
        international: _international,
        useNationalFormat: displayInitialValueAsLocalNumber || initialValueFormat === "national",
        metadata: _metadata
      }),
      // `value` property is duplicated in state.
      // The reason is that `getDerivedStateFromProps()`
      // needs this `value` to compare to the new `value` property
      // to find out if `phoneDigits` needs updating:
      // If the `value` property was changed externally
      // then it won't be equal to `state.value`
      // in which case `phoneDigits` and `country` should be updated.
      value: _value
    };
    return _this;
  }
  _createClass(PhoneNumberInput_2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var onCountryChange = this.props.onCountryChange;
      var defaultCountry = this.props.defaultCountry;
      var selectedCountry = this.state.country;
      if (onCountryChange) {
        if (defaultCountry) {
          if (!this.isCountrySupportedWithError(defaultCountry)) {
            defaultCountry = void 0;
          }
        }
        if (selectedCountry !== defaultCountry) {
          onCountryChange(selectedCountry);
        }
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var onCountryChange = this.props.onCountryChange;
      var country = this.state.country;
      if (onCountryChange && country !== prevState.country) {
        onCountryChange(country);
      }
    }
    // This function mimicks `refSetter` function returned from `useExternalRef()` hook
    // because this class-like React component can't use the `useExternalRef()` hook.
  }, {
    key: "getCountrySelectOptions",
    value: function getCountrySelectOptions$1(_ref) {
      var countries = _ref.countries;
      var _this$props5 = this.props, international = _this$props5.international, countryCallingCodeEditable = _this$props5.countryCallingCodeEditable, countryOptionsOrder = _this$props5.countryOptionsOrder, addInternationalOption = _this$props5.addInternationalOption, labels2 = _this$props5.labels, locales = _this$props5.locales, metadata2 = _this$props5.metadata;
      return this.useMemoCountrySelectOptions(function() {
        return sortCountryOptions(getCountrySelectOptions({
          countries: countries || getCountries(metadata2),
          countryNames: labels2,
          addInternationalOption: international && countryCallingCodeEditable === false ? false : addInternationalOption,
          compareStringsLocales: locales
          // compareStrings
        }), getSupportedCountryOptions(countryOptionsOrder, metadata2));
      }, [countries, countryOptionsOrder, addInternationalOption, labels2, metadata2]);
    }
  }, {
    key: "useMemoCountrySelectOptions",
    value: function useMemoCountrySelectOptions(generator, dependencies) {
      if (!this.countrySelectOptionsMemoDependencies || !areEqualArrays(dependencies, this.countrySelectOptionsMemoDependencies)) {
        this.countrySelectOptionsMemo = generator();
        this.countrySelectOptionsMemoDependencies = dependencies;
      }
      return this.countrySelectOptionsMemo;
    }
  }, {
    key: "getFirstSupportedCountry",
    value: function getFirstSupportedCountry(_ref2) {
      var countries = _ref2.countries;
      var countryOptions = this.getCountrySelectOptions({
        countries
      });
      return countryOptions[0].value;
    }
    // A shorthand for not passing `metadata` as a second argument.
  }, {
    key: "render",
    value: function render() {
      var _this$props6 = this.props, name = _this$props6.name, disabled = _this$props6.disabled, readOnly = _this$props6.readOnly, autoComplete = _this$props6.autoComplete, style = _this$props6.style, className = _this$props6.className;
      _this$props6.inputRef;
      var inputComponent = _this$props6.inputComponent, numberInputProps = _this$props6.numberInputProps, smartCaret = _this$props6.smartCaret, CountrySelectComponent = _this$props6.countrySelectComponent, countrySelectProps = _this$props6.countrySelectProps, ContainerComponent = _this$props6.containerComponent, containerComponentProps = _this$props6.containerComponentProps;
      _this$props6.defaultCountry;
      _this$props6.countries;
      _this$props6.countryOptionsOrder;
      var labels2 = _this$props6.labels;
      _this$props6.flags;
      _this$props6.flagComponent;
      _this$props6.flagUrl;
      _this$props6.addInternationalOption;
      _this$props6.internationalIcon;
      _this$props6.displayInitialValueAsLocalNumber;
      _this$props6.initialValueFormat;
      _this$props6.onCountryChange;
      _this$props6.limitMaxLength;
      _this$props6.countryCallingCodeEditable;
      _this$props6.focusInputOnCountrySelection;
      _this$props6.reset;
      var metadata2 = _this$props6.metadata, international = _this$props6.international;
      _this$props6.locales;
      var rest = _objectWithoutProperties$1(_this$props6, _excluded$2);
      var _this$state3 = this.state, country = _this$state3.country, countries = _this$state3.countries, phoneDigits = _this$state3.phoneDigits, isFocused = _this$state3.isFocused;
      var InputComponent = smartCaret ? InputSmart : InputBasic;
      var countrySelectOptions = this.getCountrySelectOptions({
        countries
      });
      return /* @__PURE__ */ React.createElement(ContainerComponent, _extends$1({
        style,
        className: classNames(className, "PhoneInput", {
          "PhoneInput--focus": isFocused,
          "PhoneInput--disabled": disabled,
          "PhoneInput--readOnly": readOnly
        })
      }, containerComponentProps), /* @__PURE__ */ React.createElement(CountrySelectComponent, _extends$1({
        name: name ? "".concat(name, "Country") : void 0,
        "aria-label": labels2.country
      }, countrySelectProps, {
        value: country,
        options: countrySelectOptions,
        onChange: this.onCountryChange,
        onFocus: this.onCountryFocus,
        onBlur: this.onCountryBlur,
        disabled: disabled || countrySelectProps && countrySelectProps.disabled,
        readOnly: readOnly || countrySelectProps && countrySelectProps.readOnly,
        iconComponent: this.CountryIcon
      })), /* @__PURE__ */ React.createElement(InputComponent, _extends$1({
        ref: this.setInputRef,
        type: "tel",
        autoComplete
      }, numberInputProps, rest, {
        international: international ? true : void 0,
        withCountryCallingCode: international ? true : void 0,
        name,
        metadata: metadata2,
        country,
        value: phoneDigits || "",
        onChange: this.onChange,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        disabled,
        readOnly,
        inputComponent,
        className: classNames("PhoneInputInput", numberInputProps && numberInputProps.className, rest.className)
      })));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: (
      // `state` holds previous props as `props`, and also:
      // * `country` — The currently selected country, e.g. `"RU"`.
      // * `value` — The currently entered phone number (E.164), e.g. `+78005553535`.
      // * `phoneDigits` — The parsed `<input/>` value, e.g. `8005553535`.
      // (and a couple of other less significant properties)
      function getDerivedStateFromProps(props, state) {
        return _objectSpread({
          // Emulate `prevProps` via `state.props`.
          props
        }, getPhoneInputWithCountryStateUpdateFromNewProps(props, state.props, state));
      }
    )
  }]);
  return PhoneNumberInput_2;
}(React.PureComponent);
var PhoneNumberInput = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  return /* @__PURE__ */ React.createElement(PhoneNumberInput_, _extends$1({}, withDefaultProps(props), {
    inputRef: ref
  }));
});
PhoneNumberInput.propTypes = {
  /**
   * Phone number in `E.164` format.
   *
   * Example:
   *
   * `"+12223333333"`
   *
   * Any "falsy" value like `undefined`, `null` or an empty string `""` is treated like "empty".
   */
  value: PropTypes.string,
  /**
   * A function of `value: string?`.
   *
   * Updates the `value` property as the user inputs a phone number.
   *
   * If the user erases the input value, the argument is `undefined`.
   */
  onChange: PropTypes.func.isRequired,
  /**
   * Toggles the `--focus` CSS class.
   * @ignore
   */
  onFocus: PropTypes.func,
  /**
   * `onBlur` is usually passed by `redux-form`.
   * @ignore
   */
  onBlur: PropTypes.func,
  /**
   * Set to `true` to mark both the phone number `<input/>`
   * and the country `<select/>` as `disabled`.
   */
  disabled: PropTypes.bool,
  /**
   * Set to `true` to mark both the phone number `<input/>`
   * and the country `<select/>` as `readonly`.
   */
  readOnly: PropTypes.bool,
  /**
   * Sets `autoComplete` property for phone number `<input/>`.
   *
   * Web browser's "autocomplete" feature
   * remembers the phone number being input
   * and can also autofill the `<input/>`
   * with previously remembered phone numbers.
   *
   * https://developers.google.com
   * /web/updates/2015/06/checkout-faster-with-autofill
   *
   * For example, can be used to turn it off:
   *
   * "So when should you use `autocomplete="off"`?
   *  One example is when you've implemented your own version
   *  of autocomplete for search. Another example is any form field
   *  where users will input and submit different kinds of information
   *  where it would not be useful to have the browser remember
   *  what was submitted previously".
   */
  // (is `"tel"` by default)
  autoComplete: PropTypes.string,
  /**
   * Set to `"national"` to show the initial `value` in
   * "national" format rather than "international".
   *
   * For example, if `initialValueFormat` is `"national"`
   * and the initial `value="+12133734253"` is passed
   * then the `<input/>` value will be `"(213) 373-4253"`.
   *
   * By default, `initialValueFormat` is `undefined`,
   * meaning that if the initial `value="+12133734253"` is passed
   * then the `<input/>` value will be `"+1 213 373 4253"`.
   *
   * The reason for such default behaviour is that
   * the newer generation grows up when there are no stationary phones
   * and therefore everyone inputs phone numbers in international format
   * in their smartphones so people gradually get more accustomed to
   * writing phone numbers in international format rather than in local format.
   * Future people won't be using "national" format, only "international".
   */
  // (is `undefined` by default)
  initialValueFormat: PropTypes.oneOf(["national"]),
  // `displayInitialValueAsLocalNumber` property has been
  // superceded by `initialValueFormat` property.
  displayInitialValueAsLocalNumber: PropTypes.bool,
  /**
   * The country to be selected by default.
   * For example, can be set after a GeoIP lookup.
   *
   * Example: `"US"`.
   */
  // A two-letter country code ("ISO 3166-1 alpha-2").
  defaultCountry: PropTypes.string,
  /**
   * If specified, only these countries will be available for selection.
   *
   * Example:
   *
   * `["RU", "UA", "KZ"]`
   */
  countries: PropTypes.arrayOf(PropTypes.string),
  /**
   * Custom country `<select/>` option names.
   * Also some labels like "ext" and country `<select/>` `aria-label`.
   *
   * Example:
   *
   * `{ "ZZ": "Международный", RU: "Россия", US: "США", ... }`
   *
   * See the `locales` directory for examples.
   */
  labels,
  /**
   * Country `<select/>` options are sorted by their labels.
   * The default sorting function uses `a.localeCompare(b, locales)`,
   * and, if that's not available, falls back to simple `a > b` / `a < b`.
   * Some languages, like Chinese, support multiple sorting variants
   * (called "collations"), and the user might prefer one or another.
   * Also, sometimes the Operating System language is not always
   * the preferred language for a person using a website or an application,
   * so there should be a way to specify custom locale.
   * This `locales` property mimicks the `locales` argument of `Intl` constructors,
   * and can be either a Unicode BCP 47 locale identifier or an array of such locale identifiers.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument
   */
  locales: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),
  /*
   * Custom country `<select/>` options sorting function.
   * The default one uses `a.localeCompare(b)`, and,
   * if that's not available, falls back to simple `a > b`/`a < b`.
   * There have been requests to add custom sorter for cases
   * like Chinese language and "pinyin" (non-default) sorting order.
   * https://stackoverflow.com/questions/22907288/chinese-sorting-by-pinyin-in-javascript-with-localecompare
  compareStrings: PropTypes.func,
   */
  /**
   * A URL template of a country flag, where
   * "{XX}" is a two-letter country code in upper case,
   * or where "{xx}" is a two-letter country code in lower case.
   * By default it points to `country-flag-icons` gitlab pages website.
   * I imagine someone might want to download those country flag icons
   * and host them on their own servers instead
   * (all flags are available in the `country-flag-icons` library).
   * There's a catch though: new countries may be added in future,
   * so when hosting country flag icons on your own server
   * one should check the `CHANGELOG.md` every time before updating this library,
   * otherwise there's a possibility that some new country flag would be missing.
   */
  flagUrl: PropTypes.string,
  /**
   * Custom country flag icon components.
   * These flags will be used instead of the default ones.
   * The the "Flags" section of the readme for more info.
   *
   * The shape is an object where keys are country codes
   * and values are flag icon components.
   * Flag icon components receive the same properties
   * as `flagComponent` (see below).
   *
   * Example:
   *
   * `{ "RU": (props) => <img src="..."/> }`
   *
   * Example:
   *
   * `import flags from 'country-flag-icons/react/3x2'`
   *
   * `import PhoneInput from 'react-phone-number-input'`
   *
   * `<PhoneInput flags={flags} .../>`
   */
  flags: PropTypes.objectOf(PropTypes.elementType),
  /**
   * Country flag icon component.
   *
   * Takes properties:
   *
   * * `country: string` — The country code.
   * * `countryName: string` — The country name.
   * * `flagUrl: string` — The `flagUrl` property (see above).
   * * `flags: object` — The `flags` property (see above).
   */
  flagComponent: PropTypes.elementType,
  /**
   * Set to `false` to remove the "International" option from country `<select/>`.
   */
  addInternationalOption: PropTypes.bool,
  /**
   * "International" icon component.
   * Should have the same aspect ratio.
   *
   * Receives properties:
   *
   * * `title: string` — "International" country option label.
   */
  internationalIcon: PropTypes.elementType,
  /**
   * Can be used to place some countries on top of the list of country `<select/>` options.
   *
   * * `"XX"` — inserts an option for "XX" country.
   * * `"🌐"` — inserts "International" option.
   * * `"|"` — inserts a separator.
   * * `"..."` — inserts options for the rest of the countries (can be omitted, in which case it will be automatically added at the end).
   *
   * Example:
   *
   * `["US", "CA", "AU", "|", "..."]`
   */
  countryOptionsOrder: PropTypes.arrayOf(PropTypes.string),
  /**
   * `<Phone/>` component CSS style object.
   */
  style: PropTypes.object,
  /**
   * `<Phone/>` component CSS class.
   */
  className: PropTypes.string,
  /**
   * Country `<select/>` component.
   *
   * Receives properties:
   *
   * * `name: string?` — HTML `name` attribute.
   * * `value: string?` — The currently selected country code.
   * * `onChange(value: string?)` — Updates the `value`.
   * * `onFocus()` — Is used to toggle the `--focus` CSS class.
   * * `onBlur()` — Is used to toggle the `--focus` CSS class.
   * * `options: object[]` — The list of all selectable countries (including "International") each being an object of shape `{ value: string?, label: string }`.
   * * `iconComponent: PropTypes.elementType` — React component that renders a country icon: `<Icon country={value}/>`. If `country` is `undefined` then it renders an "International" icon.
   * * `disabled: boolean?` — HTML `disabled` attribute.
   * * `readOnly: boolean?` — HTML `readOnly` attribute.
   * * `tabIndex: (number|string)?` — HTML `tabIndex` attribute.
   * * `className: string` — CSS class name.
   */
  countrySelectComponent: PropTypes.elementType,
  /**
   * Country `<select/>` component props.
   * Along with the usual DOM properties such as `aria-label` and `tabIndex`,
   * some custom properties are supported, such as `arrowComponent` and `unicodeFlags`.
   */
  countrySelectProps: PropTypes.object,
  /**
   * Phone number `<input/>` component.
   *
   * Receives properties:
   *
   * * `value: string` — The formatted `value`.
   * * `onChange(event: Event)` — Updates the formatted `value` from `event.target.value`.
   * * `onFocus()` — Is used to toggle the `--focus` CSS class.
   * * `onBlur()` — Is used to toggle the `--focus` CSS class.
   * * Other properties like `type="tel"` or `autoComplete="tel"` that should be passed through to the DOM `<input/>`.
   *
   * Must also either use `React.forwardRef()` to "forward" `ref` to the `<input/>` or implement `.focus()` method.
   */
  inputComponent: PropTypes.elementType,
  /**
   * Phone number `<input/>` component props.
   */
  numberInputProps: PropTypes.object,
  /**
   * Wrapping `<div/>` component.
   *
   * Receives properties:
   *
   * * `style: object` — A component CSS style object.
   * * `className: string` — Classes to attach to the component, typically changes when component focuses or blurs.
   */
  containerComponent: PropTypes.elementType,
  /**
   * Wrapping `<div/>` component props.
   */
  containerComponentProps: PropTypes.object,
  /**
   * When the user attempts to insert a digit somewhere in the middle of a phone number,
   * the caret position is moved right before the next available digit skipping
   * any punctuation in between. This is called "smart" caret positioning.
   * Another case would be the phone number format changing as a result of
   * the user inserting the digit somewhere in the middle, which would require
   * re-positioning the caret because all digit positions have changed.
   * This "smart" caret positioning feature can be turned off by passing
   * `smartCaret={false}` property: use it in case of any possible issues
   * with caret position during phone number input.
   */
  // Is `true` by default.
  smartCaret: PropTypes.bool,
  /**
   * Set to `true` to force "international" phone number format.
   * Set to `false` to force "national" phone number format.
   * By default it's `undefined` meaning that it doesn't enforce any phone number format.
   */
  international: PropTypes.bool,
  /**
   * If set to `true`, the phone number input will get trimmed
   * if it exceeds the maximum length for the country.
   */
  limitMaxLength: PropTypes.bool,
  /**
   * If set to `false`, and `international` is `true`, then
   * users won't be able to erase the "country calling part"
   * of a phone number in the `<input/>`.
   */
  countryCallingCodeEditable: PropTypes.bool,
  /**
   * `libphonenumber-js` metadata.
   *
   * Can be used to pass custom `libphonenumber-js` metadata
   * to reduce the overall bundle size for those who compile "custom" metadata.
   */
  metadata,
  /**
   * Is called every time the selected country changes:
   * either programmatically or when user selects it manually from the list.
   */
  // People have been asking for a way to get the selected country.
  // @see  https://github.com/catamphetamine/react-phone-number-input/issues/128
  // For some it's just a "business requirement".
  // I guess it's about gathering as much info on the user as a website can
  // without introducing any addional fields that would complicate the form
  // therefore reducing "conversion" (that's a marketing term).
  // Assuming that the phone number's country is the user's country
  // is not 100% correct but in most cases I guess it's valid.
  onCountryChange: PropTypes.func,
  /**
   * If set to `false`, will not focus the `<input/>` component
   * when the user selects a country from the list of countries.
   * This can be used to conform to the Web Content Accessibility Guidelines (WCAG).
   * Quote:
   * "On input: Changing the setting of any user interface component
   *  does not automatically cause a change of context unless the user
   *  has been advised of the behaviour before using the component."
   */
  focusInputOnCountrySelection: PropTypes.bool
};
var defaultProps = {
  /**
   * Remember (and autofill) the value as a phone number.
   */
  autoComplete: "tel",
  /**
   * Country `<select/>` component.
   */
  countrySelectComponent: CountrySelectWithIcon,
  /**
   * Flag icon component.
   */
  flagComponent: FlagComponent,
  /**
   * By default, uses icons from `country-flag-icons` gitlab pages website.
   */
  // Must be equal to `flagUrl` in `./CountryIcon.js`.
  flagUrl: "https://purecatamphetamine.github.io/country-flag-icons/3x2/{XX}.svg",
  /**
   * Default "International" country `<select/>` option icon.
   */
  internationalIcon: InternationalIcon,
  /**
   * Phone number `<input/>` component.
   */
  inputComponent: "input",
  /**
   * Wrapping `<div/>` component.
   */
  containerComponent: "div",
  /**
   * Some users requested a way to reset the component:
   * both number `<input/>` and country `<select/>`.
   * Whenever `reset` property changes both number `<input/>`
   * and country `<select/>` are reset.
   * It's not implemented as some instance `.reset()` method
   * because `ref` is forwarded to `<input/>`.
   * It's also not replaced with just resetting `country` on
   * external `value` reset, because a user could select a country
   * and then not input any `value`, and so the selected country
   * would be "stuck", if not using this `reset` property.
   */
  // https://github.com/catamphetamine/react-phone-number-input/issues/300
  reset: PropTypes.any,
  /**
   *
   */
  /**
   * Set to `false` to use "basic" caret instead of the "smart" one.
   */
  smartCaret: true,
  /**
   * Whether to add the "International" option
   * to the list of countries.
   */
  addInternationalOption: true,
  /**
   * If set to `false`, and `international` is `true`, then
   * users won't be able to erase the "country calling part"
   * of a phone number in the `<input/>`.
   */
  countryCallingCodeEditable: true,
  /**
   * If set to `false`, will not focus the `<input/>` component
   * when the user selects a country from the list of countries.
   * This can be used to conform to the Web Content Accessibility Guidelines (WCAG).
   * Quote:
   * "On input: Changing the setting of any user interface component
   *  does not automatically cause a change of context unless the user
   *  has been advised of the behaviour before using the component."
   */
  focusInputOnCountrySelection: true
};
function withDefaultProps(props) {
  props = _objectSpread({}, props);
  for (var key in defaultProps) {
    if (props[key] === void 0) {
      props[key] = defaultProps[key];
    }
  }
  return props;
}
const PhoneInput$1 = PhoneNumberInput;
function areEqualArrays(a3, b3) {
  if (a3.length !== b3.length) {
    return false;
  }
  var i2 = 0;
  while (i2 < a3.length) {
    if (a3[i2] !== b3[i2]) {
      return false;
    }
    i2++;
  }
  return true;
}
const defaultLabels = {
  "ext": "ext.",
  "country": "Phone number country",
  "phone": "Phone",
  "AB": "Abkhazia",
  "AC": "Ascension Island",
  "AD": "Andorra",
  "AE": "United Arab Emirates",
  "AF": "Afghanistan",
  "AG": "Antigua and Barbuda",
  "AI": "Anguilla",
  "AL": "Albania",
  "AM": "Armenia",
  "AO": "Angola",
  "AQ": "Antarctica",
  "AR": "Argentina",
  "AS": "American Samoa",
  "AT": "Austria",
  "AU": "Australia",
  "AW": "Aruba",
  "AX": "Åland Islands",
  "AZ": "Azerbaijan",
  "BA": "Bosnia and Herzegovina",
  "BB": "Barbados",
  "BD": "Bangladesh",
  "BE": "Belgium",
  "BF": "Burkina Faso",
  "BG": "Bulgaria",
  "BH": "Bahrain",
  "BI": "Burundi",
  "BJ": "Benin",
  "BL": "Saint Barthélemy",
  "BM": "Bermuda",
  "BN": "Brunei Darussalam",
  "BO": "Bolivia",
  "BQ": "Bonaire, Sint Eustatius and Saba",
  "BR": "Brazil",
  "BS": "Bahamas",
  "BT": "Bhutan",
  "BV": "Bouvet Island",
  "BW": "Botswana",
  "BY": "Belarus",
  "BZ": "Belize",
  "CA": "Canada",
  "CC": "Cocos (Keeling) Islands",
  "CD": "Congo, Democratic Republic of the",
  "CF": "Central African Republic",
  "CG": "Congo",
  "CH": "Switzerland",
  "CI": "Cote d'Ivoire",
  "CK": "Cook Islands",
  "CL": "Chile",
  "CM": "Cameroon",
  "CN": "China",
  "CO": "Colombia",
  "CR": "Costa Rica",
  "CU": "Cuba",
  "CV": "Cape Verde",
  "CW": "Curaçao",
  "CX": "Christmas Island",
  "CY": "Cyprus",
  "CZ": "Czech Republic",
  "DE": "Germany",
  "DJ": "Djibouti",
  "DK": "Denmark",
  "DM": "Dominica",
  "DO": "Dominican Republic",
  "DZ": "Algeria",
  "EC": "Ecuador",
  "EE": "Estonia",
  "EG": "Egypt",
  "EH": "Western Sahara",
  "ER": "Eritrea",
  "ES": "Spain",
  "ET": "Ethiopia",
  "FI": "Finland",
  "FJ": "Fiji",
  "FK": "Falkland Islands",
  "FM": "Federated States of Micronesia",
  "FO": "Faroe Islands",
  "FR": "France",
  "GA": "Gabon",
  "GB": "United Kingdom",
  "GD": "Grenada",
  "GE": "Georgia",
  "GF": "French Guiana",
  "GG": "Guernsey",
  "GH": "Ghana",
  "GI": "Gibraltar",
  "GL": "Greenland",
  "GM": "Gambia",
  "GN": "Guinea",
  "GP": "Guadeloupe",
  "GQ": "Equatorial Guinea",
  "GR": "Greece",
  "GS": "South Georgia and the South Sandwich Islands",
  "GT": "Guatemala",
  "GU": "Guam",
  "GW": "Guinea-Bissau",
  "GY": "Guyana",
  "HK": "Hong Kong",
  "HM": "Heard Island and McDonald Islands",
  "HN": "Honduras",
  "HR": "Croatia",
  "HT": "Haiti",
  "HU": "Hungary",
  "ID": "Indonesia",
  "IE": "Ireland",
  "IL": "Israel",
  "IM": "Isle of Man",
  "IN": "India",
  "IO": "British Indian Ocean Territory",
  "IQ": "Iraq",
  "IR": "Iran",
  "IS": "Iceland",
  "IT": "Italy",
  "JE": "Jersey",
  "JM": "Jamaica",
  "JO": "Jordan",
  "JP": "Japan",
  "KE": "Kenya",
  "KG": "Kyrgyzstan",
  "KH": "Cambodia",
  "KI": "Kiribati",
  "KM": "Comoros",
  "KN": "Saint Kitts and Nevis",
  "KP": "North Korea",
  "KR": "South Korea",
  "KW": "Kuwait",
  "KY": "Cayman Islands",
  "KZ": "Kazakhstan",
  "LA": "Laos",
  "LB": "Lebanon",
  "LC": "Saint Lucia",
  "LI": "Liechtenstein",
  "LK": "Sri Lanka",
  "LR": "Liberia",
  "LS": "Lesotho",
  "LT": "Lithuania",
  "LU": "Luxembourg",
  "LV": "Latvia",
  "LY": "Libya",
  "MA": "Morocco",
  "MC": "Monaco",
  "MD": "Moldova",
  "ME": "Montenegro",
  "MF": "Saint Martin (French Part)",
  "MG": "Madagascar",
  "MH": "Marshall Islands",
  "MK": "North Macedonia",
  "ML": "Mali",
  "MM": "Myanmar",
  "MN": "Mongolia",
  "MO": "Macao",
  "MP": "Northern Mariana Islands",
  "MQ": "Martinique",
  "MR": "Mauritania",
  "MS": "Montserrat",
  "MT": "Malta",
  "MU": "Mauritius",
  "MV": "Maldives",
  "MW": "Malawi",
  "MX": "Mexico",
  "MY": "Malaysia",
  "MZ": "Mozambique",
  "NA": "Namibia",
  "NC": "New Caledonia",
  "NE": "Niger",
  "NF": "Norfolk Island",
  "NG": "Nigeria",
  "NI": "Nicaragua",
  "NL": "Netherlands",
  "NO": "Norway",
  "NP": "Nepal",
  "NR": "Nauru",
  "NU": "Niue",
  "NZ": "New Zealand",
  "OM": "Oman",
  "OS": "South Ossetia",
  "PA": "Panama",
  "PE": "Peru",
  "PF": "French Polynesia",
  "PG": "Papua New Guinea",
  "PH": "Philippines",
  "PK": "Pakistan",
  "PL": "Poland",
  "PM": "Saint Pierre and Miquelon",
  "PN": "Pitcairn",
  "PR": "Puerto Rico",
  "PS": "Palestine",
  "PT": "Portugal",
  "PW": "Palau",
  "PY": "Paraguay",
  "QA": "Qatar",
  "RE": "Reunion",
  "RO": "Romania",
  "RS": "Serbia",
  "RU": "Russia",
  "RW": "Rwanda",
  "SA": "Saudi Arabia",
  "SB": "Solomon Islands",
  "SC": "Seychelles",
  "SD": "Sudan",
  "SE": "Sweden",
  "SG": "Singapore",
  "SH": "Saint Helena",
  "SI": "Slovenia",
  "SJ": "Svalbard and Jan Mayen",
  "SK": "Slovakia",
  "SL": "Sierra Leone",
  "SM": "San Marino",
  "SN": "Senegal",
  "SO": "Somalia",
  "SR": "Suriname",
  "SS": "South Sudan",
  "ST": "Sao Tome and Principe",
  "SV": "El Salvador",
  "SX": "Sint Maarten",
  "SY": "Syria",
  "SZ": "Swaziland",
  "TA": "Tristan da Cunha",
  "TC": "Turks and Caicos Islands",
  "TD": "Chad",
  "TF": "French Southern Territories",
  "TG": "Togo",
  "TH": "Thailand",
  "TJ": "Tajikistan",
  "TK": "Tokelau",
  "TL": "Timor-Leste",
  "TM": "Turkmenistan",
  "TN": "Tunisia",
  "TO": "Tonga",
  "TR": "Turkey",
  "TT": "Trinidad and Tobago",
  "TV": "Tuvalu",
  "TW": "Taiwan",
  "TZ": "Tanzania",
  "UA": "Ukraine",
  "UG": "Uganda",
  "UM": "United States Minor Outlying Islands",
  "US": "United States",
  "UY": "Uruguay",
  "UZ": "Uzbekistan",
  "VA": "Holy See (Vatican City State)",
  "VC": "Saint Vincent and the Grenadines",
  "VE": "Venezuela",
  "VG": "Virgin Islands, British",
  "VI": "Virgin Islands, U.S.",
  "VN": "Vietnam",
  "VU": "Vanuatu",
  "WF": "Wallis and Futuna",
  "WS": "Samoa",
  "XK": "Kosovo",
  "YE": "Yemen",
  "YT": "Mayotte",
  "ZA": "South Africa",
  "ZM": "Zambia",
  "ZW": "Zimbabwe",
  "ZZ": "International"
};
var _excluded$1 = ["metadata", "labels"];
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createPhoneInput(defaultMetadata) {
  var PhoneInputDefault = /* @__PURE__ */ React.forwardRef(function(_ref, ref) {
    var _ref$metadata = _ref.metadata, metadata2 = _ref$metadata === void 0 ? defaultMetadata : _ref$metadata, _ref$labels = _ref.labels, labels2 = _ref$labels === void 0 ? defaultLabels : _ref$labels, rest = _objectWithoutProperties(_ref, _excluded$1);
    return /* @__PURE__ */ React.createElement(PhoneInput$1, _extends({}, rest, {
      ref,
      metadata: metadata2,
      labels: labels2
    }));
  });
  PhoneInputDefault.propTypes = {
    metadata,
    labels
  };
  return PhoneInputDefault;
}
createPhoneInput();
const PhoneInputComponent = createPhoneInput(metadata$1);
const phone = "";
const PhoneInput = reactExports.forwardRef(function PhoneInput2({ className = "", isFocused = false, ...props }, ref) {
  var _a, _b;
  const input = ref ? ref : reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (isFocused && input.current) {
      input.current.focus();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    PhoneInputComponent,
    {
      className: "border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5 mt-1 " + className,
      onChange: (e2) => props.onChange && props.onChange(e2),
      defaultCountry: ((_a = props == null ? void 0 : props.config) == null ? void 0 : _a.defaultCountry) ? (_b = props == null ? void 0 : props.config) == null ? void 0 : _b.defaultCountry : "PK"
    }
  );
});
function CheckIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ reactExports.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ reactExports.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ reactExports.createElement("path", {
    fillRule: "evenodd",
    d: "M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$1 = reactExports.forwardRef(CheckIcon);
const CheckIcon$1 = ForwardRef$1;
function ChevronUpDownIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ reactExports.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ reactExports.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ reactExports.createElement("path", {
    fillRule: "evenodd",
    d: "M10.53 3.47a.75.75 0 0 0-1.06 0L6.22 6.72a.75.75 0 0 0 1.06 1.06L10 5.06l2.72 2.72a.75.75 0 1 0 1.06-1.06l-3.25-3.25Zm-4.31 9.81 3.25 3.25a.75.75 0 0 0 1.06 0l3.25-3.25a.75.75 0 1 0-1.06-1.06L10 14.94l-2.72-2.72a.75.75 0 0 0-1.06 1.06Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef = reactExports.forwardRef(ChevronUpDownIcon);
const ChevronUpDownIcon$1 = ForwardRef;
const TagsInput = reactExports.forwardRef(function TagsInput2({ map, className = "", isFocused = false, options = [], ...props }, ref) {
  const input = ref ? ref : reactExports.useRef(null);
  const [tags, setTags] = reactExports.useState([]);
  const [tag, setTag] = reactExports.useState("");
  const filteredOption = tag === "" ? options : options.filter((option) => {
    return option.toLowerCase().includes(tag.toLowerCase());
  });
  reactExports.useEffect(() => {
    if (isFocused) {
      input.current.focus();
    }
  }, []);
  const watchWords = (e2) => {
    e2.preventDefault();
    if (e2.keyCode == 188 || e2.keyCode == 13) {
      if (!tags.includes(tag)) {
        setTags([...tags, tag]);
      }
      setTag("");
      return false;
    }
    if (e2.keyCode < 12)
      return false;
    if (e2.keyCode > 13 && e2.keyCode < 48)
      return false;
    if (e2.keyCode > 111 && e2.keyCode < 188)
      return false;
    setTag(tag + e2.key);
    props.handleInputChange(tag);
  };
  const setSelectedTag = () => {
    if (!tags.includes(tag)) {
      setTags([...tags, tag]);
    }
    setTag("");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ht$1, { value: tag, onChange: setSelectedTag, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative mt-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full cursor-default overflow-hidden rounded-lg bg-white text-left shadow-md focus:outline-none focus-visible:ring-2 focus-visible:ring-white/75 focus-visible:ring-offset-2 focus-visible:ring-offset-teal-300 sm:text-sm", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ht$1.Input,
          {
            className: "w-full border-none py-2 pl-3 pr-10 text-sm leading-5 text-gray-900 focus:ring-0",
            onKeyUp: (e2) => watchWords(e2)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ht$1.Button, { className: "absolute inset-y-0 right-0 flex items-center pr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ChevronUpDownIcon$1,
          {
            className: "h-5 w-5 text-gray-400",
            "aria-hidden": "true"
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Ke$1,
        {
          as: reactExports.Fragment,
          leave: "transition ease-in duration-100",
          leaveFrom: "opacity-100",
          leaveTo: "opacity-0",
          afterLeave: () => setTag(""),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ht$1.Options, { className: "absolute mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-black/5 focus:outline-none sm:text-sm", children: filteredOption.length === 0 && tag !== "" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative cursor-default select-none py-2 px-4 text-gray-700", children: [
            'Press "," to create "',
            tag,
            '"'
          ] }) : filteredOption.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            ht$1.Option,
            {
              className: ({ active }) => `relative cursor-default select-none py-2 pl-10 pr-4 ${active ? "bg-teal-600 text-white" : "text-gray-900"}`,
              value: option,
              children: ({ selected, active }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    className: `block truncate ${selected ? "font-medium" : "font-normal"}`,
                    children: option
                  }
                ),
                selected ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    className: `absolute inset-y-0 left-0 flex items-center pl-3 ${active ? "text-white" : "text-teal-600"}`,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon$1, { className: "h-5 w-5", "aria-hidden": "true" })
                  }
                ) : null
              ] })
            },
            option
          )) })
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: tags.map((element) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline mr-2 px-2 py-1.5 border rounded-sm", children: element });
    }) })
  ] });
});
const SelectInput = reactExports.forwardRef(function SelectInput2({ map, options, className = "", value, isFocused = false, placeholder = "", ...props }, ref) {
  const input = ref ? ref : reactExports.useRef();
  reactExports.useEffect(() => {
    if (isFocused) {
      input.current.focus();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "select",
    {
      className: "w-full flex bg-white border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm " + className,
      defaultValue: value,
      name: map,
      onChange: (e2) => props.onChange && props.onChange(e2),
      onBlur: (e2) => props.onBlur && props.onBlur(e2),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: placeholder }),
        options.map((option, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { selected: value === option.value, value: option.value, children: option.label }, index2))
      ]
    }
  );
});
function Checkbox({ name, label, className = "", ...props }) {
  const [checked, setChecked] = reactExports.useState(props.value || false);
  const handleChange = () => {
    setChecked(!checked);
    props.onChange(!checked);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center", htmlFor: name, onClick: handleChange, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        checked,
        onChange: handleChange,
        name,
        type: "checkbox",
        className: "rounded border-gray-300 text-indigo-600 shadow-sm focus:ring-indigo-500 " + className
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 text-sm text-gray-600", children: label })
  ] });
}
const TextareaInput = reactExports.forwardRef(function TextareaInput2({ map, className = "", isFocused = false, ...props }, ref) {
  const input = ref ? ref : reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (isFocused) {
      input.current.focus();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "textarea",
    {
      name: map,
      onChange: (e2) => props.onChange && props.onChange(e2),
      onBlur: (e2) => props.onBlur && props.onBlur(e2),
      className: "border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5 " + className,
      ref: input
    }
  );
});
const AddressInput = reactExports.forwardRef(function AddressInput2({ className = "", isFocused = false, onChange: onChange2, onBlur }, ref) {
  const input = ref ? ref : reactExports.useRef();
  reactExports.useEffect(() => {
    if (isFocused) {
      input.current.focus();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "text",
      onChange: (e2) => onChange2(e2),
      onBlur: (e2) => onBlur(e2),
      className: "border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5 " + className,
      ref: input
    }
  );
});
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s4, i2 = 1, n3 = arguments.length; i2 < n3; i2++) {
      s4 = arguments[i2];
      for (var p2 in s4)
        if (Object.prototype.hasOwnProperty.call(s4, p2))
          t2[p2] = s4[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s4, e2) {
  var t2 = {};
  for (var p2 in s4)
    if (Object.prototype.hasOwnProperty.call(s4, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s4[p2];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s4); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p2[i2]))
        t2[p2[i2]] = s4[p2[i2]];
    }
  return t2;
}
function __spreadArray(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to2.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
var escapeRegExp = function(stringToGoIntoTheRegex) {
  return stringToGoIntoTheRegex.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
};
var abbrMap = { k: 1e3, m: 1e6, b: 1e9 };
var parseAbbrValue = function(value, decimalSeparator) {
  if (decimalSeparator === void 0) {
    decimalSeparator = ".";
  }
  var reg = new RegExp("(\\d+(".concat(escapeRegExp(decimalSeparator), "\\d*)?)([kmb])$"), "i");
  var match = value.match(reg);
  if (match) {
    var digits = match[1], abbr = match[3];
    var multiplier = abbrMap[abbr.toLowerCase()];
    return Number(digits.replace(decimalSeparator, ".")) * multiplier;
  }
  return void 0;
};
var removeSeparators = function(value, separator) {
  if (separator === void 0) {
    separator = ",";
  }
  var reg = new RegExp(escapeRegExp(separator), "g");
  return value.replace(reg, "");
};
var removeInvalidChars = function(value, validChars) {
  var chars = escapeRegExp(validChars.join(""));
  var reg = new RegExp("[^\\d".concat(chars, "]"), "gi");
  return value.replace(reg, "");
};
var cleanValue = function(_a) {
  var value = _a.value, _b = _a.groupSeparator, groupSeparator = _b === void 0 ? "," : _b, _c = _a.decimalSeparator, decimalSeparator = _c === void 0 ? "." : _c, _d = _a.allowDecimals, allowDecimals = _d === void 0 ? true : _d, _e2 = _a.decimalsLimit, decimalsLimit = _e2 === void 0 ? 2 : _e2, _f = _a.allowNegativeValue, allowNegativeValue = _f === void 0 ? true : _f, _g = _a.disableAbbreviations, disableAbbreviations = _g === void 0 ? false : _g, _h = _a.prefix, prefix = _h === void 0 ? "" : _h, _j = _a.transformRawValue, transformRawValue = _j === void 0 ? function(rawValue) {
    return rawValue;
  } : _j;
  var transformedValue = transformRawValue(value);
  if (transformedValue === "-") {
    return transformedValue;
  }
  var abbreviations = disableAbbreviations ? [] : ["k", "m", "b"];
  var reg = new RegExp("((^|\\D)-\\d)|(-".concat(escapeRegExp(prefix), ")"));
  var isNegative = reg.test(transformedValue);
  var _k = RegExp("(\\d+)-?".concat(escapeRegExp(prefix))).exec(value) || [], prefixWithValue = _k[0], preValue = _k[1];
  var withoutPrefix = prefix ? prefixWithValue ? transformedValue.replace(prefixWithValue, "").concat(preValue) : transformedValue.replace(prefix, "") : transformedValue;
  var withoutSeparators = removeSeparators(withoutPrefix, groupSeparator);
  var withoutInvalidChars = removeInvalidChars(withoutSeparators, __spreadArray([
    groupSeparator,
    decimalSeparator
  ], abbreviations, true));
  var valueOnly = withoutInvalidChars;
  if (!disableAbbreviations) {
    if (abbreviations.some(function(letter) {
      return letter === withoutInvalidChars.toLowerCase().replace(decimalSeparator, "");
    })) {
      return "";
    }
    var parsed = parseAbbrValue(withoutInvalidChars, decimalSeparator);
    if (parsed) {
      valueOnly = String(parsed);
    }
  }
  var includeNegative = isNegative && allowNegativeValue ? "-" : "";
  if (decimalSeparator && valueOnly.includes(decimalSeparator)) {
    var _l = withoutInvalidChars.split(decimalSeparator), int = _l[0], decimals = _l[1];
    var trimmedDecimals = decimalsLimit && decimals ? decimals.slice(0, decimalsLimit) : decimals;
    var includeDecimals = allowDecimals ? "".concat(decimalSeparator).concat(trimmedDecimals) : "";
    return "".concat(includeNegative).concat(int).concat(includeDecimals);
  }
  return "".concat(includeNegative).concat(valueOnly);
};
var fixedDecimalValue = function(value, decimalSeparator, fixedDecimalLength) {
  if (fixedDecimalLength !== void 0 && value.length > 1) {
    if (fixedDecimalLength === 0) {
      return value.replace(decimalSeparator, "");
    }
    if (value.includes(decimalSeparator)) {
      var _a = value.split(decimalSeparator), int = _a[0], decimals = _a[1];
      if (decimals.length === fixedDecimalLength) {
        return value;
      }
      if (decimals.length > fixedDecimalLength) {
        return "".concat(int).concat(decimalSeparator).concat(decimals.slice(0, fixedDecimalLength));
      }
    }
    var reg = value.length > fixedDecimalLength ? new RegExp("(\\d+)(\\d{".concat(fixedDecimalLength, "})")) : new RegExp("(\\d)(\\d+)");
    var match = value.match(reg);
    if (match) {
      var int = match[1], decimals = match[2];
      return "".concat(int).concat(decimalSeparator).concat(decimals);
    }
  }
  return value;
};
var getSuffix = function(value, _a) {
  var _b = _a.groupSeparator, groupSeparator = _b === void 0 ? "," : _b, _c = _a.decimalSeparator, decimalSeparator = _c === void 0 ? "." : _c;
  var suffixReg = new RegExp("\\d([^".concat(escapeRegExp(groupSeparator)).concat(escapeRegExp(decimalSeparator), "0-9]+)"));
  var suffixMatch = value.match(suffixReg);
  return suffixMatch ? suffixMatch[1] : void 0;
};
var formatValue = function(options) {
  var _value = options.value, decimalSeparator = options.decimalSeparator, intlConfig = options.intlConfig, decimalScale = options.decimalScale, _a = options.prefix, prefix = _a === void 0 ? "" : _a, _b = options.suffix, suffix = _b === void 0 ? "" : _b;
  if (_value === "" || _value === void 0) {
    return "";
  }
  if (_value === "-") {
    return "-";
  }
  var isNegative = new RegExp("^\\d?-".concat(prefix ? "".concat(escapeRegExp(prefix), "?") : "", "\\d")).test(_value);
  var value = decimalSeparator !== "." ? replaceDecimalSeparator(_value, decimalSeparator, isNegative) : _value;
  if (decimalSeparator && decimalSeparator !== "-" && value.startsWith(decimalSeparator)) {
    value = "0" + value;
  }
  var defaultNumberFormatOptions = {
    minimumFractionDigits: decimalScale || 0,
    maximumFractionDigits: 20
  };
  var numberFormatter = intlConfig ? new Intl.NumberFormat(intlConfig.locale, intlConfig.currency ? __assign(__assign({}, defaultNumberFormatOptions), { style: "currency", currency: intlConfig.currency }) : defaultNumberFormatOptions) : new Intl.NumberFormat(void 0, defaultNumberFormatOptions);
  var parts = numberFormatter.formatToParts(Number(value));
  var formatted = replaceParts(parts, options);
  var intlSuffix = getSuffix(formatted, __assign({}, options));
  var includeDecimalSeparator = _value.slice(-1) === decimalSeparator ? decimalSeparator : "";
  var _c = value.match(RegExp("\\d+\\.(\\d+)")) || [], decimals = _c[1];
  if (decimalScale === void 0 && decimals && decimalSeparator) {
    if (formatted.includes(decimalSeparator)) {
      formatted = formatted.replace(RegExp("(\\d+)(".concat(escapeRegExp(decimalSeparator), ")(\\d+)"), "g"), "$1$2".concat(decimals));
    } else {
      if (intlSuffix && !suffix) {
        formatted = formatted.replace(intlSuffix, "".concat(decimalSeparator).concat(decimals).concat(intlSuffix));
      } else {
        formatted = "".concat(formatted).concat(decimalSeparator).concat(decimals);
      }
    }
  }
  if (suffix && includeDecimalSeparator) {
    return "".concat(formatted).concat(includeDecimalSeparator).concat(suffix);
  }
  if (intlSuffix && includeDecimalSeparator) {
    return formatted.replace(intlSuffix, "".concat(includeDecimalSeparator).concat(intlSuffix));
  }
  if (intlSuffix && suffix) {
    return formatted.replace(intlSuffix, "".concat(includeDecimalSeparator).concat(suffix));
  }
  return [formatted, includeDecimalSeparator, suffix].join("");
};
var replaceDecimalSeparator = function(value, decimalSeparator, isNegative) {
  var newValue = value;
  if (decimalSeparator && decimalSeparator !== ".") {
    newValue = newValue.replace(RegExp(escapeRegExp(decimalSeparator), "g"), ".");
    if (isNegative && decimalSeparator === "-") {
      newValue = "-".concat(newValue.slice(1));
    }
  }
  return newValue;
};
var replaceParts = function(parts, _a) {
  var prefix = _a.prefix, groupSeparator = _a.groupSeparator, decimalSeparator = _a.decimalSeparator, decimalScale = _a.decimalScale, _b = _a.disableGroupSeparators, disableGroupSeparators = _b === void 0 ? false : _b;
  return parts.reduce(function(prev, _a2, i2) {
    var type = _a2.type, value = _a2.value;
    if (i2 === 0 && prefix) {
      if (type === "minusSign") {
        return [value, prefix];
      }
      if (type === "currency") {
        return __spreadArray(__spreadArray([], prev, true), [prefix], false);
      }
      return [prefix, value];
    }
    if (type === "currency") {
      return prefix ? prev : __spreadArray(__spreadArray([], prev, true), [value], false);
    }
    if (type === "group") {
      return !disableGroupSeparators ? __spreadArray(__spreadArray([], prev, true), [groupSeparator !== void 0 ? groupSeparator : value], false) : prev;
    }
    if (type === "decimal") {
      if (decimalScale !== void 0 && decimalScale === 0) {
        return prev;
      }
      return __spreadArray(__spreadArray([], prev, true), [decimalSeparator !== void 0 ? decimalSeparator : value], false);
    }
    if (type === "fraction") {
      return __spreadArray(__spreadArray([], prev, true), [decimalScale !== void 0 ? value.slice(0, decimalScale) : value], false);
    }
    return __spreadArray(__spreadArray([], prev, true), [value], false);
  }, [""]).join("");
};
var defaultConfig = {
  currencySymbol: "",
  groupSeparator: "",
  decimalSeparator: "",
  prefix: "",
  suffix: ""
};
var getLocaleConfig = function(intlConfig) {
  var _a = intlConfig || {}, locale = _a.locale, currency = _a.currency;
  var numberFormatter = locale ? new Intl.NumberFormat(locale, currency ? { currency, style: "currency" } : void 0) : new Intl.NumberFormat();
  return numberFormatter.formatToParts(1000.1).reduce(function(prev, curr, i2) {
    if (curr.type === "currency") {
      if (i2 === 0) {
        return __assign(__assign({}, prev), { currencySymbol: curr.value, prefix: curr.value });
      } else {
        return __assign(__assign({}, prev), { currencySymbol: curr.value, suffix: curr.value });
      }
    }
    if (curr.type === "group") {
      return __assign(__assign({}, prev), { groupSeparator: curr.value });
    }
    if (curr.type === "decimal") {
      return __assign(__assign({}, prev), { decimalSeparator: curr.value });
    }
    return prev;
  }, defaultConfig);
};
var isNumber = function(input) {
  return RegExp(/\d/, "gi").test(input);
};
var padTrimValue = function(value, decimalSeparator, decimalScale) {
  if (decimalSeparator === void 0) {
    decimalSeparator = ".";
  }
  if (decimalScale === void 0 || value === "" || value === void 0) {
    return value;
  }
  if (!value.match(/\d/g)) {
    return "";
  }
  var _a = value.split(decimalSeparator), int = _a[0], decimals = _a[1];
  if (decimalScale === 0) {
    return int;
  }
  var newValue = decimals || "";
  if (newValue.length < decimalScale) {
    while (newValue.length < decimalScale) {
      newValue += "0";
    }
  } else {
    newValue = newValue.slice(0, decimalScale);
  }
  return "".concat(int).concat(decimalSeparator).concat(newValue);
};
var repositionCursor = function(_a) {
  var selectionStart = _a.selectionStart, value = _a.value, lastKeyStroke = _a.lastKeyStroke, stateValue = _a.stateValue, groupSeparator = _a.groupSeparator;
  var cursorPosition = selectionStart;
  var modifiedValue = value;
  if (stateValue && cursorPosition) {
    var splitValue = value.split("");
    if (lastKeyStroke === "Backspace" && stateValue[cursorPosition] === groupSeparator) {
      splitValue.splice(cursorPosition - 1, 1);
      cursorPosition -= 1;
    }
    if (lastKeyStroke === "Delete" && stateValue[cursorPosition] === groupSeparator) {
      splitValue.splice(cursorPosition, 1);
      cursorPosition += 1;
    }
    modifiedValue = splitValue.join("");
    return { modifiedValue, cursorPosition };
  }
  return { modifiedValue, cursorPosition: selectionStart };
};
var CurrencyInput = reactExports.forwardRef(function(_a, ref) {
  var _b = _a.allowDecimals, allowDecimals = _b === void 0 ? true : _b, _c = _a.allowNegativeValue, allowNegativeValue = _c === void 0 ? true : _c, id = _a.id, name = _a.name, className = _a.className, customInput = _a.customInput, decimalsLimit = _a.decimalsLimit, defaultValue = _a.defaultValue, _d = _a.disabled, disabled = _d === void 0 ? false : _d, userMaxLength = _a.maxLength, userValue = _a.value, onValueChange = _a.onValueChange, fixedDecimalLength = _a.fixedDecimalLength, placeholder = _a.placeholder, decimalScale = _a.decimalScale, prefix = _a.prefix, suffix = _a.suffix, intlConfig = _a.intlConfig, step = _a.step, min2 = _a.min, max2 = _a.max, _e2 = _a.disableGroupSeparators, disableGroupSeparators = _e2 === void 0 ? false : _e2, _f = _a.disableAbbreviations, disableAbbreviations = _f === void 0 ? false : _f, _decimalSeparator = _a.decimalSeparator, _groupSeparator = _a.groupSeparator, onChange2 = _a.onChange, onFocus = _a.onFocus, onBlur = _a.onBlur, onKeyDown2 = _a.onKeyDown, onKeyUp = _a.onKeyUp, transformRawValue = _a.transformRawValue, _g = _a.formatValueOnBlur, formatValueOnBlur = _g === void 0 ? true : _g, props = __rest(_a, ["allowDecimals", "allowNegativeValue", "id", "name", "className", "customInput", "decimalsLimit", "defaultValue", "disabled", "maxLength", "value", "onValueChange", "fixedDecimalLength", "placeholder", "decimalScale", "prefix", "suffix", "intlConfig", "step", "min", "max", "disableGroupSeparators", "disableAbbreviations", "decimalSeparator", "groupSeparator", "onChange", "onFocus", "onBlur", "onKeyDown", "onKeyUp", "transformRawValue", "formatValueOnBlur"]);
  if (_decimalSeparator && isNumber(_decimalSeparator)) {
    throw new Error("decimalSeparator cannot be a number");
  }
  if (_groupSeparator && isNumber(_groupSeparator)) {
    throw new Error("groupSeparator cannot be a number");
  }
  var localeConfig = reactExports.useMemo(function() {
    return getLocaleConfig(intlConfig);
  }, [intlConfig]);
  var decimalSeparator = _decimalSeparator || localeConfig.decimalSeparator || "";
  var groupSeparator = _groupSeparator || localeConfig.groupSeparator || "";
  if (decimalSeparator && groupSeparator && decimalSeparator === groupSeparator && disableGroupSeparators === false) {
    throw new Error("decimalSeparator cannot be the same as groupSeparator");
  }
  var formatValueOptions = {
    decimalSeparator,
    groupSeparator,
    disableGroupSeparators,
    intlConfig,
    prefix: prefix || localeConfig.prefix,
    suffix
  };
  var cleanValueOptions = {
    decimalSeparator,
    groupSeparator,
    allowDecimals,
    decimalsLimit: decimalsLimit || fixedDecimalLength || 2,
    allowNegativeValue,
    disableAbbreviations,
    prefix: prefix || localeConfig.prefix,
    transformRawValue
  };
  var _h = reactExports.useState(function() {
    return defaultValue != null ? formatValue(__assign(__assign({}, formatValueOptions), { decimalScale, value: String(defaultValue) })) : userValue != null ? formatValue(__assign(__assign({}, formatValueOptions), { decimalScale, value: String(userValue) })) : "";
  }), stateValue = _h[0], setStateValue = _h[1];
  var _j = reactExports.useState(false), dirty = _j[0], setDirty = _j[1];
  var _k = reactExports.useState(0), cursor = _k[0], setCursor = _k[1];
  var _l = reactExports.useState(0), changeCount = _l[0], setChangeCount = _l[1];
  var _m = reactExports.useState(null), lastKeyStroke = _m[0], setLastKeyStroke = _m[1];
  var inputRef = reactExports.useRef(null);
  reactExports.useImperativeHandle(ref, function() {
    return inputRef.current;
  });
  var processChange = function(value, selectionStart) {
    setDirty(true);
    var _a2 = repositionCursor({
      selectionStart,
      value,
      lastKeyStroke,
      stateValue,
      groupSeparator
    }), modifiedValue = _a2.modifiedValue, cursorPosition = _a2.cursorPosition;
    var stringValue = cleanValue(__assign({ value: modifiedValue }, cleanValueOptions));
    if (userMaxLength && stringValue.replace(/-/g, "").length > userMaxLength) {
      return;
    }
    if (stringValue === "" || stringValue === "-" || stringValue === decimalSeparator) {
      onValueChange && onValueChange(void 0, name, { float: null, formatted: "", value: "" });
      setStateValue(stringValue);
      setCursor(1);
      return;
    }
    var stringValueWithoutSeparator = decimalSeparator ? stringValue.replace(decimalSeparator, ".") : stringValue;
    var numberValue = parseFloat(stringValueWithoutSeparator);
    var formattedValue = formatValue(__assign({ value: stringValue }, formatValueOptions));
    if (cursorPosition != null) {
      var newCursor = cursorPosition + (formattedValue.length - value.length);
      newCursor = newCursor <= 0 ? prefix ? prefix.length : 0 : newCursor;
      setCursor(newCursor);
      setChangeCount(changeCount + 1);
    }
    setStateValue(formattedValue);
    if (onValueChange) {
      var values = {
        float: numberValue,
        formatted: formattedValue,
        value: stringValue
      };
      onValueChange(stringValue, name, values);
    }
  };
  var handleOnChange = function(event) {
    var _a2 = event.target, value = _a2.value, selectionStart = _a2.selectionStart;
    processChange(value, selectionStart);
    onChange2 && onChange2(event);
  };
  var handleOnFocus = function(event) {
    onFocus && onFocus(event);
    return stateValue ? stateValue.length : 0;
  };
  var handleOnBlur = function(event) {
    var value = event.target.value;
    var valueOnly = cleanValue(__assign({ value }, cleanValueOptions));
    if (valueOnly === "-" || valueOnly === decimalSeparator || !valueOnly) {
      setStateValue("");
      onBlur && onBlur(event);
      return;
    }
    var fixedDecimals = fixedDecimalValue(valueOnly, decimalSeparator, fixedDecimalLength);
    var newValue = padTrimValue(fixedDecimals, decimalSeparator, decimalScale !== void 0 ? decimalScale : fixedDecimalLength);
    var numberValue = parseFloat(newValue.replace(decimalSeparator, "."));
    var formattedValue = formatValue(__assign(__assign({}, formatValueOptions), { value: newValue }));
    if (onValueChange && formatValueOnBlur) {
      onValueChange(newValue, name, {
        float: numberValue,
        formatted: formattedValue,
        value: newValue
      });
    }
    setStateValue(formattedValue);
    onBlur && onBlur(event);
  };
  var handleOnKeyDown = function(event) {
    var key = event.key;
    setLastKeyStroke(key);
    if (step && (key === "ArrowUp" || key === "ArrowDown")) {
      event.preventDefault();
      setCursor(stateValue.length);
      var currentValue = parseFloat(userValue != null ? String(userValue).replace(decimalSeparator, ".") : cleanValue(__assign({ value: stateValue }, cleanValueOptions))) || 0;
      var newValue = key === "ArrowUp" ? currentValue + step : currentValue - step;
      if (min2 !== void 0 && newValue < Number(min2)) {
        return;
      }
      if (max2 !== void 0 && newValue > Number(max2)) {
        return;
      }
      var fixedLength = String(step).includes(".") ? Number(String(step).split(".")[1].length) : void 0;
      processChange(String(fixedLength ? newValue.toFixed(fixedLength) : newValue).replace(".", decimalSeparator));
    }
    onKeyDown2 && onKeyDown2(event);
  };
  var handleOnKeyUp = function(event) {
    var key = event.key, selectionStart = event.currentTarget.selectionStart;
    if (key !== "ArrowUp" && key !== "ArrowDown" && stateValue !== "-") {
      var suffix_1 = getSuffix(stateValue, { groupSeparator, decimalSeparator });
      if (suffix_1 && selectionStart && selectionStart > stateValue.length - suffix_1.length) {
        if (inputRef.current) {
          var newCursor = stateValue.length - suffix_1.length;
          inputRef.current.setSelectionRange(newCursor, newCursor);
        }
      }
    }
    onKeyUp && onKeyUp(event);
  };
  reactExports.useEffect(function() {
    if (userValue == null && defaultValue == null) {
      setStateValue("");
    }
  }, [defaultValue, userValue]);
  reactExports.useEffect(function() {
    if (dirty && stateValue !== "-" && inputRef.current && document.activeElement === inputRef.current) {
      inputRef.current.setSelectionRange(cursor, cursor);
    }
  }, [stateValue, cursor, inputRef, dirty, changeCount]);
  var getRenderValue = function() {
    if (userValue != null && stateValue !== "-" && (!decimalSeparator || stateValue !== decimalSeparator)) {
      return formatValue(__assign(__assign({}, formatValueOptions), { decimalScale: dirty ? void 0 : decimalScale, value: String(userValue) }));
    }
    return stateValue;
  };
  var inputProps = __assign({ type: "text", inputMode: "decimal", id, name, className, onChange: handleOnChange, onBlur: handleOnBlur, onFocus: handleOnFocus, onKeyDown: handleOnKeyDown, onKeyUp: handleOnKeyUp, placeholder, disabled, value: getRenderValue(), ref: inputRef }, props);
  if (customInput) {
    var CustomInput = customInput;
    return React.createElement(CustomInput, __assign({}, inputProps));
  }
  return React.createElement("input", __assign({}, inputProps));
});
CurrencyInput.displayName = "CurrencyInput";
const AmountInput = reactExports.forwardRef(function AmountInput2({ className = "", isFocused = false, ...props }, ref) {
  const input = ref ? ref : reactExports.useRef();
  reactExports.useEffect(() => {
    if (isFocused) {
      input.current.focus();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    CurrencyInput,
    {
      onValueChange: (e2) => props.onValueChange && props.onValueChange(e2),
      className: "border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5 " + className,
      ref: input
    }
  ) });
});
var _excluded = ["defaultOptions", "cacheOptions", "loadOptions", "options", "isLoading", "onInputChange", "filterOption"];
function useAsync(_ref) {
  var _ref$defaultOptions = _ref.defaultOptions, propsDefaultOptions = _ref$defaultOptions === void 0 ? false : _ref$defaultOptions, _ref$cacheOptions = _ref.cacheOptions, cacheOptions = _ref$cacheOptions === void 0 ? false : _ref$cacheOptions, propsLoadOptions = _ref.loadOptions;
  _ref.options;
  var _ref$isLoading = _ref.isLoading, propsIsLoading = _ref$isLoading === void 0 ? false : _ref$isLoading, propsOnInputChange = _ref.onInputChange, _ref$filterOption = _ref.filterOption, filterOption = _ref$filterOption === void 0 ? null : _ref$filterOption, restSelectProps = _objectWithoutProperties$9(_ref, _excluded);
  var propsInputValue = restSelectProps.inputValue;
  var lastRequest = reactExports.useRef(void 0);
  var mounted = reactExports.useRef(false);
  var _useState = reactExports.useState(Array.isArray(propsDefaultOptions) ? propsDefaultOptions : void 0), _useState2 = _slicedToArray$3(_useState, 2), defaultOptions = _useState2[0], setDefaultOptions = _useState2[1];
  var _useState3 = reactExports.useState(typeof propsInputValue !== "undefined" ? propsInputValue : ""), _useState4 = _slicedToArray$3(_useState3, 2), stateInputValue = _useState4[0], setStateInputValue = _useState4[1];
  var _useState5 = reactExports.useState(propsDefaultOptions === true), _useState6 = _slicedToArray$3(_useState5, 2), isLoading = _useState6[0], setIsLoading = _useState6[1];
  var _useState7 = reactExports.useState(void 0), _useState8 = _slicedToArray$3(_useState7, 2), loadedInputValue = _useState8[0], setLoadedInputValue = _useState8[1];
  var _useState9 = reactExports.useState([]), _useState10 = _slicedToArray$3(_useState9, 2), loadedOptions = _useState10[0], setLoadedOptions = _useState10[1];
  var _useState11 = reactExports.useState(false), _useState12 = _slicedToArray$3(_useState11, 2), passEmptyOptions = _useState12[0], setPassEmptyOptions = _useState12[1];
  var _useState13 = reactExports.useState({}), _useState14 = _slicedToArray$3(_useState13, 2), optionsCache = _useState14[0], setOptionsCache = _useState14[1];
  var _useState15 = reactExports.useState(void 0), _useState16 = _slicedToArray$3(_useState15, 2), prevDefaultOptions = _useState16[0], setPrevDefaultOptions = _useState16[1];
  var _useState17 = reactExports.useState(void 0), _useState18 = _slicedToArray$3(_useState17, 2), prevCacheOptions = _useState18[0], setPrevCacheOptions = _useState18[1];
  if (cacheOptions !== prevCacheOptions) {
    setOptionsCache({});
    setPrevCacheOptions(cacheOptions);
  }
  if (propsDefaultOptions !== prevDefaultOptions) {
    setDefaultOptions(Array.isArray(propsDefaultOptions) ? propsDefaultOptions : void 0);
    setPrevDefaultOptions(propsDefaultOptions);
  }
  reactExports.useEffect(function() {
    mounted.current = true;
    return function() {
      mounted.current = false;
    };
  }, []);
  var loadOptions = reactExports.useCallback(function(inputValue, callback) {
    if (!propsLoadOptions)
      return callback();
    var loader = propsLoadOptions(inputValue, callback);
    if (loader && typeof loader.then === "function") {
      loader.then(callback, function() {
        return callback();
      });
    }
  }, [propsLoadOptions]);
  reactExports.useEffect(function() {
    if (propsDefaultOptions === true) {
      loadOptions(stateInputValue, function(options2) {
        if (!mounted.current)
          return;
        setDefaultOptions(options2 || []);
        setIsLoading(!!lastRequest.current);
      });
    }
  }, []);
  var onInputChange = reactExports.useCallback(function(newValue, actionMeta) {
    var inputValue = handleInputChange(newValue, actionMeta, propsOnInputChange);
    if (!inputValue) {
      lastRequest.current = void 0;
      setStateInputValue("");
      setLoadedInputValue("");
      setLoadedOptions([]);
      setIsLoading(false);
      setPassEmptyOptions(false);
      return;
    }
    if (cacheOptions && optionsCache[inputValue]) {
      setStateInputValue(inputValue);
      setLoadedInputValue(inputValue);
      setLoadedOptions(optionsCache[inputValue]);
      setIsLoading(false);
      setPassEmptyOptions(false);
    } else {
      var request = lastRequest.current = {};
      setStateInputValue(inputValue);
      setIsLoading(true);
      setPassEmptyOptions(!loadedInputValue);
      loadOptions(inputValue, function(options2) {
        if (!mounted)
          return;
        if (request !== lastRequest.current)
          return;
        lastRequest.current = void 0;
        setIsLoading(false);
        setLoadedInputValue(inputValue);
        setLoadedOptions(options2 || []);
        setPassEmptyOptions(false);
        setOptionsCache(options2 ? _objectSpread2(_objectSpread2({}, optionsCache), {}, _defineProperty$8({}, inputValue, options2)) : optionsCache);
      });
    }
  }, [cacheOptions, loadOptions, loadedInputValue, optionsCache, propsOnInputChange]);
  var options = passEmptyOptions ? [] : stateInputValue && loadedInputValue ? loadedOptions : defaultOptions || [];
  return _objectSpread2(_objectSpread2({}, restSelectProps), {}, {
    options,
    isLoading: isLoading || propsIsLoading,
    onInputChange,
    filterOption
  });
}
var AsyncSelect = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
  var stateManagedProps = useAsync(props);
  var selectProps = useStateManager(stateManagedProps);
  return /* @__PURE__ */ reactExports.createElement(Select, _extends$9({
    ref
  }, selectProps));
});
var AsyncSelect$1 = AsyncSelect;
const SelectUrlInput = reactExports.forwardRef(function SelectUrlInput2({ url, className = "", value, isFocused = false, placeholder = "", ...props }, ref) {
  const input = ref ? ref : reactExports.useRef();
  reactExports.useEffect(() => {
    if (isFocused) {
      input.current.focus();
    }
  }, []);
  const getApiData = async (inputValue) => {
    let jsonResponse = await fetch(
      url + `&search=` + inputValue,
      {
        headers: {
          "Accept": "application/json",
          "Content-Type": "application/json"
        }
      }
    ).then((response) => response.json());
    let responseData = jsonResponse.data.structure.records.data.map((item) => {
      return {
        label: item.name,
        value: item.id
      };
    });
    return responseData;
  };
  const loadOptions = (inputValue) => {
    console.log(inputValue);
    return getApiData(inputValue);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    AsyncSelect$1,
    {
      cacheOptions: true,
      loadOptions,
      defaultOptions: true,
      className: "w-full flex bg-white border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm " + className,
      ...props,
      styles: {
        control: () => ({}),
        clearIndicator: (baseStyles) => ({ ...baseStyles }),
        container: (baseStyles) => ({ ...baseStyles }),
        dropdownIndicator: (baseStyles) => ({ ...baseStyles }),
        group: (baseStyles) => ({ ...baseStyles }),
        groupHeading: (baseStyles) => ({ ...baseStyles }),
        indicatorsContainer: (baseStyles) => ({ ...baseStyles }),
        indicatorSeparator: (baseStyles) => ({ ...baseStyles }),
        input: (baseStyles) => ({ ...baseStyles }),
        loadingIndicator: (baseStyles) => ({ ...baseStyles }),
        loadingMessage: (baseStyles) => ({ ...baseStyles }),
        menu: (baseStyles) => ({ ...baseStyles }),
        menuList: (baseStyles) => ({ ...baseStyles }),
        menuPortal: () => ({}),
        multiValue: (baseStyles) => ({ ...baseStyles }),
        multiValueLabel: (baseStyles) => ({ ...baseStyles }),
        multiValueRemove: (baseStyles) => ({ ...baseStyles }),
        noOptionsMessage: (baseStyles) => ({ ...baseStyles }),
        option: () => ({}),
        placeholder: (baseStyles) => ({ ...baseStyles }),
        singleValue: (baseStyles) => ({ ...baseStyles }),
        valueContainer: (baseStyles) => ({ ...baseStyles })
      },
      classNames: {
        control: () => "w-full flex",
        input: () => "inline-gid flex-1 box-content not-form",
        option: () => "px-3 py-2 bg-white hover:bg-gray-200 cursor-pointer"
      }
    }
  );
});
const EmailInput = reactExports.forwardRef(function EmailInput2({ map, className = "", isFocused = false, ...props }, ref) {
  const input = ref ? ref : reactExports.useRef(null);
  reactExports.useEffect(() => {
    var _a;
    if (isFocused) {
      (_a = input.current) == null ? void 0 : _a.focus();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "email",
      onChange: (e2) => props.onChange && props.onChange(e2),
      onBlur: (e2) => props.onBlur && props.onBlur(e2),
      name: map,
      className: "border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5 " + className,
      ref: input
    }
  );
});
var Rt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Pe(s4) {
  return s4 && s4.__esModule && Object.prototype.hasOwnProperty.call(s4, "default") ? s4.default : s4;
}
function Te() {
}
Object.assign(Te, {
  default: Te,
  register: Te,
  revert: function() {
  },
  __esModule: true
});
Element.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(s4) {
  const e2 = (this.document || this.ownerDocument).querySelectorAll(s4);
  let t2 = e2.length;
  for (; --t2 >= 0 && e2.item(t2) !== this; )
    ;
  return t2 > -1;
});
Element.prototype.closest || (Element.prototype.closest = function(s4) {
  let e2 = this;
  if (!document.documentElement.contains(e2))
    return null;
  do {
    if (e2.matches(s4))
      return e2;
    e2 = e2.parentElement || e2.parentNode;
  } while (e2 !== null);
  return null;
});
Element.prototype.prepend || (Element.prototype.prepend = function(e2) {
  const t2 = document.createDocumentFragment();
  Array.isArray(e2) || (e2 = [e2]), e2.forEach((o3) => {
    const i2 = o3 instanceof Node;
    t2.appendChild(i2 ? o3 : document.createTextNode(o3));
  }), this.insertBefore(t2, this.firstChild);
});
Element.prototype.scrollIntoViewIfNeeded || (Element.prototype.scrollIntoViewIfNeeded = function(s4) {
  s4 = arguments.length === 0 ? true : !!s4;
  const e2 = this.parentNode, t2 = window.getComputedStyle(e2, null), o3 = parseInt(t2.getPropertyValue("border-top-width")), i2 = parseInt(t2.getPropertyValue("border-left-width")), n3 = this.offsetTop - e2.offsetTop < e2.scrollTop, r4 = this.offsetTop - e2.offsetTop + this.clientHeight - o3 > e2.scrollTop + e2.clientHeight, a3 = this.offsetLeft - e2.offsetLeft < e2.scrollLeft, l2 = this.offsetLeft - e2.offsetLeft + this.clientWidth - i2 > e2.scrollLeft + e2.clientWidth, d4 = n3 && !r4;
  (n3 || r4) && s4 && (e2.scrollTop = this.offsetTop - e2.offsetTop - e2.clientHeight / 2 - o3 + this.clientHeight / 2), (a3 || l2) && s4 && (e2.scrollLeft = this.offsetLeft - e2.offsetLeft - e2.clientWidth / 2 - i2 + this.clientWidth / 2), (n3 || r4 || a3 || l2) && !s4 && this.scrollIntoView(d4);
});
window.requestIdleCallback = window.requestIdleCallback || function(s4) {
  const e2 = Date.now();
  return setTimeout(function() {
    s4({
      didTimeout: false,
      timeRemaining: function() {
        return Math.max(0, 50 - (Date.now() - e2));
      }
    });
  }, 1);
};
window.cancelIdleCallback = window.cancelIdleCallback || function(s4) {
  clearTimeout(s4);
};
let Dt = (s4 = 21) => crypto.getRandomValues(new Uint8Array(s4)).reduce((e2, t2) => (t2 &= 63, t2 < 36 ? e2 += t2.toString(36) : t2 < 62 ? e2 += (t2 - 26).toString(36).toUpperCase() : t2 > 62 ? e2 += "-" : e2 += "_", e2), "");
var at = /* @__PURE__ */ ((s4) => (s4.VERBOSE = "VERBOSE", s4.INFO = "INFO", s4.WARN = "WARN", s4.ERROR = "ERROR", s4))(at || {});
const v$1 = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  ESC: 27,
  SPACE: 32,
  LEFT: 37,
  UP: 38,
  DOWN: 40,
  RIGHT: 39,
  DELETE: 46,
  META: 91,
  SLASH: 191
}, Pt = {
  LEFT: 0,
  WHEEL: 1,
  RIGHT: 2,
  BACKWARD: 3,
  FORWARD: 4
};
function me(s4, e2, t2 = "log", o3, i2 = "color: inherit") {
  if (!("console" in window) || !window.console[t2])
    return;
  const n3 = ["info", "log", "warn", "error"].includes(t2), r4 = [];
  switch (me.logLevel) {
    case "ERROR":
      if (t2 !== "error")
        return;
      break;
    case "WARN":
      if (!["error", "warn"].includes(t2))
        return;
      break;
    case "INFO":
      if (!n3 || s4)
        return;
      break;
  }
  o3 && r4.push(o3);
  const a3 = "Editor.js 2.29.1", l2 = `line-height: 1em;
            color: #006FEA;
            display: inline-block;
            font-size: 11px;
            line-height: 1em;
            background-color: #fff;
            padding: 4px 9px;
            border-radius: 30px;
            border: 1px solid rgba(56, 138, 229, 0.16);
            margin: 4px 5px 4px 0;`;
  s4 && (n3 ? (r4.unshift(l2, i2), e2 = `%c${a3}%c ${e2}`) : e2 = `( ${a3} )${e2}`);
  try {
    n3 ? o3 ? console[t2](`${e2} %o`, ...r4) : console[t2](e2, ...r4) : console[t2](e2);
  } catch {
  }
}
me.logLevel = "VERBOSE";
function Ft(s4) {
  me.logLevel = s4;
}
const T$1 = me.bind(window, false), Y = me.bind(window, true);
function oe(s4) {
  return Object.prototype.toString.call(s4).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
}
function M$2(s4) {
  return oe(s4) === "function" || oe(s4) === "asyncfunction";
}
function D$1(s4) {
  return oe(s4) === "object";
}
function G(s4) {
  return oe(s4) === "string";
}
function Ht(s4) {
  return oe(s4) === "boolean";
}
function Je(s4) {
  return oe(s4) === "number";
}
function Qe(s4) {
  return oe(s4) === "undefined";
}
function W(s4) {
  return s4 ? Object.keys(s4).length === 0 && s4.constructor === Object : true;
}
function lt(s4) {
  return s4 > 47 && s4 < 58 || // number keys
  s4 === 32 || s4 === 13 || // Space bar & return key(s)
  s4 === 229 || // processing key input for certain languages — Chinese, Japanese, etc.
  s4 > 64 && s4 < 91 || // letter keys
  s4 > 95 && s4 < 112 || // Numpad keys
  s4 > 185 && s4 < 193 || // ;=,-./` (in order)
  s4 > 218 && s4 < 223;
}
async function zt(s4, e2 = () => {
}, t2 = () => {
}) {
  async function o3(i2, n3, r4) {
    try {
      await i2.function(i2.data), await n3(Qe(i2.data) ? {} : i2.data);
    } catch {
      r4(Qe(i2.data) ? {} : i2.data);
    }
  }
  return s4.reduce(async (i2, n3) => (await i2, o3(n3, e2, t2)), Promise.resolve());
}
function ct(s4) {
  return Array.prototype.slice.call(s4);
}
function xe(s4, e2) {
  return function() {
    const t2 = this, o3 = arguments;
    window.setTimeout(() => s4.apply(t2, o3), e2);
  };
}
function Ut(s4) {
  return s4.name.split(".").pop();
}
function jt(s4) {
  return /^[-\w]+\/([-+\w]+|\*)$/.test(s4);
}
function et(s4, e2, t2) {
  let o3;
  return (...i2) => {
    const n3 = this, r4 = () => {
      o3 = null, t2 || s4.apply(n3, i2);
    }, a3 = t2 && !o3;
    window.clearTimeout(o3), o3 = window.setTimeout(r4, e2), a3 && s4.apply(n3, i2);
  };
}
function Ie(s4, e2, t2 = void 0) {
  let o3, i2, n3, r4 = null, a3 = 0;
  t2 || (t2 = {});
  const l2 = function() {
    a3 = t2.leading === false ? 0 : Date.now(), r4 = null, n3 = s4.apply(o3, i2), r4 || (o3 = i2 = null);
  };
  return function() {
    const d4 = Date.now();
    !a3 && t2.leading === false && (a3 = d4);
    const u3 = e2 - (d4 - a3);
    return o3 = this, i2 = arguments, u3 <= 0 || u3 > e2 ? (r4 && (clearTimeout(r4), r4 = null), a3 = d4, n3 = s4.apply(o3, i2), r4 || (o3 = i2 = null)) : !r4 && t2.trailing !== false && (r4 = setTimeout(l2, u3)), n3;
  };
}
function $t() {
  const s4 = {
    win: false,
    mac: false,
    x11: false,
    linux: false
  }, e2 = Object.keys(s4).find((t2) => window.navigator.appVersion.toLowerCase().indexOf(t2) !== -1);
  return e2 && (s4[e2] = true), s4;
}
function re(s4) {
  return s4[0].toUpperCase() + s4.slice(1);
}
function Me(s4, ...e2) {
  if (!e2.length)
    return s4;
  const t2 = e2.shift();
  if (D$1(s4) && D$1(t2))
    for (const o3 in t2)
      D$1(t2[o3]) ? (s4[o3] || Object.assign(s4, { [o3]: {} }), Me(s4[o3], t2[o3])) : Object.assign(s4, { [o3]: t2[o3] });
  return Me(s4, ...e2);
}
function ye(s4) {
  const e2 = $t();
  return s4 = s4.replace(/shift/gi, "⇧").replace(/backspace/gi, "⌫").replace(/enter/gi, "⏎").replace(/up/gi, "↑").replace(/left/gi, "→").replace(/down/gi, "↓").replace(/right/gi, "←").replace(/escape/gi, "⎋").replace(/insert/gi, "Ins").replace(/delete/gi, "␡").replace(/\+/gi, " + "), e2.mac ? s4 = s4.replace(/ctrl|cmd/gi, "⌘").replace(/alt/gi, "⌥") : s4 = s4.replace(/cmd/gi, "Ctrl").replace(/windows/gi, "WIN"), s4;
}
function Wt(s4) {
  try {
    return new URL(s4).href;
  } catch {
  }
  return s4.substring(0, 2) === "//" ? window.location.protocol + s4 : window.location.origin + s4;
}
function Yt() {
  return Dt(10);
}
function Kt(s4) {
  window.open(s4, "_blank");
}
function Xt(s4 = "") {
  return `${s4}${Math.floor(Math.random() * 1e8).toString(16)}`;
}
function Le(s4, e2, t2) {
  const o3 = `«${e2}» is deprecated and will be removed in the next major release. Please use the «${t2}» instead.`;
  s4 && Y(o3, "warn");
}
function le(s4, e2, t2) {
  const o3 = t2.value ? "value" : "get", i2 = t2[o3], n3 = `#${e2}Cache`;
  if (t2[o3] = function(...r4) {
    return this[n3] === void 0 && (this[n3] = i2.apply(this, ...r4)), this[n3];
  }, o3 === "get" && t2.set) {
    const r4 = t2.set;
    t2.set = function(a3) {
      delete s4[n3], r4.apply(this, a3);
    };
  }
  return t2;
}
const dt = 650;
function te() {
  return window.matchMedia(`(max-width: ${dt}px)`).matches;
}
const tt = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
function Vt(s4, e2) {
  const t2 = Array.isArray(s4) || D$1(s4), o3 = Array.isArray(e2) || D$1(e2);
  return t2 || o3 ? JSON.stringify(s4) === JSON.stringify(e2) : s4 === e2;
}
let c$4 = class c {
  /**
   * Check if passed tag has no closed tag
   *
   * @param {HTMLElement} tag - element to check
   * @returns {boolean}
   */
  static isSingleTag(e2) {
    return e2.tagName && [
      "AREA",
      "BASE",
      "BR",
      "COL",
      "COMMAND",
      "EMBED",
      "HR",
      "IMG",
      "INPUT",
      "KEYGEN",
      "LINK",
      "META",
      "PARAM",
      "SOURCE",
      "TRACK",
      "WBR"
    ].includes(e2.tagName);
  }
  /**
   * Check if element is BR or WBR
   *
   * @param {HTMLElement} element - element to check
   * @returns {boolean}
   */
  static isLineBreakTag(e2) {
    return e2 && e2.tagName && [
      "BR",
      "WBR"
    ].includes(e2.tagName);
  }
  /**
   * Helper for making Elements with class name and attributes
   *
   * @param  {string} tagName - new Element tag name
   * @param  {string[]|string} [classNames] - list or name of CSS class name(s)
   * @param  {object} [attributes] - any attributes
   * @returns {HTMLElement}
   */
  static make(e2, t2 = null, o3 = {}) {
    const i2 = document.createElement(e2);
    Array.isArray(t2) ? i2.classList.add(...t2) : t2 && i2.classList.add(t2);
    for (const n3 in o3)
      Object.prototype.hasOwnProperty.call(o3, n3) && (i2[n3] = o3[n3]);
    return i2;
  }
  /**
   * Creates Text Node with the passed content
   *
   * @param {string} content - text content
   * @returns {Text}
   */
  static text(e2) {
    return document.createTextNode(e2);
  }
  /**
   * Append one or several elements to the parent
   *
   * @param  {Element|DocumentFragment} parent - where to append
   * @param  {Element|Element[]|DocumentFragment|Text|Text[]} elements - element or elements list
   */
  static append(e2, t2) {
    Array.isArray(t2) ? t2.forEach((o3) => e2.appendChild(o3)) : e2.appendChild(t2);
  }
  /**
   * Append element or a couple to the beginning of the parent elements
   *
   * @param {Element} parent - where to append
   * @param {Element|Element[]} elements - element or elements list
   */
  static prepend(e2, t2) {
    Array.isArray(t2) ? (t2 = t2.reverse(), t2.forEach((o3) => e2.prepend(o3))) : e2.prepend(t2);
  }
  /**
   * Swap two elements in parent
   *
   * @param {HTMLElement} el1 - from
   * @param {HTMLElement} el2 - to
   * @deprecated
   */
  static swap(e2, t2) {
    const o3 = document.createElement("div"), i2 = e2.parentNode;
    i2.insertBefore(o3, e2), i2.insertBefore(e2, t2), i2.insertBefore(t2, o3), i2.removeChild(o3);
  }
  /**
   * Selector Decorator
   *
   * Returns first match
   *
   * @param {Element} el - element we searching inside. Default - DOM Document
   * @param {string} selector - searching string
   * @returns {Element}
   */
  static find(e2 = document, t2) {
    return e2.querySelector(t2);
  }
  /**
   * Get Element by Id
   *
   * @param {string} id - id to find
   * @returns {HTMLElement | null}
   */
  static get(e2) {
    return document.getElementById(e2);
  }
  /**
   * Selector Decorator.
   *
   * Returns all matches
   *
   * @param {Element|Document} el - element we searching inside. Default - DOM Document
   * @param {string} selector - searching string
   * @returns {NodeList}
   */
  static findAll(e2 = document, t2) {
    return e2.querySelectorAll(t2);
  }
  /**
   * Returns CSS selector for all text inputs
   */
  static get allInputsSelector() {
    return "[contenteditable=true], textarea, input:not([type]), " + ["text", "password", "email", "number", "search", "tel", "url"].map((t2) => `input[type="${t2}"]`).join(", ");
  }
  /**
   * Find all contenteditable, textarea and editable input elements passed holder contains
   *
   * @param holder - element where to find inputs
   */
  static findAllInputs(e2) {
    return ct(e2.querySelectorAll(c.allInputsSelector)).reduce((t2, o3) => c.isNativeInput(o3) || c.containsOnlyInlineElements(o3) ? [...t2, o3] : [...t2, ...c.getDeepestBlockElements(o3)], []);
  }
  /**
   * Search for deepest node which is Leaf.
   * Leaf is the vertex that doesn't have any child nodes
   *
   * @description Method recursively goes throw the all Node until it finds the Leaf
   * @param {Node} node - root Node. From this vertex we start Deep-first search
   *                      {@link https://en.wikipedia.org/wiki/Depth-first_search}
   * @param {boolean} [atLast] - find last text node
   * @returns {Node} - it can be text Node or Element Node, so that caret will able to work with it
   */
  static getDeepestNode(e2, t2 = false) {
    const o3 = t2 ? "lastChild" : "firstChild", i2 = t2 ? "previousSibling" : "nextSibling";
    if (e2 && e2.nodeType === Node.ELEMENT_NODE && e2[o3]) {
      let n3 = e2[o3];
      if (c.isSingleTag(n3) && !c.isNativeInput(n3) && !c.isLineBreakTag(n3))
        if (n3[i2])
          n3 = n3[i2];
        else if (n3.parentNode[i2])
          n3 = n3.parentNode[i2];
        else
          return n3.parentNode;
      return this.getDeepestNode(n3, t2);
    }
    return e2;
  }
  /**
   * Check if object is DOM node
   *
   * @param {*} node - object to check
   * @returns {boolean}
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static isElement(e2) {
    return Je(e2) ? false : e2 && e2.nodeType && e2.nodeType === Node.ELEMENT_NODE;
  }
  /**
   * Check if object is DocumentFragment node
   *
   * @param {object} node - object to check
   * @returns {boolean}
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static isFragment(e2) {
    return Je(e2) ? false : e2 && e2.nodeType && e2.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
  }
  /**
   * Check if passed element is contenteditable
   *
   * @param {HTMLElement} element - html element to check
   * @returns {boolean}
   */
  static isContentEditable(e2) {
    return e2.contentEditable === "true";
  }
  /**
   * Checks target if it is native input
   *
   * @param {*} target - HTML element or string
   * @returns {boolean}
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static isNativeInput(e2) {
    const t2 = [
      "INPUT",
      "TEXTAREA"
    ];
    return e2 && e2.tagName ? t2.includes(e2.tagName) : false;
  }
  /**
   * Checks if we can set caret
   *
   * @param {HTMLElement} target - target to check
   * @returns {boolean}
   */
  static canSetCaret(e2) {
    let t2 = true;
    if (c.isNativeInput(e2))
      switch (e2.type) {
        case "file":
        case "checkbox":
        case "radio":
        case "hidden":
        case "submit":
        case "button":
        case "image":
        case "reset":
          t2 = false;
          break;
      }
    else
      t2 = c.isContentEditable(e2);
    return t2;
  }
  /**
   * Checks node if it is empty
   *
   * @description Method checks simple Node without any childs for emptiness
   * If you have Node with 2 or more children id depth, you better use {@link Dom#isEmpty} method
   * @param {Node} node - node to check
   * @param {string} [ignoreChars] - char or substring to treat as empty
   * @returns {boolean} true if it is empty
   */
  static isNodeEmpty(e2, t2) {
    let o3;
    return this.isSingleTag(e2) && !this.isLineBreakTag(e2) ? false : (this.isElement(e2) && this.isNativeInput(e2) ? o3 = e2.value : o3 = e2.textContent.replace("​", ""), t2 && (o3 = o3.replace(new RegExp(t2, "g"), "")), o3.trim().length === 0);
  }
  /**
   * checks node if it is doesn't have any child nodes
   *
   * @param {Node} node - node to check
   * @returns {boolean}
   */
  static isLeaf(e2) {
    return e2 ? e2.childNodes.length === 0 : false;
  }
  /**
   * breadth-first search (BFS)
   * {@link https://en.wikipedia.org/wiki/Breadth-first_search}
   *
   * @description Pushes to stack all DOM leafs and checks for emptiness
   * @param {Node} node - node to check
   * @param {string} [ignoreChars] - char or substring to treat as empty
   * @returns {boolean}
   */
  static isEmpty(e2, t2) {
    e2.normalize();
    const o3 = [e2];
    for (; o3.length > 0; )
      if (e2 = o3.shift(), !!e2) {
        if (this.isLeaf(e2) && !this.isNodeEmpty(e2, t2))
          return false;
        e2.childNodes && o3.push(...Array.from(e2.childNodes));
      }
    return true;
  }
  /**
   * Check if string contains html elements
   *
   * @param {string} str - string to check
   * @returns {boolean}
   */
  static isHTMLString(e2) {
    const t2 = c.make("div");
    return t2.innerHTML = e2, t2.childElementCount > 0;
  }
  /**
   * Return length of node`s text content
   *
   * @param {Node} node - node with content
   * @returns {number}
   */
  static getContentLength(e2) {
    return c.isNativeInput(e2) ? e2.value.length : e2.nodeType === Node.TEXT_NODE ? e2.length : e2.textContent.length;
  }
  /**
   * Return array of names of block html elements
   *
   * @returns {string[]}
   */
  static get blockElements() {
    return [
      "address",
      "article",
      "aside",
      "blockquote",
      "canvas",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "hr",
      "li",
      "main",
      "nav",
      "noscript",
      "ol",
      "output",
      "p",
      "pre",
      "ruby",
      "section",
      "table",
      "tbody",
      "thead",
      "tr",
      "tfoot",
      "ul",
      "video"
    ];
  }
  /**
   * Check if passed content includes only inline elements
   *
   * @param {string|HTMLElement} data - element or html string
   * @returns {boolean}
   */
  static containsOnlyInlineElements(e2) {
    let t2;
    G(e2) ? (t2 = document.createElement("div"), t2.innerHTML = e2) : t2 = e2;
    const o3 = (i2) => !c.blockElements.includes(i2.tagName.toLowerCase()) && Array.from(i2.children).every(o3);
    return Array.from(t2.children).every(o3);
  }
  /**
   * Find and return all block elements in the passed parent (including subtree)
   *
   * @param {HTMLElement} parent - root element
   * @returns {HTMLElement[]}
   */
  static getDeepestBlockElements(e2) {
    return c.containsOnlyInlineElements(e2) ? [e2] : Array.from(e2.children).reduce((t2, o3) => [...t2, ...c.getDeepestBlockElements(o3)], []);
  }
  /**
   * Helper for get holder from {string} or return HTMLElement
   *
   * @param {string | HTMLElement} element - holder's id or holder's HTML Element
   * @returns {HTMLElement}
   */
  static getHolder(e2) {
    return G(e2) ? document.getElementById(e2) : e2;
  }
  /**
   * Returns true if element is anchor (is A tag)
   *
   * @param {Element} element - element to check
   * @returns {boolean}
   */
  static isAnchor(e2) {
    return e2.tagName.toLowerCase() === "a";
  }
  /**
   * Return element's offset related to the document
   *
   * @todo handle case when editor initialized in scrollable popup
   * @param el - element to compute offset
   */
  static offset(e2) {
    const t2 = e2.getBoundingClientRect(), o3 = window.pageXOffset || document.documentElement.scrollLeft, i2 = window.pageYOffset || document.documentElement.scrollTop, n3 = t2.top + i2, r4 = t2.left + o3;
    return {
      top: n3,
      left: r4,
      bottom: n3 + t2.height,
      right: r4 + t2.width
    };
  }
};
const qt = {
  blockTunes: {
    toggler: {
      "Click to tune": "",
      "or drag to move": ""
    }
  },
  inlineToolbar: {
    converter: {
      "Convert to": ""
    }
  },
  toolbar: {
    toolbox: {
      Add: ""
    }
  },
  popover: {
    Filter: "",
    "Nothing found": ""
  }
}, Zt = {
  Text: "",
  Link: "",
  Bold: "",
  Italic: ""
}, Gt = {
  link: {
    "Add a link": ""
  },
  stub: {
    "The block can not be displayed correctly.": ""
  }
}, Jt = {
  delete: {
    Delete: "",
    "Click to delete": ""
  },
  moveUp: {
    "Move up": ""
  },
  moveDown: {
    "Move down": ""
  }
}, ht = {
  ui: qt,
  toolNames: Zt,
  tools: Gt,
  blockTunes: Jt
}, ie = class {
  /**
   * Type-safe translation for internal UI texts:
   * Perform translation of the string by namespace and a key
   *
   * @example I18n.ui(I18nInternalNS.ui.blockTunes.toggler, 'Click to tune')
   * @param internalNamespace - path to translated string in dictionary
   * @param dictKey - dictionary key. Better to use default locale original text
   */
  static ui(s4, e2) {
    return ie._t(s4, e2);
  }
  /**
   * Translate for external strings that is not presented in default dictionary.
   * For example, for user-specified tool names
   *
   * @param namespace - path to translated string in dictionary
   * @param dictKey - dictionary key. Better to use default locale original text
   */
  static t(s4, e2) {
    return ie._t(s4, e2);
  }
  /**
   * Adjust module for using external dictionary
   *
   * @param dictionary - new messages list to override default
   */
  static setDictionary(s4) {
    ie.currentDictionary = s4;
  }
  /**
   * Perform translation both for internal and external namespaces
   * If there is no translation found, returns passed key as a translated message
   *
   * @param namespace - path to translated string in dictionary
   * @param dictKey - dictionary key. Better to use default locale original text
   */
  static _t(s4, e2) {
    const t2 = ie.getNamespace(s4);
    return !t2 || !t2[e2] ? e2 : t2[e2];
  }
  /**
   * Find messages section by namespace path
   *
   * @param namespace - path to section
   */
  static getNamespace(s4) {
    return s4.split(".").reduce((t2, o3) => !t2 || !Object.keys(t2).length ? {} : t2[o3], ie.currentDictionary);
  }
};
let z = ie;
z.currentDictionary = ht;
class ut extends Error {
}
class Ee {
  constructor() {
    this.subscribers = {};
  }
  /**
   * Subscribe any event on callback
   *
   * @param eventName - event name
   * @param callback - subscriber
   */
  on(e2, t2) {
    e2 in this.subscribers || (this.subscribers[e2] = []), this.subscribers[e2].push(t2);
  }
  /**
   * Subscribe any event on callback. Callback will be called once and be removed from subscribers array after call.
   *
   * @param eventName - event name
   * @param callback - subscriber
   */
  once(e2, t2) {
    e2 in this.subscribers || (this.subscribers[e2] = []);
    const o3 = (i2) => {
      const n3 = t2(i2), r4 = this.subscribers[e2].indexOf(o3);
      return r4 !== -1 && this.subscribers[e2].splice(r4, 1), n3;
    };
    this.subscribers[e2].push(o3);
  }
  /**
   * Emit callbacks with passed data
   *
   * @param eventName - event name
   * @param data - subscribers get this data when they were fired
   */
  emit(e2, t2) {
    W(this.subscribers) || !this.subscribers[e2] || this.subscribers[e2].reduce((o3, i2) => {
      const n3 = i2(o3);
      return n3 !== void 0 ? n3 : o3;
    }, t2);
  }
  /**
   * Unsubscribe callback from event
   *
   * @param eventName - event name
   * @param callback - event handler
   */
  off(e2, t2) {
    if (this.subscribers[e2] === void 0) {
      console.warn(`EventDispatcher .off(): there is no subscribers for event "${e2.toString()}". Probably, .off() called before .on()`);
      return;
    }
    for (let o3 = 0; o3 < this.subscribers[e2].length; o3++)
      if (this.subscribers[e2][o3] === t2) {
        delete this.subscribers[e2][o3];
        break;
      }
  }
  /**
   * Destroyer
   * clears subscribers list
   */
  destroy() {
    this.subscribers = {};
  }
}
function ee(s4) {
  Object.setPrototypeOf(this, {
    /**
     * Block id
     *
     * @returns {string}
     */
    get id() {
      return s4.id;
    },
    /**
     * Tool name
     *
     * @returns {string}
     */
    get name() {
      return s4.name;
    },
    /**
     * Tool config passed on Editor's initialization
     *
     * @returns {ToolConfig}
     */
    get config() {
      return s4.config;
    },
    /**
     * .ce-block element, that wraps plugin contents
     *
     * @returns {HTMLElement}
     */
    get holder() {
      return s4.holder;
    },
    /**
     * True if Block content is empty
     *
     * @returns {boolean}
     */
    get isEmpty() {
      return s4.isEmpty;
    },
    /**
     * True if Block is selected with Cross-Block selection
     *
     * @returns {boolean}
     */
    get selected() {
      return s4.selected;
    },
    /**
     * Set Block's stretch state
     *
     * @param {boolean} state — state to set
     */
    set stretched(t2) {
      s4.stretched = t2;
    },
    /**
     * True if Block is stretched
     *
     * @returns {boolean}
     */
    get stretched() {
      return s4.stretched;
    },
    /**
     * True if Block has inputs to be focused
     */
    get focusable() {
      return s4.focusable;
    },
    /**
     * Call Tool method with errors handler under-the-hood
     *
     * @param {string} methodName - method to call
     * @param {object} param - object with parameters
     * @returns {unknown}
     */
    call(t2, o3) {
      return s4.call(t2, o3);
    },
    /**
     * Save Block content
     *
     * @returns {Promise<void|SavedData>}
     */
    save() {
      return s4.save();
    },
    /**
     * Validate Block data
     *
     * @param {BlockToolData} data - data to validate
     * @returns {Promise<boolean>}
     */
    validate(t2) {
      return s4.validate(t2);
    },
    /**
     * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback
     * Can be useful for block changes invisible for editor core.
     */
    dispatchChange() {
      s4.dispatchChange();
    }
  });
}
class Fe {
  constructor() {
    this.allListeners = [];
  }
  /**
   * Assigns event listener on element and returns unique identifier
   *
   * @param {EventTarget} element - DOM element that needs to be listened
   * @param {string} eventType - event type
   * @param {Function} handler - method that will be fired on event
   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}
   */
  on(e2, t2, o3, i2 = false) {
    const n3 = Xt("l"), r4 = {
      id: n3,
      element: e2,
      eventType: t2,
      handler: o3,
      options: i2
    };
    if (!this.findOne(e2, t2, o3))
      return this.allListeners.push(r4), e2.addEventListener(t2, o3, i2), n3;
  }
  /**
   * Removes event listener from element
   *
   * @param {EventTarget} element - DOM element that we removing listener
   * @param {string} eventType - event type
   * @param {Function} handler - remove handler, if element listens several handlers on the same event type
   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}
   */
  off(e2, t2, o3, i2) {
    const n3 = this.findAll(e2, t2, o3);
    n3.forEach((r4, a3) => {
      const l2 = this.allListeners.indexOf(n3[a3]);
      l2 > -1 && (this.allListeners.splice(l2, 1), r4.element.removeEventListener(r4.eventType, r4.handler, r4.options));
    });
  }
  /**
   * Removes listener by id
   *
   * @param {string} id - listener identifier
   */
  offById(e2) {
    const t2 = this.findById(e2);
    t2 && t2.element.removeEventListener(t2.eventType, t2.handler, t2.options);
  }
  /**
   * Finds and returns first listener by passed params
   *
   * @param {EventTarget} element - event target
   * @param {string} [eventType] - event type
   * @param {Function} [handler] - event handler
   * @returns {ListenerData|null}
   */
  findOne(e2, t2, o3) {
    const i2 = this.findAll(e2, t2, o3);
    return i2.length > 0 ? i2[0] : null;
  }
  /**
   * Return all stored listeners by passed params
   *
   * @param {EventTarget} element - event target
   * @param {string} eventType - event type
   * @param {Function} handler - event handler
   * @returns {ListenerData[]}
   */
  findAll(e2, t2, o3) {
    let i2;
    const n3 = e2 ? this.findByEventTarget(e2) : [];
    return e2 && t2 && o3 ? i2 = n3.filter((r4) => r4.eventType === t2 && r4.handler === o3) : e2 && t2 ? i2 = n3.filter((r4) => r4.eventType === t2) : i2 = n3, i2;
  }
  /**
   * Removes all listeners
   */
  removeAll() {
    this.allListeners.map((e2) => {
      e2.element.removeEventListener(e2.eventType, e2.handler, e2.options);
    }), this.allListeners = [];
  }
  /**
   * Module cleanup on destruction
   */
  destroy() {
    this.removeAll();
  }
  /**
   * Search method: looks for listener by passed element
   *
   * @param {EventTarget} element - searching element
   * @returns {Array} listeners that found on element
   */
  findByEventTarget(e2) {
    return this.allListeners.filter((t2) => {
      if (t2.element === e2)
        return t2;
    });
  }
  /**
   * Search method: looks for listener by passed event type
   *
   * @param {string} eventType - event type
   * @returns {ListenerData[]} listeners that found on element
   */
  findByType(e2) {
    return this.allListeners.filter((t2) => {
      if (t2.eventType === e2)
        return t2;
    });
  }
  /**
   * Search method: looks for listener by passed handler
   *
   * @param {Function} handler - event handler
   * @returns {ListenerData[]} listeners that found on element
   */
  findByHandler(e2) {
    return this.allListeners.filter((t2) => {
      if (t2.handler === e2)
        return t2;
    });
  }
  /**
   * Returns listener data found by id
   *
   * @param {string} id - listener identifier
   * @returns {ListenerData}
   */
  findById(e2) {
    return this.allListeners.find((t2) => t2.id === e2);
  }
}
let y$1 = class y {
  /**
   * @class
   * @param options - Module options
   * @param options.config - Module config
   * @param options.eventsDispatcher - Common event bus
   */
  constructor({ config: e2, eventsDispatcher: t2 }) {
    if (this.nodes = {}, this.listeners = new Fe(), this.readOnlyMutableListeners = {
      /**
       * Assigns event listener on DOM element and pushes into special array that might be removed
       *
       * @param {EventTarget} element - DOM Element
       * @param {string} eventType - Event name
       * @param {Function} handler - Event handler
       * @param {boolean|AddEventListenerOptions} options - Listening options
       */
      on: (o3, i2, n3, r4 = false) => {
        this.mutableListenerIds.push(
          this.listeners.on(o3, i2, n3, r4)
        );
      },
      /**
       * Clears all mutable listeners
       */
      clearAll: () => {
        for (const o3 of this.mutableListenerIds)
          this.listeners.offById(o3);
        this.mutableListenerIds = [];
      }
    }, this.mutableListenerIds = [], new.target === y)
      throw new TypeError("Constructors for abstract class Module are not allowed.");
    this.config = e2, this.eventsDispatcher = t2;
  }
  /**
   * Editor modules setter
   *
   * @param {EditorModules} Editor - Editor's Modules
   */
  set state(e2) {
    this.Editor = e2;
  }
  /**
   * Remove memorized nodes
   */
  removeAllNodes() {
    for (const e2 in this.nodes) {
      const t2 = this.nodes[e2];
      t2 instanceof HTMLElement && t2.remove();
    }
  }
  /**
   * Returns true if current direction is RTL (Right-To-Left)
   */
  get isRtl() {
    return this.config.i18n.direction === "rtl";
  }
};
let b$1 = class b {
  constructor() {
    this.instance = null, this.selection = null, this.savedSelectionRange = null, this.isFakeBackgroundEnabled = false, this.commandBackground = "backColor", this.commandRemoveFormat = "removeFormat";
  }
  /**
   * Editor styles
   *
   * @returns {{editorWrapper: string, editorZone: string}}
   */
  static get CSS() {
    return {
      editorWrapper: "codex-editor",
      editorZone: "codex-editor__redactor"
    };
  }
  /**
   * Returns selected anchor
   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorNode}
   *
   * @returns {Node|null}
   */
  static get anchorNode() {
    const e2 = window.getSelection();
    return e2 ? e2.anchorNode : null;
  }
  /**
   * Returns selected anchor element
   *
   * @returns {Element|null}
   */
  static get anchorElement() {
    const e2 = window.getSelection();
    if (!e2)
      return null;
    const t2 = e2.anchorNode;
    return t2 ? c$4.isElement(t2) ? t2 : t2.parentElement : null;
  }
  /**
   * Returns selection offset according to the anchor node
   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorOffset}
   *
   * @returns {number|null}
   */
  static get anchorOffset() {
    const e2 = window.getSelection();
    return e2 ? e2.anchorOffset : null;
  }
  /**
   * Is current selection range collapsed
   *
   * @returns {boolean|null}
   */
  static get isCollapsed() {
    const e2 = window.getSelection();
    return e2 ? e2.isCollapsed : null;
  }
  /**
   * Check current selection if it is at Editor's zone
   *
   * @returns {boolean}
   */
  static get isAtEditor() {
    return this.isSelectionAtEditor(b.get());
  }
  /**
   * Check if passed selection is at Editor's zone
   *
   * @param selection - Selection object to check
   */
  static isSelectionAtEditor(e2) {
    if (!e2)
      return false;
    let t2 = e2.anchorNode || e2.focusNode;
    t2 && t2.nodeType === Node.TEXT_NODE && (t2 = t2.parentNode);
    let o3 = null;
    return t2 && t2 instanceof Element && (o3 = t2.closest(`.${b.CSS.editorZone}`)), o3 ? o3.nodeType === Node.ELEMENT_NODE : false;
  }
  /**
   * Check if passed range at Editor zone
   *
   * @param range - range to check
   */
  static isRangeAtEditor(e2) {
    if (!e2)
      return;
    let t2 = e2.startContainer;
    t2 && t2.nodeType === Node.TEXT_NODE && (t2 = t2.parentNode);
    let o3 = null;
    return t2 && t2 instanceof Element && (o3 = t2.closest(`.${b.CSS.editorZone}`)), o3 ? o3.nodeType === Node.ELEMENT_NODE : false;
  }
  /**
   * Methods return boolean that true if selection exists on the page
   */
  static get isSelectionExists() {
    return !!b.get().anchorNode;
  }
  /**
   * Return first range
   *
   * @returns {Range|null}
   */
  static get range() {
    return this.getRangeFromSelection(this.get());
  }
  /**
   * Returns range from passed Selection object
   *
   * @param selection - Selection object to get Range from
   */
  static getRangeFromSelection(e2) {
    return e2 && e2.rangeCount ? e2.getRangeAt(0) : null;
  }
  /**
   * Calculates position and size of selected text
   *
   * @returns {DOMRect | ClientRect}
   */
  static get rect() {
    let e2 = document.selection, t2, o3 = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    if (e2 && e2.type !== "Control")
      return e2 = e2, t2 = e2.createRange(), o3.x = t2.boundingLeft, o3.y = t2.boundingTop, o3.width = t2.boundingWidth, o3.height = t2.boundingHeight, o3;
    if (!window.getSelection)
      return T$1("Method window.getSelection is not supported", "warn"), o3;
    if (e2 = window.getSelection(), e2.rangeCount === null || isNaN(e2.rangeCount))
      return T$1("Method SelectionUtils.rangeCount is not supported", "warn"), o3;
    if (e2.rangeCount === 0)
      return o3;
    if (t2 = e2.getRangeAt(0).cloneRange(), t2.getBoundingClientRect && (o3 = t2.getBoundingClientRect()), o3.x === 0 && o3.y === 0) {
      const i2 = document.createElement("span");
      if (i2.getBoundingClientRect) {
        i2.appendChild(document.createTextNode("​")), t2.insertNode(i2), o3 = i2.getBoundingClientRect();
        const n3 = i2.parentNode;
        n3.removeChild(i2), n3.normalize();
      }
    }
    return o3;
  }
  /**
   * Returns selected text as String
   *
   * @returns {string}
   */
  static get text() {
    return window.getSelection ? window.getSelection().toString() : "";
  }
  /**
   * Returns window SelectionUtils
   * {@link https://developer.mozilla.org/ru/docs/Web/API/Window/getSelection}
   *
   * @returns {Selection}
   */
  static get() {
    return window.getSelection();
  }
  /**
   * Set focus to contenteditable or native input element
   *
   * @param element - element where to set focus
   * @param offset - offset of cursor
   */
  static setCursor(e2, t2 = 0) {
    const o3 = document.createRange(), i2 = window.getSelection();
    return c$4.isNativeInput(e2) ? c$4.canSetCaret(e2) ? (e2.focus(), e2.selectionStart = e2.selectionEnd = t2, e2.getBoundingClientRect()) : void 0 : (o3.setStart(e2, t2), o3.setEnd(e2, t2), i2.removeAllRanges(), i2.addRange(o3), o3.getBoundingClientRect());
  }
  /**
   * Check if current range exists and belongs to container
   *
   * @param container - where range should be
   */
  static isRangeInsideContainer(e2) {
    const t2 = b.range;
    return t2 === null ? false : e2.contains(t2.startContainer);
  }
  /**
   * Adds fake cursor to the current range
   */
  static addFakeCursor() {
    const e2 = b.range;
    if (e2 === null)
      return;
    const t2 = c$4.make("span", "codex-editor__fake-cursor");
    t2.dataset.mutationFree = "true", e2.collapse(), e2.insertNode(t2);
  }
  /**
   * Check if passed element contains a fake cursor
   *
   * @param el - where to check
   */
  static isFakeCursorInsideContainer(e2) {
    return c$4.find(e2, ".codex-editor__fake-cursor") !== null;
  }
  /**
   * Removes fake cursor from a container
   *
   * @param container - container to look for
   */
  static removeFakeCursor(e2 = document.body) {
    const t2 = c$4.find(e2, ".codex-editor__fake-cursor");
    t2 && t2.remove();
  }
  /**
   * Removes fake background
   */
  removeFakeBackground() {
    this.isFakeBackgroundEnabled && (this.isFakeBackgroundEnabled = false, document.execCommand(this.commandRemoveFormat));
  }
  /**
   * Sets fake background
   */
  setFakeBackground() {
    document.execCommand(this.commandBackground, false, "#a8d6ff"), this.isFakeBackgroundEnabled = true;
  }
  /**
   * Save SelectionUtils's range
   */
  save() {
    this.savedSelectionRange = b.range;
  }
  /**
   * Restore saved SelectionUtils's range
   */
  restore() {
    if (!this.savedSelectionRange)
      return;
    const e2 = window.getSelection();
    e2.removeAllRanges(), e2.addRange(this.savedSelectionRange);
  }
  /**
   * Clears saved selection
   */
  clearSaved() {
    this.savedSelectionRange = null;
  }
  /**
   * Collapse current selection
   */
  collapseToEnd() {
    const e2 = window.getSelection(), t2 = document.createRange();
    t2.selectNodeContents(e2.focusNode), t2.collapse(false), e2.removeAllRanges(), e2.addRange(t2);
  }
  /**
   * Looks ahead to find passed tag from current selection
   *
   * @param  {string} tagName       - tag to found
   * @param  {string} [className]   - tag's class name
   * @param  {number} [searchDepth] - count of tags that can be included. For better performance.
   * @returns {HTMLElement|null}
   */
  findParentTag(e2, t2, o3 = 10) {
    const i2 = window.getSelection();
    let n3 = null;
    return !i2 || !i2.anchorNode || !i2.focusNode ? null : ([
      /** the Node in which the selection begins */
      i2.anchorNode,
      /** the Node in which the selection ends */
      i2.focusNode
    ].forEach((a3) => {
      let l2 = o3;
      for (; l2 > 0 && a3.parentNode && !(a3.tagName === e2 && (n3 = a3, t2 && a3.classList && !a3.classList.contains(t2) && (n3 = null), n3)); )
        a3 = a3.parentNode, l2--;
    }), n3);
  }
  /**
   * Expands selection range to the passed parent node
   *
   * @param {HTMLElement} element - element which contents should be selected
   */
  expandToTag(e2) {
    const t2 = window.getSelection();
    t2.removeAllRanges();
    const o3 = document.createRange();
    o3.selectNodeContents(e2), t2.addRange(o3);
  }
};
function Qt(s4, e2) {
  const { type: t2, target: o3, addedNodes: i2, removedNodes: n3 } = s4;
  if (o3 === e2)
    return true;
  if (["characterData", "attributes"].includes(t2)) {
    const l2 = o3.nodeType === Node.TEXT_NODE ? o3.parentNode : o3;
    return e2.contains(l2);
  }
  const r4 = Array.from(i2).some((l2) => e2.contains(l2)), a3 = Array.from(n3).some((l2) => e2.contains(l2));
  return r4 || a3;
}
const Ae = "redactor dom changed", pt = "block changed", ft = "fake cursor is about to be toggled", gt = "fake cursor have been set";
function ot(s4, e2) {
  return s4.mergeable && s4.name === e2.name;
}
function eo(s4, e2) {
  const t2 = e2 == null ? void 0 : e2.export;
  return M$2(t2) ? t2(s4) : G(t2) ? s4[t2] : (t2 !== void 0 && T$1("Conversion «export» property must be a string or function. String means key of saved data object to export. Function should export processed string to export."), "");
}
function to(s4, e2) {
  const t2 = e2 == null ? void 0 : e2.import;
  return M$2(t2) ? t2(s4) : G(t2) ? {
    [t2]: s4
  } : (t2 !== void 0 && T$1("Conversion «import» property must be a string or function. String means key of tool data to import. Function accepts a imported string and return composed tool data."), {});
}
var X = /* @__PURE__ */ ((s4) => (s4.APPEND_CALLBACK = "appendCallback", s4.RENDERED = "rendered", s4.MOVED = "moved", s4.UPDATED = "updated", s4.REMOVED = "removed", s4.ON_PASTE = "onPaste", s4))(X || {});
let R$3 = class R extends Ee {
  /**
   * @param options - block constructor options
   * @param [options.id] - block's id. Will be generated if omitted.
   * @param options.data - Tool's initial data
   * @param options.tool — block's tool
   * @param options.api - Editor API module for pass it to the Block Tunes
   * @param options.readOnly - Read-Only flag
   * @param [eventBus] - Editor common event bus. Allows to subscribe on some Editor events. Could be omitted when "virtual" Block is created. See BlocksAPI@composeBlockData.
   */
  constructor({
    id: e2 = Yt(),
    data: t2,
    tool: o3,
    api: i2,
    readOnly: n3,
    tunesData: r4
  }, a3) {
    super(), this.cachedInputs = [], this.toolRenderedElement = null, this.tunesInstances = /* @__PURE__ */ new Map(), this.defaultTunesInstances = /* @__PURE__ */ new Map(), this.unavailableTunesData = {}, this.inputIndex = 0, this.editorEventBus = null, this.handleFocus = () => {
      this.dropInputsCache(), this.updateCurrentInput();
    }, this.didMutated = (l2 = void 0) => {
      const d4 = l2 === void 0, u3 = l2 instanceof InputEvent;
      !d4 && !u3 && this.detectToolRootChange(l2);
      let h2;
      d4 || u3 ? h2 = true : h2 = !(l2.length > 0 && l2.every((x2) => {
        const { addedNodes: p2, removedNodes: m3, target: L2 } = x2;
        return [
          ...Array.from(p2),
          ...Array.from(m3),
          L2
        ].some((S2) => (c$4.isElement(S2) || (S2 = S2.parentElement), S2 && S2.closest('[data-mutation-free="true"]') !== null));
      })), h2 && (this.dropInputsCache(), this.updateCurrentInput(), this.call(
        "updated"
        /* UPDATED */
      ), this.emit("didMutated", this));
    }, this.name = o3.name, this.id = e2, this.settings = o3.settings, this.config = o3.settings.config || {}, this.api = i2, this.editorEventBus = a3 || null, this.blockAPI = new ee(this), this.tool = o3, this.toolInstance = o3.create(t2, this.blockAPI, n3), this.tunes = o3.tunes, this.composeTunes(r4), this.holder = this.compose(), window.requestIdleCallback(() => {
      this.watchBlockMutations(), this.addInputEvents();
    });
  }
  /**
   * CSS classes for the Block
   *
   * @returns {{wrapper: string, content: string}}
   */
  static get CSS() {
    return {
      wrapper: "ce-block",
      wrapperStretched: "ce-block--stretched",
      content: "ce-block__content",
      selected: "ce-block--selected",
      dropTarget: "ce-block--drop-target"
    };
  }
  /**
   * Find and return all editable elements (contenteditable and native inputs) in the Tool HTML
   *
   * @returns {HTMLElement[]}
   */
  get inputs() {
    if (this.cachedInputs.length !== 0)
      return this.cachedInputs;
    const e2 = c$4.findAllInputs(this.holder);
    return this.inputIndex > e2.length - 1 && (this.inputIndex = e2.length - 1), this.cachedInputs = e2, e2;
  }
  /**
   * Return current Tool`s input
   *
   * @returns {HTMLElement}
   */
  get currentInput() {
    return this.inputs[this.inputIndex];
  }
  /**
   * Set input index to the passed element
   *
   * @param {HTMLElement | Node} element - HTML Element to set as current input
   */
  set currentInput(e2) {
    const t2 = this.inputs.findIndex((o3) => o3 === e2 || o3.contains(e2));
    t2 !== -1 && (this.inputIndex = t2);
  }
  /**
   * Return first Tool`s input
   *
   * @returns {HTMLElement}
   */
  get firstInput() {
    return this.inputs[0];
  }
  /**
   * Return first Tool`s input
   *
   * @returns {HTMLElement}
   */
  get lastInput() {
    const e2 = this.inputs;
    return e2[e2.length - 1];
  }
  /**
   * Return next Tool`s input or undefined if it doesn't exist
   *
   * @returns {HTMLElement}
   */
  get nextInput() {
    return this.inputs[this.inputIndex + 1];
  }
  /**
   * Return previous Tool`s input or undefined if it doesn't exist
   *
   * @returns {HTMLElement}
   */
  get previousInput() {
    return this.inputs[this.inputIndex - 1];
  }
  /**
   * Get Block's JSON data
   *
   * @returns {object}
   */
  get data() {
    return this.save().then((e2) => e2 && !W(e2.data) ? e2.data : {});
  }
  /**
   * Returns tool's sanitizer config
   *
   * @returns {object}
   */
  get sanitize() {
    return this.tool.sanitizeConfig;
  }
  /**
   * is block mergeable
   * We plugin have merge function then we call it mergeable
   *
   * @returns {boolean}
   */
  get mergeable() {
    return M$2(this.toolInstance.merge);
  }
  /**
   * If Block contains inputs, it is focusable
   */
  get focusable() {
    return this.inputs.length !== 0;
  }
  /**
   * Check block for emptiness
   *
   * @returns {boolean}
   */
  get isEmpty() {
    const e2 = c$4.isEmpty(this.pluginsContent, "/"), t2 = !this.hasMedia;
    return e2 && t2;
  }
  /**
   * Check if block has a media content such as images, iframe and other
   *
   * @returns {boolean}
   */
  get hasMedia() {
    const e2 = [
      "img",
      "iframe",
      "video",
      "audio",
      "source",
      "input",
      "textarea",
      "twitterwidget"
    ];
    return !!this.holder.querySelector(e2.join(","));
  }
  /**
   * Set selected state
   * We don't need to mark Block as Selected when it is empty
   *
   * @param {boolean} state - 'true' to select, 'false' to remove selection
   */
  set selected(e2) {
    var i2, n3;
    this.holder.classList.toggle(R.CSS.selected, e2);
    const t2 = e2 === true && b$1.isRangeInsideContainer(this.holder), o3 = e2 === false && b$1.isFakeCursorInsideContainer(this.holder);
    (t2 || o3) && ((i2 = this.editorEventBus) == null || i2.emit(ft, { state: e2 }), t2 ? b$1.addFakeCursor() : b$1.removeFakeCursor(this.holder), (n3 = this.editorEventBus) == null || n3.emit(gt, { state: e2 }));
  }
  /**
   * Returns True if it is Selected
   *
   * @returns {boolean}
   */
  get selected() {
    return this.holder.classList.contains(R.CSS.selected);
  }
  /**
   * Set stretched state
   *
   * @param {boolean} state - 'true' to enable, 'false' to disable stretched state
   */
  set stretched(e2) {
    this.holder.classList.toggle(R.CSS.wrapperStretched, e2);
  }
  /**
   * Return Block's stretched state
   *
   * @returns {boolean}
   */
  get stretched() {
    return this.holder.classList.contains(R.CSS.wrapperStretched);
  }
  /**
   * Toggle drop target state
   *
   * @param {boolean} state - 'true' if block is drop target, false otherwise
   */
  set dropTarget(e2) {
    this.holder.classList.toggle(R.CSS.dropTarget, e2);
  }
  /**
   * Returns Plugins content
   *
   * @returns {HTMLElement}
   */
  get pluginsContent() {
    return this.toolRenderedElement;
  }
  /**
   * Calls Tool's method
   *
   * Method checks tool property {MethodName}. Fires method with passes params If it is instance of Function
   *
   * @param {string} methodName - method to call
   * @param {object} params - method argument
   */
  call(e2, t2) {
    if (M$2(this.toolInstance[e2])) {
      e2 === "appendCallback" && T$1(
        "`appendCallback` hook is deprecated and will be removed in the next major release. Use `rendered` hook instead",
        "warn"
      );
      try {
        this.toolInstance[e2].call(this.toolInstance, t2);
      } catch (o3) {
        T$1(`Error during '${e2}' call: ${o3.message}`, "error");
      }
    }
  }
  /**
   * Call plugins merge method
   *
   * @param {BlockToolData} data - data to merge
   */
  async mergeWith(e2) {
    await this.toolInstance.merge(e2);
  }
  /**
   * Extracts data from Block
   * Groups Tool's save processing time
   *
   * @returns {object}
   */
  async save() {
    const e2 = await this.toolInstance.save(this.pluginsContent), t2 = this.unavailableTunesData;
    [
      ...this.tunesInstances.entries(),
      ...this.defaultTunesInstances.entries()
    ].forEach(([n3, r4]) => {
      if (M$2(r4.save))
        try {
          t2[n3] = r4.save();
        } catch (a3) {
          T$1(`Tune ${r4.constructor.name} save method throws an Error %o`, "warn", a3);
        }
    });
    const o3 = window.performance.now();
    let i2;
    return Promise.resolve(e2).then((n3) => (i2 = window.performance.now(), {
      id: this.id,
      tool: this.name,
      data: n3,
      tunes: t2,
      time: i2 - o3
    })).catch((n3) => {
      T$1(`Saving process for ${this.name} tool failed due to the ${n3}`, "log", "red");
    });
  }
  /**
   * Uses Tool's validation method to check the correctness of output data
   * Tool's validation method is optional
   *
   * @description Method returns true|false whether data passed the validation or not
   * @param {BlockToolData} data - data to validate
   * @returns {Promise<boolean>} valid
   */
  async validate(e2) {
    let t2 = true;
    return this.toolInstance.validate instanceof Function && (t2 = await this.toolInstance.validate(e2)), t2;
  }
  /**
   * Returns data to render in tunes menu.
   * Splits block tunes settings into 2 groups: popover items and custom html.
   */
  getTunes() {
    const e2 = document.createElement("div"), t2 = [], o3 = typeof this.toolInstance.renderSettings == "function" ? this.toolInstance.renderSettings() : [], i2 = [
      ...this.tunesInstances.values(),
      ...this.defaultTunesInstances.values()
    ].map((n3) => n3.render());
    return [o3, i2].flat().forEach((n3) => {
      c$4.isElement(n3) ? e2.appendChild(n3) : Array.isArray(n3) ? t2.push(...n3) : t2.push(n3);
    }), [t2, e2];
  }
  /**
   * Update current input index with selection anchor node
   */
  updateCurrentInput() {
    this.currentInput = c$4.isNativeInput(document.activeElement) || !b$1.anchorNode ? document.activeElement : b$1.anchorNode;
  }
  /**
   * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback
   * Can be useful for block changes invisible for editor core.
   */
  dispatchChange() {
    this.didMutated();
  }
  /**
   * Call Tool instance destroy method
   */
  destroy() {
    this.unwatchBlockMutations(), this.removeInputEvents(), super.destroy(), M$2(this.toolInstance.destroy) && this.toolInstance.destroy();
  }
  /**
   * Tool could specify several entries to be displayed at the Toolbox (for example, "Heading 1", "Heading 2", "Heading 3")
   * This method returns the entry that is related to the Block (depended on the Block data)
   */
  async getActiveToolboxEntry() {
    const e2 = this.tool.toolbox;
    if (e2.length === 1)
      return Promise.resolve(this.tool.toolbox[0]);
    const t2 = await this.data;
    return e2.find((i2) => Object.entries(i2.data).some(([n3, r4]) => t2[n3] && Vt(t2[n3], r4)));
  }
  /**
   * Exports Block data as string using conversion config
   */
  async exportDataAsString() {
    const e2 = await this.data;
    return eo(e2, this.tool.conversionConfig);
  }
  /**
   * Make default Block wrappers and put Tool`s content there
   *
   * @returns {HTMLDivElement}
   */
  compose() {
    const e2 = c$4.make("div", R.CSS.wrapper), t2 = c$4.make("div", R.CSS.content), o3 = this.toolInstance.render();
    e2.dataset.id = this.id, this.toolRenderedElement = o3, t2.appendChild(this.toolRenderedElement);
    let i2 = t2;
    return [...this.tunesInstances.values(), ...this.defaultTunesInstances.values()].forEach((n3) => {
      if (M$2(n3.wrap))
        try {
          i2 = n3.wrap(i2);
        } catch (r4) {
          T$1(`Tune ${n3.constructor.name} wrap method throws an Error %o`, "warn", r4);
        }
    }), e2.appendChild(i2), e2;
  }
  /**
   * Instantiate Block Tunes
   *
   * @param tunesData - current Block tunes data
   * @private
   */
  composeTunes(e2) {
    Array.from(this.tunes.values()).forEach((t2) => {
      (t2.isInternal ? this.defaultTunesInstances : this.tunesInstances).set(t2.name, t2.create(e2[t2.name], this.blockAPI));
    }), Object.entries(e2).forEach(([t2, o3]) => {
      this.tunesInstances.has(t2) || (this.unavailableTunesData[t2] = o3);
    });
  }
  /**
   * Adds focus event listeners to all inputs and contenteditable
   */
  addInputEvents() {
    this.inputs.forEach((e2) => {
      e2.addEventListener("focus", this.handleFocus), c$4.isNativeInput(e2) && e2.addEventListener("input", this.didMutated);
    });
  }
  /**
   * removes focus event listeners from all inputs and contenteditable
   */
  removeInputEvents() {
    this.inputs.forEach((e2) => {
      e2.removeEventListener("focus", this.handleFocus), c$4.isNativeInput(e2) && e2.removeEventListener("input", this.didMutated);
    });
  }
  /**
   * Listen common editor Dom Changed event and detect mutations related to the  Block
   */
  watchBlockMutations() {
    var e2;
    this.redactorDomChangedCallback = (t2) => {
      const { mutations: o3 } = t2;
      o3.some((n3) => Qt(n3, this.toolRenderedElement)) && this.didMutated(o3);
    }, (e2 = this.editorEventBus) == null || e2.on(Ae, this.redactorDomChangedCallback);
  }
  /**
   * Remove redactor dom change event listener
   */
  unwatchBlockMutations() {
    var e2;
    (e2 = this.editorEventBus) == null || e2.off(Ae, this.redactorDomChangedCallback);
  }
  /**
   * Sometimes Tool can replace own main element, for example H2 -> H4 or UL -> OL
   * We need to detect such changes and update a link to tools main element with the new one
   *
   * @param mutations - records of block content mutations
   */
  detectToolRootChange(e2) {
    e2.forEach((t2) => {
      if (Array.from(t2.removedNodes).includes(this.toolRenderedElement)) {
        const i2 = t2.addedNodes[t2.addedNodes.length - 1];
        this.toolRenderedElement = i2;
      }
    });
  }
  /**
   * Clears inputs cached value
   */
  dropInputsCache() {
    this.cachedInputs = [];
  }
};
class oo extends y$1 {
  constructor() {
    super(...arguments), this.insert = (e2 = this.config.defaultBlock, t2 = {}, o3 = {}, i2, n3, r4, a3) => {
      const l2 = this.Editor.BlockManager.insert({
        id: a3,
        tool: e2,
        data: t2,
        index: i2,
        needToFocus: n3,
        replace: r4
      });
      return new ee(l2);
    }, this.composeBlockData = async (e2) => {
      const t2 = this.Editor.Tools.blockTools.get(e2);
      return new R$3({
        tool: t2,
        api: this.Editor.API,
        readOnly: true,
        data: {},
        tunesData: {}
      }).data;
    }, this.update = async (e2, t2) => {
      const { BlockManager: o3 } = this.Editor, i2 = o3.getBlockById(e2);
      if (i2 === void 0)
        throw new Error(`Block with id "${e2}" not found`);
      const n3 = await o3.update(i2, t2);
      return new ee(n3);
    }, this.convert = (e2, t2, o3) => {
      var h2, f2;
      const { BlockManager: i2, Tools: n3 } = this.Editor, r4 = i2.getBlockById(e2);
      if (!r4)
        throw new Error(`Block with id "${e2}" not found`);
      const a3 = n3.blockTools.get(r4.name), l2 = n3.blockTools.get(t2);
      if (!l2)
        throw new Error(`Block Tool with type "${t2}" not found`);
      const d4 = ((h2 = a3 == null ? void 0 : a3.conversionConfig) == null ? void 0 : h2.export) !== void 0, u3 = ((f2 = l2.conversionConfig) == null ? void 0 : f2.import) !== void 0;
      if (d4 && u3)
        i2.convert(r4, t2, o3);
      else {
        const x2 = [
          d4 ? false : re(r4.name),
          u3 ? false : re(t2)
        ].filter(Boolean).join(" and ");
        throw new Error(`Conversion from "${r4.name}" to "${t2}" is not possible. ${x2} tool(s) should provide a "conversionConfig"`);
      }
    }, this.insertMany = (e2, t2 = this.Editor.BlockManager.blocks.length - 1) => {
      this.validateIndex(t2);
      const o3 = e2.map(({ id: i2, type: n3, data: r4 }) => this.Editor.BlockManager.composeBlock({
        id: i2,
        tool: n3 || this.config.defaultBlock,
        data: r4
      }));
      return this.Editor.BlockManager.insertMany(o3, t2), o3.map((i2) => new ee(i2));
    };
  }
  /**
   * Available methods
   *
   * @returns {Blocks}
   */
  get methods() {
    return {
      clear: () => this.clear(),
      render: (e2) => this.render(e2),
      renderFromHTML: (e2) => this.renderFromHTML(e2),
      delete: (e2) => this.delete(e2),
      swap: (e2, t2) => this.swap(e2, t2),
      move: (e2, t2) => this.move(e2, t2),
      getBlockByIndex: (e2) => this.getBlockByIndex(e2),
      getById: (e2) => this.getById(e2),
      getCurrentBlockIndex: () => this.getCurrentBlockIndex(),
      getBlockIndex: (e2) => this.getBlockIndex(e2),
      getBlocksCount: () => this.getBlocksCount(),
      stretchBlock: (e2, t2 = true) => this.stretchBlock(e2, t2),
      insertNewBlock: () => this.insertNewBlock(),
      insert: this.insert,
      insertMany: this.insertMany,
      update: this.update,
      composeBlockData: this.composeBlockData,
      convert: this.convert
    };
  }
  /**
   * Returns Blocks count
   *
   * @returns {number}
   */
  getBlocksCount() {
    return this.Editor.BlockManager.blocks.length;
  }
  /**
   * Returns current block index
   *
   * @returns {number}
   */
  getCurrentBlockIndex() {
    return this.Editor.BlockManager.currentBlockIndex;
  }
  /**
   * Returns the index of Block by id;
   *
   * @param id - block id
   */
  getBlockIndex(e2) {
    const t2 = this.Editor.BlockManager.getBlockById(e2);
    if (!t2) {
      Y("There is no block with id `" + e2 + "`", "warn");
      return;
    }
    return this.Editor.BlockManager.getBlockIndex(t2);
  }
  /**
   * Returns BlockAPI object by Block index
   *
   * @param {number} index - index to get
   */
  getBlockByIndex(e2) {
    const t2 = this.Editor.BlockManager.getBlockByIndex(e2);
    if (t2 === void 0) {
      Y("There is no block at index `" + e2 + "`", "warn");
      return;
    }
    return new ee(t2);
  }
  /**
   * Returns BlockAPI object by Block id
   *
   * @param id - id of block to get
   */
  getById(e2) {
    const t2 = this.Editor.BlockManager.getBlockById(e2);
    return t2 === void 0 ? (Y("There is no block with id `" + e2 + "`", "warn"), null) : new ee(t2);
  }
  /**
   * Call Block Manager method that swap Blocks
   *
   * @param {number} fromIndex - position of first Block
   * @param {number} toIndex - position of second Block
   * @deprecated — use 'move' instead
   */
  swap(e2, t2) {
    T$1(
      "`blocks.swap()` method is deprecated and will be removed in the next major release. Use `block.move()` method instead",
      "info"
    ), this.Editor.BlockManager.swap(e2, t2);
  }
  /**
   * Move block from one index to another
   *
   * @param {number} toIndex - index to move to
   * @param {number} fromIndex - index to move from
   */
  move(e2, t2) {
    this.Editor.BlockManager.move(e2, t2);
  }
  /**
   * Deletes Block
   *
   * @param {number} blockIndex - index of Block to delete
   */
  delete(e2 = this.Editor.BlockManager.currentBlockIndex) {
    try {
      const t2 = this.Editor.BlockManager.getBlockByIndex(e2);
      this.Editor.BlockManager.removeBlock(t2);
    } catch (t2) {
      Y(t2, "warn");
      return;
    }
    this.Editor.BlockManager.blocks.length === 0 && this.Editor.BlockManager.insert(), this.Editor.BlockManager.currentBlock && this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END), this.Editor.Toolbar.close();
  }
  /**
   * Clear Editor's area
   */
  async clear() {
    await this.Editor.BlockManager.clear(true), this.Editor.InlineToolbar.close();
  }
  /**
   * Fills Editor with Blocks data
   *
   * @param {OutputData} data — Saved Editor data
   */
  async render(e2) {
    if (e2 === void 0 || e2.blocks === void 0)
      throw new Error("Incorrect data passed to the render() method");
    this.Editor.ModificationsObserver.disable(), await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(e2.blocks), this.Editor.ModificationsObserver.enable();
  }
  /**
   * Render passed HTML string
   *
   * @param {string} data - HTML string to render
   * @returns {Promise<void>}
   */
  renderFromHTML(e2) {
    return this.Editor.BlockManager.clear(), this.Editor.Paste.processText(e2, true);
  }
  /**
   * Stretch Block's content
   *
   * @param {number} index - index of Block to stretch
   * @param {boolean} status - true to enable, false to disable
   * @deprecated Use BlockAPI interface to stretch Blocks
   */
  stretchBlock(e2, t2 = true) {
    Le(
      true,
      "blocks.stretchBlock()",
      "BlockAPI"
    );
    const o3 = this.Editor.BlockManager.getBlockByIndex(e2);
    o3 && (o3.stretched = t2);
  }
  /**
   * Insert new Block
   * After set caret to this Block
   *
   * @todo remove in 3.0.0
   * @deprecated with insert() method
   */
  insertNewBlock() {
    T$1("Method blocks.insertNewBlock() is deprecated and it will be removed in the next major release. Use blocks.insert() instead.", "warn"), this.insert();
  }
  /**
   * Validated block index and throws an error if it's invalid
   *
   * @param index - index to validate
   */
  validateIndex(e2) {
    if (typeof e2 != "number")
      throw new Error("Index should be a number");
    if (e2 < 0)
      throw new Error("Index should be greater than or equal to 0");
    if (e2 === null)
      throw new Error("Index should be greater than or equal to 0");
  }
}
class io extends y$1 {
  constructor() {
    super(...arguments), this.setToFirstBlock = (e2 = this.Editor.Caret.positions.DEFAULT, t2 = 0) => this.Editor.BlockManager.firstBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.firstBlock, e2, t2), true) : false, this.setToLastBlock = (e2 = this.Editor.Caret.positions.DEFAULT, t2 = 0) => this.Editor.BlockManager.lastBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.lastBlock, e2, t2), true) : false, this.setToPreviousBlock = (e2 = this.Editor.Caret.positions.DEFAULT, t2 = 0) => this.Editor.BlockManager.previousBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.previousBlock, e2, t2), true) : false, this.setToNextBlock = (e2 = this.Editor.Caret.positions.DEFAULT, t2 = 0) => this.Editor.BlockManager.nextBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.nextBlock, e2, t2), true) : false, this.setToBlock = (e2, t2 = this.Editor.Caret.positions.DEFAULT, o3 = 0) => this.Editor.BlockManager.blocks[e2] ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.blocks[e2], t2, o3), true) : false, this.focus = (e2 = false) => e2 ? this.setToLastBlock(this.Editor.Caret.positions.END) : this.setToFirstBlock(this.Editor.Caret.positions.START);
  }
  /**
   * Available methods
   *
   * @returns {Caret}
   */
  get methods() {
    return {
      setToFirstBlock: this.setToFirstBlock,
      setToLastBlock: this.setToLastBlock,
      setToPreviousBlock: this.setToPreviousBlock,
      setToNextBlock: this.setToNextBlock,
      setToBlock: this.setToBlock,
      focus: this.focus
    };
  }
}
class no extends y$1 {
  /**
   * Available methods
   *
   * @returns {Events}
   */
  get methods() {
    return {
      emit: (e2, t2) => this.emit(e2, t2),
      off: (e2, t2) => this.off(e2, t2),
      on: (e2, t2) => this.on(e2, t2)
    };
  }
  /**
   * Subscribe on Events
   *
   * @param {string} eventName - event name to subscribe
   * @param {Function} callback - event handler
   */
  on(e2, t2) {
    this.eventsDispatcher.on(e2, t2);
  }
  /**
   * Emit event with data
   *
   * @param {string} eventName - event to emit
   * @param {object} data - event's data
   */
  emit(e2, t2) {
    this.eventsDispatcher.emit(e2, t2);
  }
  /**
   * Unsubscribe from Event
   *
   * @param {string} eventName - event to unsubscribe
   * @param {Function} callback - event handler
   */
  off(e2, t2) {
    this.eventsDispatcher.off(e2, t2);
  }
}
class He extends y$1 {
  /**
   * Return namespace section for tool or block tune
   *
   * @param tool - tool object
   */
  static getNamespace(e2) {
    return e2.isTune() ? `blockTunes.${e2.name}` : `tools.${e2.name}`;
  }
  /**
   * Return I18n API methods with global dictionary access
   */
  get methods() {
    return {
      t: () => {
        Y("I18n.t() method can be accessed only from Tools", "warn");
      }
    };
  }
  /**
   * Return I18n API methods with tool namespaced dictionary
   *
   * @param tool - Tool object
   */
  getMethodsForTool(e2) {
    return Object.assign(
      this.methods,
      {
        t: (t2) => z.t(He.getNamespace(e2), t2)
      }
    );
  }
}
class so extends y$1 {
  /**
   * Editor.js Core API modules
   */
  get methods() {
    return {
      blocks: this.Editor.BlocksAPI.methods,
      caret: this.Editor.CaretAPI.methods,
      events: this.Editor.EventsAPI.methods,
      listeners: this.Editor.ListenersAPI.methods,
      notifier: this.Editor.NotifierAPI.methods,
      sanitizer: this.Editor.SanitizerAPI.methods,
      saver: this.Editor.SaverAPI.methods,
      selection: this.Editor.SelectionAPI.methods,
      styles: this.Editor.StylesAPI.classes,
      toolbar: this.Editor.ToolbarAPI.methods,
      inlineToolbar: this.Editor.InlineToolbarAPI.methods,
      tooltip: this.Editor.TooltipAPI.methods,
      i18n: this.Editor.I18nAPI.methods,
      readOnly: this.Editor.ReadOnlyAPI.methods,
      ui: this.Editor.UiAPI.methods
    };
  }
  /**
   * Returns Editor.js Core API methods for passed tool
   *
   * @param tool - tool object
   */
  getMethodsForTool(e2) {
    return Object.assign(
      this.methods,
      {
        i18n: this.Editor.I18nAPI.getMethodsForTool(e2)
      }
    );
  }
}
class ro extends y$1 {
  /**
   * Available methods
   *
   * @returns {InlineToolbar}
   */
  get methods() {
    return {
      close: () => this.close(),
      open: () => this.open()
    };
  }
  /**
   * Open Inline Toolbar
   */
  open() {
    this.Editor.InlineToolbar.tryToShow();
  }
  /**
   * Close Inline Toolbar
   */
  close() {
    this.Editor.InlineToolbar.close();
  }
}
class ao extends y$1 {
  /**
   * Available methods
   *
   * @returns {Listeners}
   */
  get methods() {
    return {
      on: (e2, t2, o3, i2) => this.on(e2, t2, o3, i2),
      off: (e2, t2, o3, i2) => this.off(e2, t2, o3, i2),
      offById: (e2) => this.offById(e2)
    };
  }
  /**
   * Ads a DOM event listener. Return it's id.
   *
   * @param {HTMLElement} element - Element to set handler to
   * @param {string} eventType - event type
   * @param {() => void} handler - event handler
   * @param {boolean} useCapture - capture event or not
   */
  on(e2, t2, o3, i2) {
    return this.listeners.on(e2, t2, o3, i2);
  }
  /**
   * Removes DOM listener from element
   *
   * @param {Element} element - Element to remove handler from
   * @param eventType - event type
   * @param handler - event handler
   * @param {boolean} useCapture - capture event or not
   */
  off(e2, t2, o3, i2) {
    this.listeners.off(e2, t2, o3, i2);
  }
  /**
   * Removes DOM listener by the listener id
   *
   * @param id - id of the listener to remove
   */
  offById(e2) {
    this.listeners.offById(e2);
  }
}
var _e = {}, lo = {
  get exports() {
    return _e;
  },
  set exports(s4) {
    _e = s4;
  }
};
(function(s4, e2) {
  (function(t2, o3) {
    s4.exports = o3();
  })(window, function() {
    return function(t2) {
      var o3 = {};
      function i2(n3) {
        if (o3[n3])
          return o3[n3].exports;
        var r4 = o3[n3] = { i: n3, l: false, exports: {} };
        return t2[n3].call(r4.exports, r4, r4.exports, i2), r4.l = true, r4.exports;
      }
      return i2.m = t2, i2.c = o3, i2.d = function(n3, r4, a3) {
        i2.o(n3, r4) || Object.defineProperty(n3, r4, { enumerable: true, get: a3 });
      }, i2.r = function(n3) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(n3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n3, "__esModule", { value: true });
      }, i2.t = function(n3, r4) {
        if (1 & r4 && (n3 = i2(n3)), 8 & r4 || 4 & r4 && typeof n3 == "object" && n3 && n3.__esModule)
          return n3;
        var a3 = /* @__PURE__ */ Object.create(null);
        if (i2.r(a3), Object.defineProperty(a3, "default", { enumerable: true, value: n3 }), 2 & r4 && typeof n3 != "string")
          for (var l2 in n3)
            i2.d(a3, l2, (function(d4) {
              return n3[d4];
            }).bind(null, l2));
        return a3;
      }, i2.n = function(n3) {
        var r4 = n3 && n3.__esModule ? function() {
          return n3.default;
        } : function() {
          return n3;
        };
        return i2.d(r4, "a", r4), r4;
      }, i2.o = function(n3, r4) {
        return Object.prototype.hasOwnProperty.call(n3, r4);
      }, i2.p = "/", i2(i2.s = 0);
    }([function(t2, o3, i2) {
      i2(1), /*!
      * Codex JavaScript Notification module
      * https://github.com/codex-team/js-notifier
      */
      t2.exports = function() {
        var n3 = i2(6), r4 = "cdx-notify--bounce-in", a3 = null;
        return { show: function(l2) {
          if (l2.message) {
            (function() {
              if (a3)
                return true;
              a3 = n3.getWrapper(), document.body.appendChild(a3);
            })();
            var d4 = null, u3 = l2.time || 8e3;
            switch (l2.type) {
              case "confirm":
                d4 = n3.confirm(l2);
                break;
              case "prompt":
                d4 = n3.prompt(l2);
                break;
              default:
                d4 = n3.alert(l2), window.setTimeout(function() {
                  d4.remove();
                }, u3);
            }
            a3.appendChild(d4), d4.classList.add(r4);
          }
        } };
      }();
    }, function(t2, o3, i2) {
      var n3 = i2(2);
      typeof n3 == "string" && (n3 = [[t2.i, n3, ""]]);
      var r4 = { hmr: true, transform: void 0, insertInto: void 0 };
      i2(4)(n3, r4), n3.locals && (t2.exports = n3.locals);
    }, function(t2, o3, i2) {
      (t2.exports = i2(3)(false)).push([t2.i, `.cdx-notify--error{background:#fffbfb!important}.cdx-notify--error::before{background:#fb5d5d!important}.cdx-notify__input{max-width:130px;padding:5px 10px;background:#f7f7f7;border:0;border-radius:3px;font-size:13px;color:#656b7c;outline:0}.cdx-notify__input:-ms-input-placeholder{color:#656b7c}.cdx-notify__input::placeholder{color:#656b7c}.cdx-notify__input:focus:-ms-input-placeholder{color:rgba(101,107,124,.3)}.cdx-notify__input:focus::placeholder{color:rgba(101,107,124,.3)}.cdx-notify__button{border:none;border-radius:3px;font-size:13px;padding:5px 10px;cursor:pointer}.cdx-notify__button:last-child{margin-left:10px}.cdx-notify__button--cancel{background:#f2f5f7;box-shadow:0 2px 1px 0 rgba(16,19,29,0);color:#656b7c}.cdx-notify__button--cancel:hover{background:#eee}.cdx-notify__button--confirm{background:#34c992;box-shadow:0 1px 1px 0 rgba(18,49,35,.05);color:#fff}.cdx-notify__button--confirm:hover{background:#33b082}.cdx-notify__btns-wrapper{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;margin-top:5px}.cdx-notify__cross{position:absolute;top:5px;right:5px;width:10px;height:10px;padding:5px;opacity:.54;cursor:pointer}.cdx-notify__cross::after,.cdx-notify__cross::before{content:'';position:absolute;left:9px;top:5px;height:12px;width:2px;background:#575d67}.cdx-notify__cross::before{transform:rotate(-45deg)}.cdx-notify__cross::after{transform:rotate(45deg)}.cdx-notify__cross:hover{opacity:1}.cdx-notifies{position:fixed;z-index:2;bottom:20px;left:20px;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",sans-serif}.cdx-notify{position:relative;width:220px;margin-top:15px;padding:13px 16px;background:#fff;box-shadow:0 11px 17px 0 rgba(23,32,61,.13);border-radius:5px;font-size:14px;line-height:1.4em;word-wrap:break-word}.cdx-notify::before{content:'';position:absolute;display:block;top:0;left:0;width:3px;height:calc(100% - 6px);margin:3px;border-radius:5px;background:0 0}@keyframes bounceIn{0%{opacity:0;transform:scale(.3)}50%{opacity:1;transform:scale(1.05)}70%{transform:scale(.9)}100%{transform:scale(1)}}.cdx-notify--bounce-in{animation-name:bounceIn;animation-duration:.6s;animation-iteration-count:1}.cdx-notify--success{background:#fafffe!important}.cdx-notify--success::before{background:#41ffb1!important}`, ""]);
    }, function(t2, o3) {
      t2.exports = function(i2) {
        var n3 = [];
        return n3.toString = function() {
          return this.map(function(r4) {
            var a3 = function(l2, d4) {
              var u3 = l2[1] || "", h2 = l2[3];
              if (!h2)
                return u3;
              if (d4 && typeof btoa == "function") {
                var f2 = (p2 = h2, "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(p2)))) + " */"), x2 = h2.sources.map(function(m3) {
                  return "/*# sourceURL=" + h2.sourceRoot + m3 + " */";
                });
                return [u3].concat(x2).concat([f2]).join(`
`);
              }
              var p2;
              return [u3].join(`
`);
            }(r4, i2);
            return r4[2] ? "@media " + r4[2] + "{" + a3 + "}" : a3;
          }).join("");
        }, n3.i = function(r4, a3) {
          typeof r4 == "string" && (r4 = [[null, r4, ""]]);
          for (var l2 = {}, d4 = 0; d4 < this.length; d4++) {
            var u3 = this[d4][0];
            typeof u3 == "number" && (l2[u3] = true);
          }
          for (d4 = 0; d4 < r4.length; d4++) {
            var h2 = r4[d4];
            typeof h2[0] == "number" && l2[h2[0]] || (a3 && !h2[2] ? h2[2] = a3 : a3 && (h2[2] = "(" + h2[2] + ") and (" + a3 + ")"), n3.push(h2));
          }
        }, n3;
      };
    }, function(t2, o3, i2) {
      var n3, r4, a3 = {}, l2 = (n3 = function() {
        return window && document && document.all && !window.atob;
      }, function() {
        return r4 === void 0 && (r4 = n3.apply(this, arguments)), r4;
      }), d4 = function(k2) {
        var g2 = {};
        return function(w2) {
          if (typeof w2 == "function")
            return w2();
          if (g2[w2] === void 0) {
            var E2 = (function(I4) {
              return document.querySelector(I4);
            }).call(this, w2);
            if (window.HTMLIFrameElement && E2 instanceof window.HTMLIFrameElement)
              try {
                E2 = E2.contentDocument.head;
              } catch {
                E2 = null;
              }
            g2[w2] = E2;
          }
          return g2[w2];
        };
      }(), u3 = null, h2 = 0, f2 = [], x2 = i2(5);
      function p2(k2, g2) {
        for (var w2 = 0; w2 < k2.length; w2++) {
          var E2 = k2[w2], I4 = a3[E2.id];
          if (I4) {
            I4.refs++;
            for (var C2 = 0; C2 < I4.parts.length; C2++)
              I4.parts[C2](E2.parts[C2]);
            for (; C2 < E2.parts.length; C2++)
              I4.parts.push(H2(E2.parts[C2], g2));
          } else {
            var O2 = [];
            for (C2 = 0; C2 < E2.parts.length; C2++)
              O2.push(H2(E2.parts[C2], g2));
            a3[E2.id] = { id: E2.id, refs: 1, parts: O2 };
          }
        }
      }
      function m3(k2, g2) {
        for (var w2 = [], E2 = {}, I4 = 0; I4 < k2.length; I4++) {
          var C2 = k2[I4], O2 = g2.base ? C2[0] + g2.base : C2[0], B2 = { css: C2[1], media: C2[2], sourceMap: C2[3] };
          E2[O2] ? E2[O2].parts.push(B2) : w2.push(E2[O2] = { id: O2, parts: [B2] });
        }
        return w2;
      }
      function L2(k2, g2) {
        var w2 = d4(k2.insertInto);
        if (!w2)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
        var E2 = f2[f2.length - 1];
        if (k2.insertAt === "top")
          E2 ? E2.nextSibling ? w2.insertBefore(g2, E2.nextSibling) : w2.appendChild(g2) : w2.insertBefore(g2, w2.firstChild), f2.push(g2);
        else if (k2.insertAt === "bottom")
          w2.appendChild(g2);
        else {
          if (typeof k2.insertAt != "object" || !k2.insertAt.before)
            throw new Error(`[Style Loader]

 Invalid value for parameter 'insertAt' ('options.insertAt') found.
 Must be 'top', 'bottom', or Object.
 (https://github.com/webpack-contrib/style-loader#insertat)
`);
          var I4 = d4(k2.insertInto + " " + k2.insertAt.before);
          w2.insertBefore(g2, I4);
        }
      }
      function A2(k2) {
        if (k2.parentNode === null)
          return false;
        k2.parentNode.removeChild(k2);
        var g2 = f2.indexOf(k2);
        g2 >= 0 && f2.splice(g2, 1);
      }
      function S2(k2) {
        var g2 = document.createElement("style");
        return k2.attrs.type === void 0 && (k2.attrs.type = "text/css"), Z(g2, k2.attrs), L2(k2, g2), g2;
      }
      function Z(k2, g2) {
        Object.keys(g2).forEach(function(w2) {
          k2.setAttribute(w2, g2[w2]);
        });
      }
      function H2(k2, g2) {
        var w2, E2, I4, C2;
        if (g2.transform && k2.css) {
          if (!(C2 = g2.transform(k2.css)))
            return function() {
            };
          k2.css = C2;
        }
        if (g2.singleton) {
          var O2 = h2++;
          w2 = u3 || (u3 = S2(g2)), E2 = ce2.bind(null, w2, O2, false), I4 = ce2.bind(null, w2, O2, true);
        } else
          k2.sourceMap && typeof URL == "function" && typeof URL.createObjectURL == "function" && typeof URL.revokeObjectURL == "function" && typeof Blob == "function" && typeof btoa == "function" ? (w2 = function(B2) {
            var j2 = document.createElement("link");
            return B2.attrs.type === void 0 && (B2.attrs.type = "text/css"), B2.attrs.rel = "stylesheet", Z(j2, B2.attrs), L2(B2, j2), j2;
          }(g2), E2 = (function(B2, j2, de2) {
            var Q2 = de2.css, Ce = de2.sourceMap, Ot = j2.convertToAbsoluteUrls === void 0 && Ce;
            (j2.convertToAbsoluteUrls || Ot) && (Q2 = x2(Q2)), Ce && (Q2 += `
/*# sourceMappingURL=data:application/json;base64,` + btoa(unescape(encodeURIComponent(JSON.stringify(Ce)))) + " */");
            var Nt = new Blob([Q2], { type: "text/css" }), Ge = B2.href;
            B2.href = URL.createObjectURL(Nt), Ge && URL.revokeObjectURL(Ge);
          }).bind(null, w2, g2), I4 = function() {
            A2(w2), w2.href && URL.revokeObjectURL(w2.href);
          }) : (w2 = S2(g2), E2 = (function(B2, j2) {
            var de2 = j2.css, Q2 = j2.media;
            if (Q2 && B2.setAttribute("media", Q2), B2.styleSheet)
              B2.styleSheet.cssText = de2;
            else {
              for (; B2.firstChild; )
                B2.removeChild(B2.firstChild);
              B2.appendChild(document.createTextNode(de2));
            }
          }).bind(null, w2), I4 = function() {
            A2(w2);
          });
        return E2(k2), function(B2) {
          if (B2) {
            if (B2.css === k2.css && B2.media === k2.media && B2.sourceMap === k2.sourceMap)
              return;
            E2(k2 = B2);
          } else
            I4();
        };
      }
      t2.exports = function(k2, g2) {
        if (typeof DEBUG < "u" && DEBUG && typeof document != "object")
          throw new Error("The style-loader cannot be used in a non-browser environment");
        (g2 = g2 || {}).attrs = typeof g2.attrs == "object" ? g2.attrs : {}, g2.singleton || typeof g2.singleton == "boolean" || (g2.singleton = l2()), g2.insertInto || (g2.insertInto = "head"), g2.insertAt || (g2.insertAt = "bottom");
        var w2 = m3(k2, g2);
        return p2(w2, g2), function(E2) {
          for (var I4 = [], C2 = 0; C2 < w2.length; C2++) {
            var O2 = w2[C2];
            (B2 = a3[O2.id]).refs--, I4.push(B2);
          }
          for (E2 && p2(m3(E2, g2), g2), C2 = 0; C2 < I4.length; C2++) {
            var B2;
            if ((B2 = I4[C2]).refs === 0) {
              for (var j2 = 0; j2 < B2.parts.length; j2++)
                B2.parts[j2]();
              delete a3[B2.id];
            }
          }
        };
      };
      var U2, J2 = (U2 = [], function(k2, g2) {
        return U2[k2] = g2, U2.filter(Boolean).join(`
`);
      });
      function ce2(k2, g2, w2, E2) {
        var I4 = w2 ? "" : E2.css;
        if (k2.styleSheet)
          k2.styleSheet.cssText = J2(g2, I4);
        else {
          var C2 = document.createTextNode(I4), O2 = k2.childNodes;
          O2[g2] && k2.removeChild(O2[g2]), O2.length ? k2.insertBefore(C2, O2[g2]) : k2.appendChild(C2);
        }
      }
    }, function(t2, o3) {
      t2.exports = function(i2) {
        var n3 = typeof window < "u" && window.location;
        if (!n3)
          throw new Error("fixUrls requires window.location");
        if (!i2 || typeof i2 != "string")
          return i2;
        var r4 = n3.protocol + "//" + n3.host, a3 = r4 + n3.pathname.replace(/\/[^\/]*$/, "/");
        return i2.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(l2, d4) {
          var u3, h2 = d4.trim().replace(/^"(.*)"$/, function(f2, x2) {
            return x2;
          }).replace(/^'(.*)'$/, function(f2, x2) {
            return x2;
          });
          return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(h2) ? l2 : (u3 = h2.indexOf("//") === 0 ? h2 : h2.indexOf("/") === 0 ? r4 + h2 : a3 + h2.replace(/^\.\//, ""), "url(" + JSON.stringify(u3) + ")");
        });
      };
    }, function(t2, o3, i2) {
      var n3, r4, a3, l2, d4, u3, h2, f2, x2;
      t2.exports = (n3 = "cdx-notifies", r4 = "cdx-notify", a3 = "cdx-notify__cross", l2 = "cdx-notify__button--confirm", d4 = "cdx-notify__button--cancel", u3 = "cdx-notify__input", h2 = "cdx-notify__button", f2 = "cdx-notify__btns-wrapper", { alert: x2 = function(p2) {
        var m3 = document.createElement("DIV"), L2 = document.createElement("DIV"), A2 = p2.message, S2 = p2.style;
        return m3.classList.add(r4), S2 && m3.classList.add(r4 + "--" + S2), m3.innerHTML = A2, L2.classList.add(a3), L2.addEventListener("click", m3.remove.bind(m3)), m3.appendChild(L2), m3;
      }, confirm: function(p2) {
        var m3 = x2(p2), L2 = document.createElement("div"), A2 = document.createElement("button"), S2 = document.createElement("button"), Z = m3.querySelector("." + a3), H2 = p2.cancelHandler, U2 = p2.okHandler;
        return L2.classList.add(f2), A2.innerHTML = p2.okText || "Confirm", S2.innerHTML = p2.cancelText || "Cancel", A2.classList.add(h2), S2.classList.add(h2), A2.classList.add(l2), S2.classList.add(d4), H2 && typeof H2 == "function" && (S2.addEventListener("click", H2), Z.addEventListener("click", H2)), U2 && typeof U2 == "function" && A2.addEventListener("click", U2), A2.addEventListener("click", m3.remove.bind(m3)), S2.addEventListener("click", m3.remove.bind(m3)), L2.appendChild(A2), L2.appendChild(S2), m3.appendChild(L2), m3;
      }, prompt: function(p2) {
        var m3 = x2(p2), L2 = document.createElement("div"), A2 = document.createElement("button"), S2 = document.createElement("input"), Z = m3.querySelector("." + a3), H2 = p2.cancelHandler, U2 = p2.okHandler;
        return L2.classList.add(f2), A2.innerHTML = p2.okText || "Ok", A2.classList.add(h2), A2.classList.add(l2), S2.classList.add(u3), p2.placeholder && S2.setAttribute("placeholder", p2.placeholder), p2.default && (S2.value = p2.default), p2.inputType && (S2.type = p2.inputType), H2 && typeof H2 == "function" && Z.addEventListener("click", H2), U2 && typeof U2 == "function" && A2.addEventListener("click", function() {
          U2(S2.value);
        }), A2.addEventListener("click", m3.remove.bind(m3)), L2.appendChild(S2), L2.appendChild(A2), m3.appendChild(L2), m3;
      }, getWrapper: function() {
        var p2 = document.createElement("DIV");
        return p2.classList.add(n3), p2;
      } });
    }]);
  });
})(lo);
const co = /* @__PURE__ */ Pe(_e);
class ho {
  /**
   * Show web notification
   *
   * @param {NotifierOptions | ConfirmNotifierOptions | PromptNotifierOptions} options - notification options
   */
  show(e2) {
    co.show(e2);
  }
}
class uo extends y$1 {
  /**
   * @param moduleConfiguration - Module Configuration
   * @param moduleConfiguration.config - Editor's config
   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
   */
  constructor({ config: e2, eventsDispatcher: t2 }) {
    super({
      config: e2,
      eventsDispatcher: t2
    }), this.notifier = new ho();
  }
  /**
   * Available methods
   */
  get methods() {
    return {
      show: (e2) => this.show(e2)
    };
  }
  /**
   * Show notification
   *
   * @param {NotifierOptions} options - message option
   */
  show(e2) {
    return this.notifier.show(e2);
  }
}
class po extends y$1 {
  /**
   * Available methods
   */
  get methods() {
    const e2 = () => this.isEnabled;
    return {
      toggle: (t2) => this.toggle(t2),
      get isEnabled() {
        return e2();
      }
    };
  }
  /**
   * Set or toggle read-only state
   *
   * @param {boolean|undefined} state - set or toggle state
   * @returns {boolean} current value
   */
  toggle(e2) {
    return this.Editor.ReadOnly.toggle(e2);
  }
  /**
   * Returns current read-only state
   */
  get isEnabled() {
    return this.Editor.ReadOnly.isEnabled;
  }
}
var Oe = {}, fo = {
  get exports() {
    return Oe;
  },
  set exports(s4) {
    Oe = s4;
  }
};
(function(s4, e2) {
  (function(t2, o3) {
    s4.exports = o3();
  })(Rt, function() {
    function t2(h2) {
      var f2 = h2.tags, x2 = Object.keys(f2), p2 = x2.map(function(m3) {
        return typeof f2[m3];
      }).every(function(m3) {
        return m3 === "object" || m3 === "boolean" || m3 === "function";
      });
      if (!p2)
        throw new Error("The configuration was invalid");
      this.config = h2;
    }
    var o3 = ["P", "LI", "TD", "TH", "DIV", "H1", "H2", "H3", "H4", "H5", "H6", "PRE"];
    function i2(h2) {
      return o3.indexOf(h2.nodeName) !== -1;
    }
    var n3 = ["A", "B", "STRONG", "I", "EM", "SUB", "SUP", "U", "STRIKE"];
    function r4(h2) {
      return n3.indexOf(h2.nodeName) !== -1;
    }
    t2.prototype.clean = function(h2) {
      const f2 = document.implementation.createHTMLDocument(), x2 = f2.createElement("div");
      return x2.innerHTML = h2, this._sanitize(f2, x2), x2.innerHTML;
    }, t2.prototype._sanitize = function(h2, f2) {
      var x2 = a3(h2, f2), p2 = x2.firstChild();
      if (p2)
        do {
          if (p2.nodeType === Node.TEXT_NODE)
            if (p2.data.trim() === "" && (p2.previousElementSibling && i2(p2.previousElementSibling) || p2.nextElementSibling && i2(p2.nextElementSibling))) {
              f2.removeChild(p2), this._sanitize(h2, f2);
              break;
            } else
              continue;
          if (p2.nodeType === Node.COMMENT_NODE) {
            f2.removeChild(p2), this._sanitize(h2, f2);
            break;
          }
          var m3 = r4(p2), L2;
          m3 && (L2 = Array.prototype.some.call(p2.childNodes, i2));
          var A2 = !!f2.parentNode, S2 = i2(f2) && i2(p2) && A2, Z = p2.nodeName.toLowerCase(), H2 = l2(this.config, Z, p2), U2 = m3 && L2;
          if (U2 || d4(p2, H2) || !this.config.keepNestedBlockElements && S2) {
            if (!(p2.nodeName === "SCRIPT" || p2.nodeName === "STYLE"))
              for (; p2.childNodes.length > 0; )
                f2.insertBefore(p2.childNodes[0], p2);
            f2.removeChild(p2), this._sanitize(h2, f2);
            break;
          }
          for (var J2 = 0; J2 < p2.attributes.length; J2 += 1) {
            var ce2 = p2.attributes[J2];
            u3(ce2, H2, p2) && (p2.removeAttribute(ce2.name), J2 = J2 - 1);
          }
          this._sanitize(h2, p2);
        } while (p2 = x2.nextSibling());
    };
    function a3(h2, f2) {
      return h2.createTreeWalker(
        f2,
        NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,
        null,
        false
      );
    }
    function l2(h2, f2, x2) {
      return typeof h2.tags[f2] == "function" ? h2.tags[f2](x2) : h2.tags[f2];
    }
    function d4(h2, f2) {
      return typeof f2 > "u" ? true : typeof f2 == "boolean" ? !f2 : false;
    }
    function u3(h2, f2, x2) {
      var p2 = h2.name.toLowerCase();
      return f2 === true ? false : typeof f2[p2] == "function" ? !f2[p2](h2.value, x2) : typeof f2[p2] > "u" || f2[p2] === false ? true : typeof f2[p2] == "string" ? f2[p2] !== h2.value : false;
    }
    return t2;
  });
})(fo);
const go = Oe;
function bt(s4, e2) {
  return s4.map((t2) => {
    const o3 = M$2(e2) ? e2(t2.tool) : e2;
    return W(o3) || (t2.data = ze(t2.data, o3)), t2;
  });
}
function V(s4, e2 = {}) {
  const t2 = {
    tags: e2
  };
  return new go(t2).clean(s4);
}
function ze(s4, e2) {
  return Array.isArray(s4) ? bo(s4, e2) : D$1(s4) ? mo(s4, e2) : G(s4) ? ko(s4, e2) : s4;
}
function bo(s4, e2) {
  return s4.map((t2) => ze(t2, e2));
}
function mo(s4, e2) {
  const t2 = {};
  for (const o3 in s4) {
    if (!Object.prototype.hasOwnProperty.call(s4, o3))
      continue;
    const i2 = s4[o3], n3 = vo(e2[o3]) ? e2[o3] : e2;
    t2[o3] = ze(i2, n3);
  }
  return t2;
}
function ko(s4, e2) {
  return D$1(e2) ? V(s4, e2) : e2 === false ? V(s4, {}) : s4;
}
function vo(s4) {
  return D$1(s4) || Ht(s4) || M$2(s4);
}
class xo extends y$1 {
  /**
   * Available methods
   *
   * @returns {SanitizerConfig}
   */
  get methods() {
    return {
      clean: (e2, t2) => this.clean(e2, t2)
    };
  }
  /**
   * Perform sanitizing of a string
   *
   * @param {string} taintString - what to sanitize
   * @param {SanitizerConfig} config - sanitizer config
   * @returns {string}
   */
  clean(e2, t2) {
    return V(e2, t2);
  }
}
class wo extends y$1 {
  /**
   * Available methods
   *
   * @returns {Saver}
   */
  get methods() {
    return {
      save: () => this.save()
    };
  }
  /**
   * Return Editor's data
   *
   * @returns {OutputData}
   */
  save() {
    const e2 = "Editor's content can not be saved in read-only mode";
    return this.Editor.ReadOnly.isEnabled ? (Y(e2, "warn"), Promise.reject(new Error(e2))) : this.Editor.Saver.save();
  }
}
class yo extends y$1 {
  /**
   * Available methods
   *
   * @returns {SelectionAPIInterface}
   */
  get methods() {
    return {
      findParentTag: (e2, t2) => this.findParentTag(e2, t2),
      expandToTag: (e2) => this.expandToTag(e2)
    };
  }
  /**
   * Looks ahead from selection and find passed tag with class name
   *
   * @param {string} tagName - tag to find
   * @param {string} className - tag's class name
   * @returns {HTMLElement|null}
   */
  findParentTag(e2, t2) {
    return new b$1().findParentTag(e2, t2);
  }
  /**
   * Expand selection to passed tag
   *
   * @param {HTMLElement} node - tag that should contain selection
   */
  expandToTag(e2) {
    new b$1().expandToTag(e2);
  }
}
class Eo extends y$1 {
  /**
   * Exported classes
   */
  get classes() {
    return {
      /**
       * Base Block styles
       */
      block: "cdx-block",
      /**
       * Inline Tools styles
       */
      inlineToolButton: "ce-inline-tool",
      inlineToolButtonActive: "ce-inline-tool--active",
      /**
       * UI elements
       */
      input: "cdx-input",
      loader: "cdx-loader",
      button: "cdx-button",
      /**
       * Settings styles
       */
      settingsButton: "cdx-settings-button",
      settingsButtonActive: "cdx-settings-button--active"
    };
  }
}
class Bo extends y$1 {
  /**
   * Available methods
   *
   * @returns {Toolbar}
   */
  get methods() {
    return {
      close: () => this.close(),
      open: () => this.open(),
      toggleBlockSettings: (e2) => this.toggleBlockSettings(e2),
      toggleToolbox: (e2) => this.toggleToolbox(e2)
    };
  }
  /**
   * Open toolbar
   */
  open() {
    this.Editor.Toolbar.moveAndOpen();
  }
  /**
   * Close toolbar and all included elements
   */
  close() {
    this.Editor.Toolbar.close();
  }
  /**
   * Toggles Block Setting of the current block
   *
   * @param {boolean} openingState —  opening state of Block Setting
   */
  toggleBlockSettings(e2) {
    if (this.Editor.BlockManager.currentBlockIndex === -1) {
      Y("Could't toggle the Toolbar because there is no block selected ", "warn");
      return;
    }
    e2 ?? !this.Editor.BlockSettings.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.open()) : this.Editor.BlockSettings.close();
  }
  /**
   * Open toolbox
   *
   * @param {boolean} openingState - Opening state of toolbox
   */
  toggleToolbox(e2) {
    if (this.Editor.BlockManager.currentBlockIndex === -1) {
      Y("Could't toggle the Toolbox because there is no block selected ", "warn");
      return;
    }
    e2 ?? !this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open()) : this.Editor.Toolbar.toolbox.close();
  }
}
var Ne = {}, Co = {
  get exports() {
    return Ne;
  },
  set exports(s4) {
    Ne = s4;
  }
};
/*!
 * CodeX.Tooltips
 * 
 * @version 1.0.5
 * 
 * @licence MIT
 * @author CodeX <https://codex.so>
 * 
 * 
 */
(function(s4, e2) {
  (function(t2, o3) {
    s4.exports = o3();
  })(window, function() {
    return function(t2) {
      var o3 = {};
      function i2(n3) {
        if (o3[n3])
          return o3[n3].exports;
        var r4 = o3[n3] = { i: n3, l: false, exports: {} };
        return t2[n3].call(r4.exports, r4, r4.exports, i2), r4.l = true, r4.exports;
      }
      return i2.m = t2, i2.c = o3, i2.d = function(n3, r4, a3) {
        i2.o(n3, r4) || Object.defineProperty(n3, r4, { enumerable: true, get: a3 });
      }, i2.r = function(n3) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(n3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n3, "__esModule", { value: true });
      }, i2.t = function(n3, r4) {
        if (1 & r4 && (n3 = i2(n3)), 8 & r4 || 4 & r4 && typeof n3 == "object" && n3 && n3.__esModule)
          return n3;
        var a3 = /* @__PURE__ */ Object.create(null);
        if (i2.r(a3), Object.defineProperty(a3, "default", { enumerable: true, value: n3 }), 2 & r4 && typeof n3 != "string")
          for (var l2 in n3)
            i2.d(a3, l2, (function(d4) {
              return n3[d4];
            }).bind(null, l2));
        return a3;
      }, i2.n = function(n3) {
        var r4 = n3 && n3.__esModule ? function() {
          return n3.default;
        } : function() {
          return n3;
        };
        return i2.d(r4, "a", r4), r4;
      }, i2.o = function(n3, r4) {
        return Object.prototype.hasOwnProperty.call(n3, r4);
      }, i2.p = "", i2(i2.s = 0);
    }([function(t2, o3, i2) {
      t2.exports = i2(1);
    }, function(t2, o3, i2) {
      i2.r(o3), i2.d(o3, "default", function() {
        return n3;
      });
      class n3 {
        constructor() {
          this.nodes = { wrapper: null, content: null }, this.showed = false, this.offsetTop = 10, this.offsetLeft = 10, this.offsetRight = 10, this.hidingDelay = 0, this.handleWindowScroll = () => {
            this.showed && this.hide(true);
          }, this.loadStyles(), this.prepare(), window.addEventListener("scroll", this.handleWindowScroll, { passive: true });
        }
        get CSS() {
          return { tooltip: "ct", tooltipContent: "ct__content", tooltipShown: "ct--shown", placement: { left: "ct--left", bottom: "ct--bottom", right: "ct--right", top: "ct--top" } };
        }
        show(a3, l2, d4) {
          this.nodes.wrapper || this.prepare(), this.hidingTimeout && clearTimeout(this.hidingTimeout);
          const u3 = Object.assign({ placement: "bottom", marginTop: 0, marginLeft: 0, marginRight: 0, marginBottom: 0, delay: 70, hidingDelay: 0 }, d4);
          if (u3.hidingDelay && (this.hidingDelay = u3.hidingDelay), this.nodes.content.innerHTML = "", typeof l2 == "string")
            this.nodes.content.appendChild(document.createTextNode(l2));
          else {
            if (!(l2 instanceof Node))
              throw Error("[CodeX Tooltip] Wrong type of «content» passed. It should be an instance of Node or String. But " + typeof l2 + " given.");
            this.nodes.content.appendChild(l2);
          }
          switch (this.nodes.wrapper.classList.remove(...Object.values(this.CSS.placement)), u3.placement) {
            case "top":
              this.placeTop(a3, u3);
              break;
            case "left":
              this.placeLeft(a3, u3);
              break;
            case "right":
              this.placeRight(a3, u3);
              break;
            case "bottom":
            default:
              this.placeBottom(a3, u3);
          }
          u3 && u3.delay ? this.showingTimeout = setTimeout(() => {
            this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = true;
          }, u3.delay) : (this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = true);
        }
        hide(a3 = false) {
          if (this.hidingDelay && !a3)
            return this.hidingTimeout && clearTimeout(this.hidingTimeout), void (this.hidingTimeout = setTimeout(() => {
              this.hide(true);
            }, this.hidingDelay));
          this.nodes.wrapper.classList.remove(this.CSS.tooltipShown), this.showed = false, this.showingTimeout && clearTimeout(this.showingTimeout);
        }
        onHover(a3, l2, d4) {
          a3.addEventListener("mouseenter", () => {
            this.show(a3, l2, d4);
          }), a3.addEventListener("mouseleave", () => {
            this.hide();
          });
        }
        destroy() {
          this.nodes.wrapper.remove(), window.removeEventListener("scroll", this.handleWindowScroll);
        }
        prepare() {
          this.nodes.wrapper = this.make("div", this.CSS.tooltip), this.nodes.content = this.make("div", this.CSS.tooltipContent), this.append(this.nodes.wrapper, this.nodes.content), this.append(document.body, this.nodes.wrapper);
        }
        loadStyles() {
          const a3 = "codex-tooltips-style";
          if (document.getElementById(a3))
            return;
          const l2 = i2(2), d4 = this.make("style", null, { textContent: l2.toString(), id: a3 });
          this.prepend(document.head, d4);
        }
        placeBottom(a3, l2) {
          const d4 = a3.getBoundingClientRect(), u3 = d4.left + a3.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h2 = d4.bottom + window.pageYOffset + this.offsetTop + l2.marginTop;
          this.applyPlacement("bottom", u3, h2);
        }
        placeTop(a3, l2) {
          const d4 = a3.getBoundingClientRect(), u3 = d4.left + a3.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h2 = d4.top + window.pageYOffset - this.nodes.wrapper.clientHeight - this.offsetTop;
          this.applyPlacement("top", u3, h2);
        }
        placeLeft(a3, l2) {
          const d4 = a3.getBoundingClientRect(), u3 = d4.left - this.nodes.wrapper.offsetWidth - this.offsetLeft - l2.marginLeft, h2 = d4.top + window.pageYOffset + a3.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;
          this.applyPlacement("left", u3, h2);
        }
        placeRight(a3, l2) {
          const d4 = a3.getBoundingClientRect(), u3 = d4.right + this.offsetRight + l2.marginRight, h2 = d4.top + window.pageYOffset + a3.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;
          this.applyPlacement("right", u3, h2);
        }
        applyPlacement(a3, l2, d4) {
          this.nodes.wrapper.classList.add(this.CSS.placement[a3]), this.nodes.wrapper.style.left = l2 + "px", this.nodes.wrapper.style.top = d4 + "px";
        }
        make(a3, l2 = null, d4 = {}) {
          const u3 = document.createElement(a3);
          Array.isArray(l2) ? u3.classList.add(...l2) : l2 && u3.classList.add(l2);
          for (const h2 in d4)
            d4.hasOwnProperty(h2) && (u3[h2] = d4[h2]);
          return u3;
        }
        append(a3, l2) {
          Array.isArray(l2) ? l2.forEach((d4) => a3.appendChild(d4)) : a3.appendChild(l2);
        }
        prepend(a3, l2) {
          Array.isArray(l2) ? (l2 = l2.reverse()).forEach((d4) => a3.prepend(d4)) : a3.prepend(l2);
        }
      }
    }, function(t2, o3) {
      t2.exports = `.ct{z-index:999;opacity:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;-webkit-transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1),-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);will-change:opacity,top,left;-webkit-box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);border-radius:9px}.ct,.ct:before{position:absolute;top:0;left:0}.ct:before{content:"";bottom:0;right:0;background-color:#1d202b;z-index:-1;border-radius:4px}@supports(-webkit-mask-box-image:url("")){.ct:before{border-radius:0;-webkit-mask-box-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M10.71 0h2.58c3.02 0 4.64.42 6.1 1.2a8.18 8.18 0 013.4 3.4C23.6 6.07 24 7.7 24 10.71v2.58c0 3.02-.42 4.64-1.2 6.1a8.18 8.18 0 01-3.4 3.4c-1.47.8-3.1 1.21-6.11 1.21H10.7c-3.02 0-4.64-.42-6.1-1.2a8.18 8.18 0 01-3.4-3.4C.4 17.93 0 16.3 0 13.29V10.7c0-3.02.42-4.64 1.2-6.1a8.18 8.18 0 013.4-3.4C6.07.4 7.7 0 10.71 0z"/></svg>') 48% 41% 37.9% 53.3%}}@media (--mobile){.ct{display:none}}.ct__content{padding:6px 10px;color:#cdd1e0;font-size:12px;text-align:center;letter-spacing:.02em;line-height:1em}.ct:after{content:"";width:8px;height:8px;position:absolute;background-color:#1d202b;z-index:-1}.ct--bottom{-webkit-transform:translateY(5px);transform:translateY(5px)}.ct--bottom:after{top:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--top{-webkit-transform:translateY(-5px);transform:translateY(-5px)}.ct--top:after{top:auto;bottom:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--left{-webkit-transform:translateX(-5px);transform:translateX(-5px)}.ct--left:after{top:50%;left:auto;right:0;-webkit-transform:translate(41.6%,-50%) rotate(-45deg);transform:translate(41.6%,-50%) rotate(-45deg)}.ct--right{-webkit-transform:translateX(5px);transform:translateX(5px)}.ct--right:after{top:50%;left:0;-webkit-transform:translate(-41.6%,-50%) rotate(-45deg);transform:translate(-41.6%,-50%) rotate(-45deg)}.ct--shown{opacity:1;-webkit-transform:none;transform:none}`;
    }]).default;
  });
})(Co);
const To = /* @__PURE__ */ Pe(Ne);
let F$2 = null;
function Ue() {
  F$2 || (F$2 = new To());
}
function So(s4, e2, t2) {
  Ue(), F$2 == null || F$2.show(s4, e2, t2);
}
function Re(s4 = false) {
  Ue(), F$2 == null || F$2.hide(s4);
}
function ge(s4, e2, t2) {
  Ue(), F$2 == null || F$2.onHover(s4, e2, t2);
}
function Io() {
  F$2 == null || F$2.destroy(), F$2 = null;
}
class Mo extends y$1 {
  /**
   * @class
   * @param moduleConfiguration - Module Configuration
   * @param moduleConfiguration.config - Editor's config
   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
   */
  constructor({ config: e2, eventsDispatcher: t2 }) {
    super({
      config: e2,
      eventsDispatcher: t2
    });
  }
  /**
   * Available methods
   */
  get methods() {
    return {
      show: (e2, t2, o3) => this.show(e2, t2, o3),
      hide: () => this.hide(),
      onHover: (e2, t2, o3) => this.onHover(e2, t2, o3)
    };
  }
  /**
   * Method show tooltip on element with passed HTML content
   *
   * @param {HTMLElement} element - element on which tooltip should be shown
   * @param {TooltipContent} content - tooltip content
   * @param {TooltipOptions} options - tooltip options
   */
  show(e2, t2, o3) {
    So(e2, t2, o3);
  }
  /**
   * Method hides tooltip on HTML page
   */
  hide() {
    Re();
  }
  /**
   * Decorator for showing Tooltip by mouseenter/mouseleave
   *
   * @param {HTMLElement} element - element on which tooltip should be shown
   * @param {TooltipContent} content - tooltip content
   * @param {TooltipOptions} options - tooltip options
   */
  onHover(e2, t2, o3) {
    ge(e2, t2, o3);
  }
}
class Lo extends y$1 {
  /**
   * Available methods / getters
   */
  get methods() {
    return {
      nodes: this.editorNodes
      /**
       * There can be added some UI methods, like toggleThinMode() etc
       */
    };
  }
  /**
   * Exported classes
   */
  get editorNodes() {
    return {
      /**
       * Top-level editor instance wrapper
       */
      wrapper: this.Editor.UI.nodes.wrapper,
      /**
       * Element that holds all the Blocks
       */
      redactor: this.Editor.UI.nodes.redactor
    };
  }
}
function mt(s4, e2) {
  const t2 = {};
  return Object.entries(s4).forEach(([o3, i2]) => {
    if (D$1(i2)) {
      const n3 = e2 ? `${e2}.${o3}` : o3;
      Object.values(i2).every((a3) => G(a3)) ? t2[o3] = n3 : t2[o3] = mt(i2, n3);
      return;
    }
    t2[o3] = i2;
  }), t2;
}
const K = mt(ht);
function Ao(s4, e2) {
  const t2 = {};
  return Object.keys(s4).forEach((o3) => {
    const i2 = e2[o3];
    i2 !== void 0 ? t2[i2] = s4[o3] : t2[o3] = s4[o3];
  }), t2;
}
const _o = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M9 12L9 7.1C9 7.04477 9.04477 7 9.1 7H10.4C11.5 7 14 7.1 14 9.5C14 9.5 14 12 11 12M9 12V16.8C9 16.9105 9.08954 17 9.2 17H12.5C14 17 15 16 15 14.5C15 11.7046 11 12 11 12M9 12H11"/></svg>', kt = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7 10L11.8586 14.8586C11.9367 14.9367 12.0633 14.9367 12.1414 14.8586L17 10"/></svg>', Oo = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7 15L11.8586 10.1414C11.9367 10.0633 12.0633 10.0633 12.1414 10.1414L17 15"/></svg>', No = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8 8L12 12M12 12L16 16M12 12L16 8M12 12L8 16"/></svg>', Ro = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><circle cx="12" cy="12" r="4" stroke="currentColor" stroke-width="2"/></svg>', Do = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M13.34 10C12.4223 12.7337 11 17 11 17"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M14.21 7H14.2"/></svg>', it = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7.69998 12.6L7.67896 12.62C6.53993 13.7048 6.52012 15.5155 7.63516 16.625V16.625C8.72293 17.7073 10.4799 17.7102 11.5712 16.6314L13.0263 15.193C14.0703 14.1609 14.2141 12.525 13.3662 11.3266L13.22 11.12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16.22 11.12L16.3564 10.9805C17.2895 10.0265 17.3478 8.5207 16.4914 7.49733V7.49733C15.5691 6.39509 13.9269 6.25143 12.8271 7.17675L11.3901 8.38588C10.0935 9.47674 9.95706 11.4241 11.0888 12.6852L11.12 12.72"/></svg>', Po = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.40999 7.29999H9.4"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 7.29999H14.59"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.30999 12H9.3"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 12H14.59"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.40999 16.7H9.4"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 16.7H14.59"/></svg>', Fo = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M12 7V12M12 17V12M17 12H12M12 12H7"/></svg>', Ho = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><circle cx="10.5" cy="10.5" r="5.5" stroke="currentColor" stroke-width="2"/><line x1="15.4142" x2="19" y1="15" y2="18.5858" stroke="currentColor" stroke-linecap="round" stroke-width="2"/></svg>', zo = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M15.7795 11.5C15.7795 11.5 16.053 11.1962 16.5497 10.6722C17.4442 9.72856 17.4701 8.2475 16.5781 7.30145V7.30145C15.6482 6.31522 14.0873 6.29227 13.1288 7.25073L11.8796 8.49999"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8.24517 12.3883C8.24517 12.3883 7.97171 12.6922 7.47504 13.2161C6.58051 14.1598 6.55467 15.6408 7.44666 16.5869V16.5869C8.37653 17.5731 9.93744 17.5961 10.8959 16.6376L12.1452 15.3883"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M17.7802 15.1032L16.597 14.9422C16.0109 14.8624 15.4841 15.3059 15.4627 15.8969L15.4199 17.0818"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6.39064 9.03238L7.58432 9.06668C8.17551 9.08366 8.6522 8.58665 8.61056 7.99669L8.5271 6.81397"/><line x1="12.1142" x2="11.7" y1="12.2" y2="11.7858" stroke="currentColor" stroke-linecap="round" stroke-width="2"/></svg>', Uo = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/><line x1="12" x2="12" y1="9" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M12 15.02V15.01"/></svg>';
let _$1 = class _ {
  /**
   * Constructs popover item instance
   *
   * @param params - popover item construction params
   */
  constructor(e2) {
    this.nodes = {
      root: null,
      icon: null
    }, this.confirmationState = null, this.removeSpecialFocusBehavior = () => {
      this.nodes.root.classList.remove(_.CSS.noFocus);
    }, this.removeSpecialHoverBehavior = () => {
      this.nodes.root.classList.remove(_.CSS.noHover);
    }, this.onErrorAnimationEnd = () => {
      this.nodes.icon.classList.remove(_.CSS.wobbleAnimation), this.nodes.icon.removeEventListener("animationend", this.onErrorAnimationEnd);
    }, this.params = e2, this.nodes.root = this.make(e2);
  }
  /**
   * True if item is disabled and hence not clickable
   */
  get isDisabled() {
    return this.params.isDisabled;
  }
  /**
   * Exposes popover item toggle parameter
   */
  get toggle() {
    return this.params.toggle;
  }
  /**
   * Item title
   */
  get title() {
    return this.params.title;
  }
  /**
   * True if popover should close once item is activated
   */
  get closeOnActivate() {
    return this.params.closeOnActivate;
  }
  /**
   * True if confirmation state is enabled for popover item
   */
  get isConfirmationStateEnabled() {
    return this.confirmationState !== null;
  }
  /**
   * True if item is focused in keyboard navigation process
   */
  get isFocused() {
    return this.nodes.root.classList.contains(_.CSS.focused);
  }
  /**
   * Popover item CSS classes
   */
  static get CSS() {
    return {
      container: "ce-popover-item",
      title: "ce-popover-item__title",
      secondaryTitle: "ce-popover-item__secondary-title",
      icon: "ce-popover-item__icon",
      active: "ce-popover-item--active",
      disabled: "ce-popover-item--disabled",
      focused: "ce-popover-item--focused",
      hidden: "ce-popover-item--hidden",
      confirmationState: "ce-popover-item--confirmation",
      noHover: "ce-popover-item--no-hover",
      noFocus: "ce-popover-item--no-focus",
      wobbleAnimation: "wobble"
    };
  }
  /**
   * Returns popover item root element
   */
  getElement() {
    return this.nodes.root;
  }
  /**
   * Called on popover item click
   */
  handleClick() {
    if (this.isConfirmationStateEnabled) {
      this.activateOrEnableConfirmationMode(this.confirmationState);
      return;
    }
    this.activateOrEnableConfirmationMode(this.params);
  }
  /**
   * Toggles item active state
   *
   * @param isActive - true if item should strictly should become active
   */
  toggleActive(e2) {
    this.nodes.root.classList.toggle(_.CSS.active, e2);
  }
  /**
   * Toggles item hidden state
   *
   * @param isHidden - true if item should be hidden
   */
  toggleHidden(e2) {
    this.nodes.root.classList.toggle(_.CSS.hidden, e2);
  }
  /**
   * Resets popover item to its original state
   */
  reset() {
    this.isConfirmationStateEnabled && this.disableConfirmationMode();
  }
  /**
   * Method called once item becomes focused during keyboard navigation
   */
  onFocus() {
    this.disableSpecialHoverAndFocusBehavior();
  }
  /**
   * Constructs HTML element corresponding to popover item params
   *
   * @param params - item construction params
   */
  make(e2) {
    const t2 = c$4.make("div", _.CSS.container);
    return e2.name && (t2.dataset.itemName = e2.name), this.nodes.icon = c$4.make("div", _.CSS.icon, {
      innerHTML: e2.icon || Ro
    }), t2.appendChild(this.nodes.icon), t2.appendChild(c$4.make("div", _.CSS.title, {
      innerHTML: e2.title || ""
    })), e2.secondaryLabel && t2.appendChild(c$4.make("div", _.CSS.secondaryTitle, {
      textContent: e2.secondaryLabel
    })), e2.isActive && t2.classList.add(_.CSS.active), e2.isDisabled && t2.classList.add(_.CSS.disabled), t2;
  }
  /**
   * Activates confirmation mode for the item.
   *
   * @param newState - new popover item params that should be applied
   */
  enableConfirmationMode(e2) {
    const t2 = {
      ...this.params,
      ...e2,
      confirmation: e2.confirmation
    }, o3 = this.make(t2);
    this.nodes.root.innerHTML = o3.innerHTML, this.nodes.root.classList.add(_.CSS.confirmationState), this.confirmationState = e2, this.enableSpecialHoverAndFocusBehavior();
  }
  /**
   * Returns item to its original state
   */
  disableConfirmationMode() {
    const e2 = this.make(this.params);
    this.nodes.root.innerHTML = e2.innerHTML, this.nodes.root.classList.remove(_.CSS.confirmationState), this.confirmationState = null, this.disableSpecialHoverAndFocusBehavior();
  }
  /**
   * Enables special focus and hover behavior for item in confirmation state.
   * This is needed to prevent item from being highlighted as hovered/focused just after click.
   */
  enableSpecialHoverAndFocusBehavior() {
    this.nodes.root.classList.add(_.CSS.noHover), this.nodes.root.classList.add(_.CSS.noFocus), this.nodes.root.addEventListener("mouseleave", this.removeSpecialHoverBehavior, { once: true });
  }
  /**
   * Disables special focus and hover behavior
   */
  disableSpecialHoverAndFocusBehavior() {
    this.removeSpecialFocusBehavior(), this.removeSpecialHoverBehavior(), this.nodes.root.removeEventListener("mouseleave", this.removeSpecialHoverBehavior);
  }
  /**
   * Executes item's onActivate callback if the item has no confirmation configured
   *
   * @param item - item to activate or bring to confirmation mode
   */
  activateOrEnableConfirmationMode(e2) {
    if (e2.confirmation === void 0)
      try {
        e2.onActivate(e2), this.disableConfirmationMode();
      } catch {
        this.animateError();
      }
    else
      this.enableConfirmationMode(e2.confirmation);
  }
  /**
   * Animates item which symbolizes that error occured while executing 'onActivate()' callback
   */
  animateError() {
    this.nodes.icon.classList.contains(_.CSS.wobbleAnimation) || (this.nodes.icon.classList.add(_.CSS.wobbleAnimation), this.nodes.icon.addEventListener("animationend", this.onErrorAnimationEnd));
  }
};
const he = class {
  /**
   * @param {HTMLElement[]} nodeList — the list of iterable HTML-items
   * @param {string} focusedCssClass - user-provided CSS-class that will be set in flipping process
   */
  constructor(s4, e2) {
    this.cursor = -1, this.items = [], this.items = s4 || [], this.focusedCssClass = e2;
  }
  /**
   * Returns Focused button Node
   *
   * @returns {HTMLElement}
   */
  get currentItem() {
    return this.cursor === -1 ? null : this.items[this.cursor];
  }
  /**
   * Sets cursor to specified position
   *
   * @param cursorPosition - new cursor position
   */
  setCursor(s4) {
    s4 < this.items.length && s4 >= -1 && (this.dropCursor(), this.cursor = s4, this.items[this.cursor].classList.add(this.focusedCssClass));
  }
  /**
   * Sets items. Can be used when iterable items changed dynamically
   *
   * @param {HTMLElement[]} nodeList - nodes to iterate
   */
  setItems(s4) {
    this.items = s4;
  }
  /**
   * Sets cursor next to the current
   */
  next() {
    this.cursor = this.leafNodesAndReturnIndex(he.directions.RIGHT);
  }
  /**
   * Sets cursor before current
   */
  previous() {
    this.cursor = this.leafNodesAndReturnIndex(he.directions.LEFT);
  }
  /**
   * Sets cursor to the default position and removes CSS-class from previously focused item
   */
  dropCursor() {
    this.cursor !== -1 && (this.items[this.cursor].classList.remove(this.focusedCssClass), this.cursor = -1);
  }
  /**
   * Leafs nodes inside the target list from active element
   *
   * @param {string} direction - leaf direction. Can be 'left' or 'right'
   * @returns {number} index of focused node
   */
  leafNodesAndReturnIndex(s4) {
    if (this.items.length === 0)
      return this.cursor;
    let e2 = this.cursor;
    return e2 === -1 ? e2 = s4 === he.directions.RIGHT ? -1 : 0 : this.items[e2].classList.remove(this.focusedCssClass), s4 === he.directions.RIGHT ? e2 = (e2 + 1) % this.items.length : e2 = (this.items.length + e2 - 1) % this.items.length, c$4.canSetCaret(this.items[e2]) && xe(() => b$1.setCursor(this.items[e2]), 50)(), this.items[e2].classList.add(this.focusedCssClass), e2;
  }
};
let ne = he;
ne.directions = {
  RIGHT: "right",
  LEFT: "left"
};
class q {
  /**
   * @param {FlipperOptions} options - different constructing settings
   */
  constructor(e2) {
    this.iterator = null, this.activated = false, this.flipCallbacks = [], this.onKeyDown = (t2) => {
      if (this.isEventReadyForHandling(t2))
        switch (q.usedKeys.includes(t2.keyCode) && t2.preventDefault(), t2.keyCode) {
          case v$1.TAB:
            this.handleTabPress(t2);
            break;
          case v$1.LEFT:
          case v$1.UP:
            this.flipLeft();
            break;
          case v$1.RIGHT:
          case v$1.DOWN:
            this.flipRight();
            break;
          case v$1.ENTER:
            this.handleEnterPress(t2);
            break;
        }
    }, this.iterator = new ne(e2.items, e2.focusedItemClass), this.activateCallback = e2.activateCallback, this.allowedKeys = e2.allowedKeys || q.usedKeys;
  }
  /**
   * True if flipper is currently activated
   */
  get isActivated() {
    return this.activated;
  }
  /**
   * Array of keys (codes) that is handled by Flipper
   * Used to:
   *  - preventDefault only for this keys, not all keydowns (@see constructor)
   *  - to skip external behaviours only for these keys, when filler is activated (@see BlockEvents@arrowRightAndDown)
   */
  static get usedKeys() {
    return [
      v$1.TAB,
      v$1.LEFT,
      v$1.RIGHT,
      v$1.ENTER,
      v$1.UP,
      v$1.DOWN
    ];
  }
  /**
   * Active tab/arrows handling by flipper
   *
   * @param items - Some modules (like, InlineToolbar, BlockSettings) might refresh buttons dynamically
   * @param cursorPosition - index of the item that should be focused once flipper is activated
   */
  activate(e2, t2) {
    this.activated = true, e2 && this.iterator.setItems(e2), t2 !== void 0 && this.iterator.setCursor(t2), document.addEventListener("keydown", this.onKeyDown, true);
  }
  /**
   * Disable tab/arrows handling by flipper
   */
  deactivate() {
    this.activated = false, this.dropCursor(), document.removeEventListener("keydown", this.onKeyDown);
  }
  /**
   * Focus first item
   */
  focusFirst() {
    this.dropCursor(), this.flipRight();
  }
  /**
   * Focuses previous flipper iterator item
   */
  flipLeft() {
    this.iterator.previous(), this.flipCallback();
  }
  /**
   * Focuses next flipper iterator item
   */
  flipRight() {
    this.iterator.next(), this.flipCallback();
  }
  /**
   * Return true if some button is focused
   */
  hasFocus() {
    return !!this.iterator.currentItem;
  }
  /**
   * Registeres function that should be executed on each navigation action
   *
   * @param cb - function to execute
   */
  onFlip(e2) {
    this.flipCallbacks.push(e2);
  }
  /**
   * Unregisteres function that is executed on each navigation action
   *
   * @param cb - function to stop executing
   */
  removeOnFlip(e2) {
    this.flipCallbacks = this.flipCallbacks.filter((t2) => t2 !== e2);
  }
  /**
   * Drops flipper's iterator cursor
   *
   * @see DomIterator#dropCursor
   */
  dropCursor() {
    this.iterator.dropCursor();
  }
  /**
   * This function is fired before handling flipper keycodes
   * The result of this function defines if it is need to be handled or not
   *
   * @param {KeyboardEvent} event - keydown keyboard event
   * @returns {boolean}
   */
  isEventReadyForHandling(e2) {
    return this.activated && this.allowedKeys.includes(e2.keyCode);
  }
  /**
   * When flipper is activated tab press will leaf the items
   *
   * @param {KeyboardEvent} event - tab keydown event
   */
  handleTabPress(e2) {
    switch (e2.shiftKey ? ne.directions.LEFT : ne.directions.RIGHT) {
      case ne.directions.RIGHT:
        this.flipRight();
        break;
      case ne.directions.LEFT:
        this.flipLeft();
        break;
    }
  }
  /**
   * Enter press will click current item if flipper is activated
   *
   * @param {KeyboardEvent} event - enter keydown event
   */
  handleEnterPress(e2) {
    this.activated && (this.iterator.currentItem && (e2.stopPropagation(), e2.preventDefault(), this.iterator.currentItem.click()), M$2(this.activateCallback) && this.activateCallback(this.iterator.currentItem));
  }
  /**
   * Fired after flipping in any direction
   */
  flipCallback() {
    this.iterator.currentItem && this.iterator.currentItem.scrollIntoViewIfNeeded(), this.flipCallbacks.forEach((e2) => e2());
  }
}
class pe {
  /**
   * Styles
   */
  static get CSS() {
    return {
      wrapper: "cdx-search-field",
      icon: "cdx-search-field__icon",
      input: "cdx-search-field__input"
    };
  }
  /**
   * @param options - available config
   * @param options.items - searchable items list
   * @param options.onSearch - search callback
   * @param options.placeholder - input placeholder
   */
  constructor({ items: e2, onSearch: t2, placeholder: o3 }) {
    this.listeners = new Fe(), this.items = e2, this.onSearch = t2, this.render(o3);
  }
  /**
   * Returns search field element
   */
  getElement() {
    return this.wrapper;
  }
  /**
   * Sets focus to the input
   */
  focus() {
    this.input.focus();
  }
  /**
   * Clears search query and results
   */
  clear() {
    this.input.value = "", this.searchQuery = "", this.onSearch("", this.foundItems);
  }
  /**
   * Clears memory
   */
  destroy() {
    this.listeners.removeAll();
  }
  /**
   * Creates the search field
   *
   * @param placeholder - input placeholder
   */
  render(e2) {
    this.wrapper = c$4.make("div", pe.CSS.wrapper);
    const t2 = c$4.make("div", pe.CSS.icon, {
      innerHTML: Ho
    });
    this.input = c$4.make("input", pe.CSS.input, {
      placeholder: e2,
      /**
       * Used to prevent focusing on the input by Tab key
       * (Popover in the Toolbar lays below the blocks,
       * so Tab in the last block will focus this hidden input if this property is not set)
       */
      tabIndex: -1
    }), this.wrapper.appendChild(t2), this.wrapper.appendChild(this.input), this.listeners.on(this.input, "input", () => {
      this.searchQuery = this.input.value, this.onSearch(this.searchQuery, this.foundItems);
    });
  }
  /**
   * Returns list of found items for the current search query
   */
  get foundItems() {
    return this.items.filter((e2) => this.checkItem(e2));
  }
  /**
   * Contains logic for checking whether passed item conforms the search query
   *
   * @param item - item to be checked
   */
  checkItem(e2) {
    var i2;
    const t2 = ((i2 = e2.title) == null ? void 0 : i2.toLowerCase()) || "", o3 = this.searchQuery.toLowerCase();
    return t2.includes(o3);
  }
}
const ue = class {
  /**
   * Locks body element scroll
   */
  lock() {
    tt ? this.lockHard() : document.body.classList.add(ue.CSS.scrollLocked);
  }
  /**
   * Unlocks body element scroll
   */
  unlock() {
    tt ? this.unlockHard() : document.body.classList.remove(ue.CSS.scrollLocked);
  }
  /**
   * Locks scroll in a hard way (via setting fixed position to body element)
   */
  lockHard() {
    this.scrollPosition = window.pageYOffset, document.documentElement.style.setProperty(
      "--window-scroll-offset",
      `${this.scrollPosition}px`
    ), document.body.classList.add(ue.CSS.scrollLockedHard);
  }
  /**
   * Unlocks hard scroll lock
   */
  unlockHard() {
    document.body.classList.remove(ue.CSS.scrollLockedHard), this.scrollPosition !== null && window.scrollTo(0, this.scrollPosition), this.scrollPosition = null;
  }
};
let vt = ue;
vt.CSS = {
  scrollLocked: "ce-scroll-locked",
  scrollLockedHard: "ce-scroll-locked--hard"
};
var jo = Object.defineProperty, $o = Object.getOwnPropertyDescriptor, Wo = (s4, e2, t2, o3) => {
  for (var i2 = o3 > 1 ? void 0 : o3 ? $o(e2, t2) : e2, n3 = s4.length - 1, r4; n3 >= 0; n3--)
    (r4 = s4[n3]) && (i2 = (o3 ? r4(e2, t2, i2) : r4(i2)) || i2);
  return o3 && i2 && jo(e2, t2, i2), i2;
}, be = /* @__PURE__ */ ((s4) => (s4.Close = "close", s4))(be || {});
const N = class extends Ee {
  /**
   * Constructs the instance
   *
   * @param params - popover construction params
   */
  constructor(s4) {
    super(), this.scopeElement = document.body, this.listeners = new Fe(), this.scrollLocker = new vt(), this.nodes = {
      wrapper: null,
      popover: null,
      nothingFoundMessage: null,
      customContent: null,
      items: null,
      overlay: null
    }, this.messages = {
      nothingFound: "Nothing found",
      search: "Search"
    }, this.onFlip = () => {
      this.items.find((t2) => t2.isFocused).onFocus();
    }, this.items = s4.items.map((e2) => new _$1(e2)), s4.scopeElement !== void 0 && (this.scopeElement = s4.scopeElement), s4.messages && (this.messages = {
      ...this.messages,
      ...s4.messages
    }), s4.customContentFlippableItems && (this.customContentFlippableItems = s4.customContentFlippableItems), this.make(), s4.customContent && this.addCustomContent(s4.customContent), s4.searchable && this.addSearch(), this.initializeFlipper();
  }
  /**
   * Popover CSS classes
   */
  static get CSS() {
    return {
      popover: "ce-popover",
      popoverOpenTop: "ce-popover--open-top",
      popoverOpened: "ce-popover--opened",
      search: "ce-popover__search",
      nothingFoundMessage: "ce-popover__nothing-found-message",
      nothingFoundMessageDisplayed: "ce-popover__nothing-found-message--displayed",
      customContent: "ce-popover__custom-content",
      customContentHidden: "ce-popover__custom-content--hidden",
      items: "ce-popover__items",
      overlay: "ce-popover__overlay",
      overlayHidden: "ce-popover__overlay--hidden"
    };
  }
  /**
   * Returns HTML element corresponding to the popover
   */
  getElement() {
    return this.nodes.wrapper;
  }
  /**
   * Returns true if some item inside popover is focused
   */
  hasFocus() {
    return this.flipper.hasFocus();
  }
  /**
   * Open popover
   */
  show() {
    this.shouldOpenBottom || (this.nodes.popover.style.setProperty("--popover-height", this.height + "px"), this.nodes.popover.classList.add(N.CSS.popoverOpenTop)), this.nodes.overlay.classList.remove(N.CSS.overlayHidden), this.nodes.popover.classList.add(N.CSS.popoverOpened), this.flipper.activate(this.flippableElements), this.search !== void 0 && requestAnimationFrame(() => {
      var s4;
      (s4 = this.search) == null || s4.focus();
    }), te() && this.scrollLocker.lock();
  }
  /**
   * Closes popover
   */
  hide() {
    this.nodes.popover.classList.remove(N.CSS.popoverOpened), this.nodes.popover.classList.remove(N.CSS.popoverOpenTop), this.nodes.overlay.classList.add(N.CSS.overlayHidden), this.flipper.deactivate(), this.items.forEach((s4) => s4.reset()), this.search !== void 0 && this.search.clear(), te() && this.scrollLocker.unlock(), this.emit(
      "close"
      /* Close */
    );
  }
  /**
   * Clears memory
   */
  destroy() {
    this.flipper.deactivate(), this.listeners.removeAll(), te() && this.scrollLocker.unlock();
  }
  /**
   * Constructs HTML element corresponding to popover
   */
  make() {
    this.nodes.popover = c$4.make("div", [N.CSS.popover]), this.nodes.nothingFoundMessage = c$4.make("div", [N.CSS.nothingFoundMessage], {
      textContent: this.messages.nothingFound
    }), this.nodes.popover.appendChild(this.nodes.nothingFoundMessage), this.nodes.items = c$4.make("div", [N.CSS.items]), this.items.forEach((s4) => {
      this.nodes.items.appendChild(s4.getElement());
    }), this.nodes.popover.appendChild(this.nodes.items), this.listeners.on(this.nodes.popover, "click", (s4) => {
      const e2 = this.getTargetItem(s4);
      e2 !== void 0 && this.handleItemClick(e2);
    }), this.nodes.wrapper = c$4.make("div"), this.nodes.overlay = c$4.make("div", [N.CSS.overlay, N.CSS.overlayHidden]), this.listeners.on(this.nodes.overlay, "click", () => {
      this.hide();
    }), this.nodes.wrapper.appendChild(this.nodes.overlay), this.nodes.wrapper.appendChild(this.nodes.popover);
  }
  /**
   * Adds search to the popover
   */
  addSearch() {
    this.search = new pe({
      items: this.items,
      placeholder: this.messages.search,
      onSearch: (e2, t2) => {
        this.items.forEach((i2) => {
          const n3 = !t2.includes(i2);
          i2.toggleHidden(n3);
        }), this.toggleNothingFoundMessage(t2.length === 0), this.toggleCustomContent(e2 !== "");
        const o3 = e2 === "" ? this.flippableElements : t2.map((i2) => i2.getElement());
        this.flipper.isActivated && (this.flipper.deactivate(), this.flipper.activate(o3));
      }
    });
    const s4 = this.search.getElement();
    s4.classList.add(N.CSS.search), this.nodes.popover.insertBefore(s4, this.nodes.popover.firstChild);
  }
  /**
   * Adds custom html content to the popover
   *
   * @param content - html content to append
   */
  addCustomContent(s4) {
    this.nodes.customContent = s4, this.nodes.customContent.classList.add(N.CSS.customContent), this.nodes.popover.insertBefore(s4, this.nodes.popover.firstChild);
  }
  /**
   * Retrieves popover item that is the target of the specified event
   *
   * @param event - event to retrieve popover item from
   */
  getTargetItem(s4) {
    return this.items.find((e2) => s4.composedPath().includes(e2.getElement()));
  }
  /**
   * Handles item clicks
   *
   * @param item - item to handle click of
   */
  handleItemClick(s4) {
    s4.isDisabled || (this.items.filter((e2) => e2 !== s4).forEach((e2) => e2.reset()), s4.handleClick(), this.toggleItemActivenessIfNeeded(s4), s4.closeOnActivate && this.hide());
  }
  /**
   * Creates Flipper instance which allows to navigate between popover items via keyboard
   */
  initializeFlipper() {
    this.flipper = new q({
      items: this.flippableElements,
      focusedItemClass: _$1.CSS.focused,
      allowedKeys: [
        v$1.TAB,
        v$1.UP,
        v$1.DOWN,
        v$1.ENTER
      ]
    }), this.flipper.onFlip(this.onFlip);
  }
  /**
   * Returns list of elements available for keyboard navigation.
   * Contains both usual popover items elements and custom html content.
   */
  get flippableElements() {
    const s4 = this.items.map((t2) => t2.getElement());
    return (this.customContentFlippableItems || []).concat(s4);
  }
  get height() {
    let s4 = 0;
    if (this.nodes.popover === null)
      return s4;
    const e2 = this.nodes.popover.cloneNode(true);
    return e2.style.visibility = "hidden", e2.style.position = "absolute", e2.style.top = "-1000px", e2.classList.add(N.CSS.popoverOpened), document.body.appendChild(e2), s4 = e2.offsetHeight, e2.remove(), s4;
  }
  /**
   * Checks if popover should be opened bottom.
   * It should happen when there is enough space below or not enough space above
   */
  get shouldOpenBottom() {
    const s4 = this.nodes.popover.getBoundingClientRect(), e2 = this.scopeElement.getBoundingClientRect(), t2 = this.height, o3 = s4.top + t2, i2 = s4.top - t2, n3 = Math.min(window.innerHeight, e2.bottom);
    return i2 < e2.top || o3 <= n3;
  }
  /**
   * Toggles nothing found message visibility
   *
   * @param isDisplayed - true if the message should be displayed
   */
  toggleNothingFoundMessage(s4) {
    this.nodes.nothingFoundMessage.classList.toggle(N.CSS.nothingFoundMessageDisplayed, s4);
  }
  /**
   * Toggles custom content visibility
   *
   * @param isDisplayed - true if custom content should be displayed
   */
  toggleCustomContent(s4) {
    var e2;
    (e2 = this.nodes.customContent) == null || e2.classList.toggle(N.CSS.customContentHidden, s4);
  }
  /**
   * - Toggles item active state, if clicked popover item has property 'toggle' set to true.
   *
   * - Performs radiobutton-like behavior if the item has property 'toggle' set to string key.
   * (All the other items with the same key get inactive, and the item gets active)
   *
   * @param clickedItem - popover item that was clicked
   */
  toggleItemActivenessIfNeeded(s4) {
    if (s4.toggle === true && s4.toggleActive(), typeof s4.toggle == "string") {
      const e2 = this.items.filter((t2) => t2.toggle === s4.toggle);
      if (e2.length === 1) {
        s4.toggleActive();
        return;
      }
      e2.forEach((t2) => {
        t2.toggleActive(t2 === s4);
      });
    }
  }
};
let je = N;
Wo([
  le
], je.prototype, "height", 1);
class Yo extends y$1 {
  constructor() {
    super(...arguments), this.opened = false, this.selection = new b$1(), this.onPopoverClose = () => {
      this.close();
    };
  }
  /**
   * Module Events
   *
   * @returns {{opened: string, closed: string}}
   */
  get events() {
    return {
      opened: "block-settings-opened",
      closed: "block-settings-closed"
    };
  }
  /**
   * Block Settings CSS
   */
  get CSS() {
    return {
      settings: "ce-settings"
    };
  }
  /**
   * Getter for inner popover's flipper instance
   *
   * @todo remove once BlockSettings becomes standalone non-module class
   */
  get flipper() {
    var e2;
    return (e2 = this.popover) == null ? void 0 : e2.flipper;
  }
  /**
   * Panel with block settings with 2 sections:
   *  - Tool's Settings
   *  - Default Settings [Move, Remove, etc]
   */
  make() {
    this.nodes.wrapper = c$4.make("div", [this.CSS.settings]);
  }
  /**
   * Destroys module
   */
  destroy() {
    this.removeAllNodes();
  }
  /**
   * Open Block Settings pane
   *
   * @param targetBlock - near which Block we should open BlockSettings
   */
  open(e2 = this.Editor.BlockManager.currentBlock) {
    this.opened = true, this.selection.save(), this.Editor.BlockSelection.selectBlock(e2), this.Editor.BlockSelection.clearCache();
    const [t2, o3] = e2.getTunes();
    this.eventsDispatcher.emit(this.events.opened), this.popover = new je({
      searchable: true,
      items: t2.map((i2) => this.resolveTuneAliases(i2)),
      customContent: o3,
      customContentFlippableItems: this.getControls(o3),
      scopeElement: this.Editor.API.methods.ui.nodes.redactor,
      messages: {
        nothingFound: z.ui(K.ui.popover, "Nothing found"),
        search: z.ui(K.ui.popover, "Filter")
      }
    }), this.popover.on(be.Close, this.onPopoverClose), this.nodes.wrapper.append(this.popover.getElement()), this.popover.show();
  }
  /**
   * Returns root block settings element
   */
  getElement() {
    return this.nodes.wrapper;
  }
  /**
   * Close Block Settings pane
   */
  close() {
    this.opened && (this.opened = false, b$1.isAtEditor || this.selection.restore(), this.selection.clearSaved(), !this.Editor.CrossBlockSelection.isCrossBlockSelectionStarted && this.Editor.BlockManager.currentBlock && this.Editor.BlockSelection.unselectBlock(this.Editor.BlockManager.currentBlock), this.eventsDispatcher.emit(this.events.closed), this.popover && (this.popover.off(be.Close, this.onPopoverClose), this.popover.destroy(), this.popover.getElement().remove(), this.popover = null));
  }
  /**
   * Returns list of buttons and inputs inside specified container
   *
   * @param container - container to query controls inside of
   */
  getControls(e2) {
    const { StylesAPI: t2 } = this.Editor, o3 = e2.querySelectorAll(
      `.${t2.classes.settingsButton}, ${c$4.allInputsSelector}`
    );
    return Array.from(o3);
  }
  /**
   * Resolves aliases in tunes menu items
   *
   * @param item - item with resolved aliases
   */
  resolveTuneAliases(e2) {
    const t2 = Ao(e2, { label: "title" });
    return e2.confirmation && (t2.confirmation = this.resolveTuneAliases(e2.confirmation)), t2;
  }
}
class $ extends y$1 {
  constructor() {
    super(...arguments), this.opened = false, this.tools = [], this.flipper = null, this.togglingCallback = null;
  }
  /**
   * CSS getter
   */
  static get CSS() {
    return {
      conversionToolbarWrapper: "ce-conversion-toolbar",
      conversionToolbarShowed: "ce-conversion-toolbar--showed",
      conversionToolbarTools: "ce-conversion-toolbar__tools",
      conversionToolbarLabel: "ce-conversion-toolbar__label",
      conversionTool: "ce-conversion-tool",
      conversionToolHidden: "ce-conversion-tool--hidden",
      conversionToolIcon: "ce-conversion-tool__icon",
      conversionToolSecondaryLabel: "ce-conversion-tool__secondary-label",
      conversionToolFocused: "ce-conversion-tool--focused",
      conversionToolActive: "ce-conversion-tool--active"
    };
  }
  /**
   * Create UI of Conversion Toolbar
   */
  make() {
    this.nodes.wrapper = c$4.make("div", [
      $.CSS.conversionToolbarWrapper,
      ...this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []
    ]), this.nodes.tools = c$4.make("div", $.CSS.conversionToolbarTools);
    const e2 = c$4.make("div", $.CSS.conversionToolbarLabel, {
      textContent: z.ui(K.ui.inlineToolbar.converter, "Convert to")
    });
    return this.addTools(), this.enableFlipper(), c$4.append(this.nodes.wrapper, e2), c$4.append(this.nodes.wrapper, this.nodes.tools), this.nodes.wrapper;
  }
  /**
   * Deactivates flipper and removes all nodes
   */
  destroy() {
    this.flipper && (this.flipper.deactivate(), this.flipper = null), this.removeAllNodes();
  }
  /**
   * Toggle conversion dropdown visibility
   *
   * @param {Function} [togglingCallback] — callback that will accept opening state
   */
  toggle(e2) {
    this.opened ? this.close() : this.open(), M$2(e2) && (this.togglingCallback = e2);
  }
  /**
   * Shows Conversion Toolbar
   */
  open() {
    this.filterTools(), this.opened = true, this.nodes.wrapper.classList.add($.CSS.conversionToolbarShowed), window.requestAnimationFrame(() => {
      this.flipper.activate(this.tools.map((e2) => e2.button).filter((e2) => !e2.classList.contains($.CSS.conversionToolHidden))), this.flipper.focusFirst(), M$2(this.togglingCallback) && this.togglingCallback(true);
    });
  }
  /**
   * Closes Conversion Toolbar
   */
  close() {
    this.opened = false, this.flipper.deactivate(), this.nodes.wrapper.classList.remove($.CSS.conversionToolbarShowed), M$2(this.togglingCallback) && this.togglingCallback(false);
  }
  /**
   * Returns true if it has more than one tool available for convert in
   */
  hasTools() {
    return this.tools.length === 1 ? this.tools[0].name !== this.config.defaultBlock : true;
  }
  /**
   * Replaces one Block with another
   * For that Tools must provide import/export methods
   *
   * @param {string} replacingToolName - name of Tool which replaces current
   * @param blockDataOverrides - If this conversion fired by the one of multiple Toolbox items, extend converted data with this item's "data" overrides
   */
  async replaceWithBlock(e2, t2) {
    const { BlockManager: o3, BlockSelection: i2, InlineToolbar: n3, Caret: r4 } = this.Editor;
    o3.convert(this.Editor.BlockManager.currentBlock, e2, t2), i2.clearSelection(), this.close(), n3.close(), window.requestAnimationFrame(() => {
      r4.setToBlock(this.Editor.BlockManager.currentBlock, r4.positions.END);
    });
  }
  /**
   * Iterates existing Tools and inserts to the ConversionToolbar
   * if tools have ability to import
   */
  addTools() {
    const e2 = this.Editor.Tools.blockTools;
    Array.from(e2.entries()).forEach(([t2, o3]) => {
      var n3;
      const i2 = o3.conversionConfig;
      !i2 || !i2.import || (n3 = o3.toolbox) == null || n3.forEach(
        (r4) => this.addToolIfValid(t2, r4)
      );
    });
  }
  /**
   * Inserts a tool to the ConversionToolbar if the tool's toolbox config is valid
   *
   * @param name - tool's name
   * @param toolboxSettings - tool's single toolbox setting
   */
  addToolIfValid(e2, t2) {
    W(t2) || !t2.icon || this.addTool(e2, t2);
  }
  /**
   * Add tool to the Conversion Toolbar
   *
   * @param toolName - name of Tool to add
   * @param toolboxItem - tool's toolbox item data
   */
  addTool(e2, t2) {
    var r4;
    const o3 = c$4.make("div", [$.CSS.conversionTool]), i2 = c$4.make("div", [$.CSS.conversionToolIcon]);
    o3.dataset.tool = e2, i2.innerHTML = t2.icon, c$4.append(o3, i2), c$4.append(o3, c$4.text(z.t(K.toolNames, t2.title || re(e2))));
    const n3 = (r4 = this.Editor.Tools.blockTools.get(e2)) == null ? void 0 : r4.shortcut;
    if (n3) {
      const a3 = c$4.make("span", $.CSS.conversionToolSecondaryLabel, {
        innerText: ye(n3)
      });
      c$4.append(o3, a3);
    }
    c$4.append(this.nodes.tools, o3), this.tools.push({
      name: e2,
      button: o3,
      toolboxItem: t2
    }), this.listeners.on(o3, "click", async () => {
      await this.replaceWithBlock(e2, t2.data);
    });
  }
  /**
   * Hide current Tool and show others
   */
  async filterTools() {
    const { currentBlock: e2 } = this.Editor.BlockManager, t2 = await e2.getActiveToolboxEntry();
    function o3(i2, n3) {
      return i2.icon === n3.icon && i2.title === n3.title;
    }
    this.tools.forEach((i2) => {
      let n3 = false;
      if (t2) {
        const r4 = o3(t2, i2.toolboxItem);
        n3 = i2.button.dataset.tool === e2.name && r4;
      }
      i2.button.hidden = n3, i2.button.classList.toggle($.CSS.conversionToolHidden, n3);
    });
  }
  /**
   * Prepare Flipper to be able to leaf tools by arrows/tab
   */
  enableFlipper() {
    this.flipper = new q({
      focusedItemClass: $.CSS.conversionToolFocused
    });
  }
}
var De = {}, Ko = {
  get exports() {
    return De;
  },
  set exports(s4) {
    De = s4;
  }
};
/*!
 * Library for handling keyboard shortcuts
 * @copyright CodeX (https://codex.so)
 * @license MIT
 * @author CodeX (https://codex.so)
 * @version 1.2.0
 */
(function(s4, e2) {
  (function(t2, o3) {
    s4.exports = o3();
  })(window, function() {
    return function(t2) {
      var o3 = {};
      function i2(n3) {
        if (o3[n3])
          return o3[n3].exports;
        var r4 = o3[n3] = { i: n3, l: false, exports: {} };
        return t2[n3].call(r4.exports, r4, r4.exports, i2), r4.l = true, r4.exports;
      }
      return i2.m = t2, i2.c = o3, i2.d = function(n3, r4, a3) {
        i2.o(n3, r4) || Object.defineProperty(n3, r4, { enumerable: true, get: a3 });
      }, i2.r = function(n3) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(n3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n3, "__esModule", { value: true });
      }, i2.t = function(n3, r4) {
        if (1 & r4 && (n3 = i2(n3)), 8 & r4 || 4 & r4 && typeof n3 == "object" && n3 && n3.__esModule)
          return n3;
        var a3 = /* @__PURE__ */ Object.create(null);
        if (i2.r(a3), Object.defineProperty(a3, "default", { enumerable: true, value: n3 }), 2 & r4 && typeof n3 != "string")
          for (var l2 in n3)
            i2.d(a3, l2, (function(d4) {
              return n3[d4];
            }).bind(null, l2));
        return a3;
      }, i2.n = function(n3) {
        var r4 = n3 && n3.__esModule ? function() {
          return n3.default;
        } : function() {
          return n3;
        };
        return i2.d(r4, "a", r4), r4;
      }, i2.o = function(n3, r4) {
        return Object.prototype.hasOwnProperty.call(n3, r4);
      }, i2.p = "", i2(i2.s = 0);
    }([function(t2, o3, i2) {
      function n3(l2, d4) {
        for (var u3 = 0; u3 < d4.length; u3++) {
          var h2 = d4[u3];
          h2.enumerable = h2.enumerable || false, h2.configurable = true, "value" in h2 && (h2.writable = true), Object.defineProperty(l2, h2.key, h2);
        }
      }
      function r4(l2, d4, u3) {
        return d4 && n3(l2.prototype, d4), u3 && n3(l2, u3), l2;
      }
      i2.r(o3);
      var a3 = function() {
        function l2(d4) {
          var u3 = this;
          (function(h2, f2) {
            if (!(h2 instanceof f2))
              throw new TypeError("Cannot call a class as a function");
          })(this, l2), this.commands = {}, this.keys = {}, this.name = d4.name, this.parseShortcutName(d4.name), this.element = d4.on, this.callback = d4.callback, this.executeShortcut = function(h2) {
            u3.execute(h2);
          }, this.element.addEventListener("keydown", this.executeShortcut, false);
        }
        return r4(l2, null, [{ key: "supportedCommands", get: function() {
          return { SHIFT: ["SHIFT"], CMD: ["CMD", "CONTROL", "COMMAND", "WINDOWS", "CTRL"], ALT: ["ALT", "OPTION"] };
        } }, { key: "keyCodes", get: function() {
          return { 0: 48, 1: 49, 2: 50, 3: 51, 4: 52, 5: 53, 6: 54, 7: 55, 8: 56, 9: 57, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, BACKSPACE: 8, ENTER: 13, ESCAPE: 27, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, INSERT: 45, DELETE: 46, ".": 190 };
        } }]), r4(l2, [{ key: "parseShortcutName", value: function(d4) {
          d4 = d4.split("+");
          for (var u3 = 0; u3 < d4.length; u3++) {
            d4[u3] = d4[u3].toUpperCase();
            var h2 = false;
            for (var f2 in l2.supportedCommands)
              if (l2.supportedCommands[f2].includes(d4[u3])) {
                h2 = this.commands[f2] = true;
                break;
              }
            h2 || (this.keys[d4[u3]] = true);
          }
          for (var x2 in l2.supportedCommands)
            this.commands[x2] || (this.commands[x2] = false);
        } }, { key: "execute", value: function(d4) {
          var u3, h2 = { CMD: d4.ctrlKey || d4.metaKey, SHIFT: d4.shiftKey, ALT: d4.altKey }, f2 = true;
          for (u3 in this.commands)
            this.commands[u3] !== h2[u3] && (f2 = false);
          var x2, p2 = true;
          for (x2 in this.keys)
            p2 = p2 && d4.keyCode === l2.keyCodes[x2];
          f2 && p2 && this.callback(d4);
        } }, { key: "remove", value: function() {
          this.element.removeEventListener("keydown", this.executeShortcut);
        } }]), l2;
      }();
      o3.default = a3;
    }]).default;
  });
})(Ko);
const Xo = /* @__PURE__ */ Pe(De);
class Vo {
  constructor() {
    this.registeredShortcuts = /* @__PURE__ */ new Map();
  }
  /**
   * Register shortcut
   *
   * @param shortcut - shortcut options
   */
  add(e2) {
    if (this.findShortcut(e2.on, e2.name))
      throw Error(
        `Shortcut ${e2.name} is already registered for ${e2.on}. Please remove it before add a new handler.`
      );
    const o3 = new Xo({
      name: e2.name,
      on: e2.on,
      callback: e2.handler
    }), i2 = this.registeredShortcuts.get(e2.on) || [];
    this.registeredShortcuts.set(e2.on, [...i2, o3]);
  }
  /**
   * Remove shortcut
   *
   * @param element - Element shortcut is set for
   * @param name - shortcut name
   */
  remove(e2, t2) {
    const o3 = this.findShortcut(e2, t2);
    if (!o3)
      return;
    o3.remove();
    const i2 = this.registeredShortcuts.get(e2);
    this.registeredShortcuts.set(e2, i2.filter((n3) => n3 !== o3));
  }
  /**
   * Get Shortcut instance if exist
   *
   * @param element - Element shorcut is set for
   * @param shortcut - shortcut name
   * @returns {number} index - shortcut index if exist
   */
  findShortcut(e2, t2) {
    return (this.registeredShortcuts.get(e2) || []).find(({ name: i2 }) => i2 === t2);
  }
}
const ae = new Vo();
var qo = Object.defineProperty, Zo = Object.getOwnPropertyDescriptor, xt = (s4, e2, t2, o3) => {
  for (var i2 = o3 > 1 ? void 0 : o3 ? Zo(e2, t2) : e2, n3 = s4.length - 1, r4; n3 >= 0; n3--)
    (r4 = s4[n3]) && (i2 = (o3 ? r4(e2, t2, i2) : r4(i2)) || i2);
  return o3 && i2 && qo(e2, t2, i2), i2;
}, ke = /* @__PURE__ */ ((s4) => (s4.Opened = "toolbox-opened", s4.Closed = "toolbox-closed", s4.BlockAdded = "toolbox-block-added", s4))(ke || {});
const wt = class extends Ee {
  /**
   * Toolbox constructor
   *
   * @param options - available parameters
   * @param options.api - Editor API methods
   * @param options.tools - Tools available to check whether some of them should be displayed at the Toolbox or not
   */
  constructor({ api: s4, tools: e2, i18nLabels: t2 }) {
    super(), this.opened = false, this.nodes = {
      toolbox: null
    }, this.onPopoverClose = () => {
      this.opened = false, this.emit(
        "toolbox-closed"
        /* Closed */
      );
    }, this.api = s4, this.tools = e2, this.i18nLabels = t2;
  }
  /**
   * Returns True if Toolbox is Empty and nothing to show
   *
   * @returns {boolean}
   */
  get isEmpty() {
    return this.toolsToBeDisplayed.length === 0;
  }
  /**
   * CSS styles
   *
   * @returns {Object<string, string>}
   */
  static get CSS() {
    return {
      toolbox: "ce-toolbox"
    };
  }
  /**
   * Makes the Toolbox
   */
  make() {
    return this.popover = new je({
      scopeElement: this.api.ui.nodes.redactor,
      searchable: true,
      messages: {
        nothingFound: this.i18nLabels.nothingFound,
        search: this.i18nLabels.filter
      },
      items: this.toolboxItemsToBeDisplayed
    }), this.popover.on(be.Close, this.onPopoverClose), this.enableShortcuts(), this.nodes.toolbox = this.popover.getElement(), this.nodes.toolbox.classList.add(wt.CSS.toolbox), this.nodes.toolbox;
  }
  /**
   * Returns true if the Toolbox has the Flipper activated and the Flipper has selected button
   */
  hasFocus() {
    var s4;
    return (s4 = this.popover) == null ? void 0 : s4.hasFocus();
  }
  /**
   * Destroy Module
   */
  destroy() {
    var s4;
    super.destroy(), this.nodes && this.nodes.toolbox && (this.nodes.toolbox.remove(), this.nodes.toolbox = null), this.removeAllShortcuts(), (s4 = this.popover) == null || s4.off(be.Close, this.onPopoverClose);
  }
  /**
   * Toolbox Tool's button click handler
   *
   * @param toolName - tool type to be activated
   * @param blockDataOverrides - Block data predefined by the activated Toolbox item
   */
  toolButtonActivated(s4, e2) {
    this.insertNewBlock(s4, e2);
  }
  /**
   * Open Toolbox with Tools
   */
  open() {
    var s4;
    this.isEmpty || ((s4 = this.popover) == null || s4.show(), this.opened = true, this.emit(
      "toolbox-opened"
      /* Opened */
    ));
  }
  /**
   * Close Toolbox
   */
  close() {
    var s4;
    (s4 = this.popover) == null || s4.hide(), this.opened = false, this.emit(
      "toolbox-closed"
      /* Closed */
    );
  }
  /**
   * Close Toolbox
   */
  toggle() {
    this.opened ? this.close() : this.open();
  }
  get toolsToBeDisplayed() {
    const s4 = [];
    return this.tools.forEach((e2) => {
      e2.toolbox && s4.push(e2);
    }), s4;
  }
  get toolboxItemsToBeDisplayed() {
    const s4 = (e2, t2) => ({
      icon: e2.icon,
      title: z.t(K.toolNames, e2.title || re(t2.name)),
      name: t2.name,
      onActivate: () => {
        this.toolButtonActivated(t2.name, e2.data);
      },
      secondaryLabel: t2.shortcut ? ye(t2.shortcut) : ""
    });
    return this.toolsToBeDisplayed.reduce((e2, t2) => (Array.isArray(t2.toolbox) ? t2.toolbox.forEach((o3) => {
      e2.push(s4(o3, t2));
    }) : t2.toolbox !== void 0 && e2.push(s4(t2.toolbox, t2)), e2), []);
  }
  /**
   * Iterate all tools and enable theirs shortcuts if specified
   */
  enableShortcuts() {
    this.toolsToBeDisplayed.forEach((s4) => {
      const e2 = s4.shortcut;
      e2 && this.enableShortcutForTool(s4.name, e2);
    });
  }
  /**
   * Enable shortcut Block Tool implemented shortcut
   *
   * @param {string} toolName - Tool name
   * @param {string} shortcut - shortcut according to the ShortcutData Module format
   */
  enableShortcutForTool(s4, e2) {
    ae.add({
      name: e2,
      on: this.api.ui.nodes.redactor,
      handler: (t2) => {
        t2.preventDefault();
        const o3 = this.api.blocks.getCurrentBlockIndex(), i2 = this.api.blocks.getBlockByIndex(o3);
        if (i2)
          try {
            this.api.blocks.convert(i2.id, s4), window.requestAnimationFrame(() => {
              this.api.caret.setToBlock(o3, "end");
            });
            return;
          } catch {
          }
        this.insertNewBlock(s4);
      }
    });
  }
  /**
   * Removes all added shortcuts
   * Fired when the Read-Only mode is activated
   */
  removeAllShortcuts() {
    this.toolsToBeDisplayed.forEach((s4) => {
      const e2 = s4.shortcut;
      e2 && ae.remove(this.api.ui.nodes.redactor, e2);
    });
  }
  /**
   * Inserts new block
   * Can be called when button clicked on Toolbox or by ShortcutData
   *
   * @param {string} toolName - Tool name
   * @param blockDataOverrides - predefined Block data
   */
  async insertNewBlock(s4, e2) {
    const t2 = this.api.blocks.getCurrentBlockIndex(), o3 = this.api.blocks.getBlockByIndex(t2);
    if (!o3)
      return;
    const i2 = o3.isEmpty ? t2 : t2 + 1;
    let n3;
    if (e2) {
      const a3 = await this.api.blocks.composeBlockData(s4);
      n3 = Object.assign(a3, e2);
    }
    const r4 = this.api.blocks.insert(
      s4,
      n3,
      void 0,
      i2,
      void 0,
      o3.isEmpty
    );
    r4.call(X.APPEND_CALLBACK), this.api.caret.setToBlock(i2), this.emit("toolbox-block-added", {
      block: r4
    }), this.api.toolbar.close();
  }
};
let $e = wt;
xt([
  le
], $e.prototype, "toolsToBeDisplayed", 1);
xt([
  le
], $e.prototype, "toolboxItemsToBeDisplayed", 1);
const yt = "block hovered";
async function Go(s4, e2) {
  const t2 = navigator.keyboard;
  return t2 && (await t2.getLayoutMap()).get(s4) || e2;
}
class Jo extends y$1 {
  /**
   * @class
   * @param moduleConfiguration - Module Configuration
   * @param moduleConfiguration.config - Editor's config
   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
   */
  constructor({ config: e2, eventsDispatcher: t2 }) {
    super({
      config: e2,
      eventsDispatcher: t2
    }), this.toolboxInstance = null;
  }
  /**
   * CSS styles
   *
   * @returns {object}
   */
  get CSS() {
    return {
      toolbar: "ce-toolbar",
      content: "ce-toolbar__content",
      actions: "ce-toolbar__actions",
      actionsOpened: "ce-toolbar__actions--opened",
      toolbarOpened: "ce-toolbar--opened",
      openedToolboxHolderModifier: "codex-editor--toolbox-opened",
      plusButton: "ce-toolbar__plus",
      plusButtonShortcut: "ce-toolbar__plus-shortcut",
      settingsToggler: "ce-toolbar__settings-btn",
      settingsTogglerHidden: "ce-toolbar__settings-btn--hidden"
    };
  }
  /**
   * Returns the Toolbar opening state
   *
   * @returns {boolean}
   */
  get opened() {
    return this.nodes.wrapper.classList.contains(this.CSS.toolbarOpened);
  }
  /**
   * Public interface for accessing the Toolbox
   */
  get toolbox() {
    var e2;
    return {
      opened: (e2 = this.toolboxInstance) == null ? void 0 : e2.opened,
      close: () => {
        var t2;
        (t2 = this.toolboxInstance) == null || t2.close();
      },
      open: () => {
        if (this.toolboxInstance === null) {
          T$1("toolbox.open() called before initialization is finished", "warn");
          return;
        }
        this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.toolboxInstance.open();
      },
      toggle: () => {
        if (this.toolboxInstance === null) {
          T$1("toolbox.toggle() called before initialization is finished", "warn");
          return;
        }
        this.toolboxInstance.toggle();
      },
      hasFocus: () => {
        var t2;
        return (t2 = this.toolboxInstance) == null ? void 0 : t2.hasFocus();
      }
    };
  }
  /**
   * Block actions appearance manipulations
   */
  get blockActions() {
    return {
      hide: () => {
        this.nodes.actions.classList.remove(this.CSS.actionsOpened);
      },
      show: () => {
        this.nodes.actions.classList.add(this.CSS.actionsOpened);
      }
    };
  }
  /**
   * Methods for working with Block Tunes toggler
   */
  get blockTunesToggler() {
    return {
      hide: () => this.nodes.settingsToggler.classList.add(this.CSS.settingsTogglerHidden),
      show: () => this.nodes.settingsToggler.classList.remove(this.CSS.settingsTogglerHidden)
    };
  }
  /**
   * Toggles read-only mode
   *
   * @param {boolean} readOnlyEnabled - read-only mode
   */
  toggleReadOnly(e2) {
    e2 ? (this.destroy(), this.Editor.BlockSettings.destroy(), this.disableModuleBindings()) : window.requestIdleCallback(() => {
      this.drawUI(), this.enableModuleBindings();
    }, { timeout: 2e3 });
  }
  /**
   * Move Toolbar to the passed (or current) Block
   *
   * @param block - block to move Toolbar near it
   */
  moveAndOpen(e2 = this.Editor.BlockManager.currentBlock) {
    if (this.toolboxInstance === null) {
      T$1("Can't open Toolbar since Editor initialization is not finished yet", "warn");
      return;
    }
    if (this.toolboxInstance.opened && this.toolboxInstance.close(), this.Editor.BlockSettings.opened && this.Editor.BlockSettings.close(), !e2)
      return;
    this.hoveredBlock = e2;
    const t2 = e2.holder, { isMobile: o3 } = this.Editor.UI, i2 = e2.pluginsContent, n3 = window.getComputedStyle(i2), r4 = parseInt(n3.paddingTop, 10), a3 = t2.offsetHeight;
    let l2;
    o3 ? l2 = t2.offsetTop + a3 : l2 = t2.offsetTop + r4, this.nodes.wrapper.style.top = `${Math.floor(l2)}px`, this.Editor.BlockManager.blocks.length === 1 && e2.isEmpty ? this.blockTunesToggler.hide() : this.blockTunesToggler.show(), this.open();
  }
  /**
   * Close the Toolbar
   */
  close() {
    var e2, t2;
    this.Editor.ReadOnly.isEnabled || ((e2 = this.nodes.wrapper) == null || e2.classList.remove(this.CSS.toolbarOpened), this.blockActions.hide(), (t2 = this.toolboxInstance) == null || t2.close(), this.Editor.BlockSettings.close(), this.reset());
  }
  /**
   * Reset the Toolbar position to prevent DOM height growth, for example after blocks deletion
   */
  reset() {
    this.nodes.wrapper.style.top = "unset";
  }
  /**
   * Open Toolbar with Plus Button and Actions
   *
   * @param {boolean} withBlockActions - by default, Toolbar opens with Block Actions.
   *                                     This flag allows to open Toolbar without Actions.
   */
  open(e2 = true) {
    this.nodes.wrapper.classList.add(this.CSS.toolbarOpened), e2 ? this.blockActions.show() : this.blockActions.hide();
  }
  /**
   * Draws Toolbar elements
   */
  async make() {
    this.nodes.wrapper = c$4.make("div", this.CSS.toolbar), ["content", "actions"].forEach((n3) => {
      this.nodes[n3] = c$4.make("div", this.CSS[n3]);
    }), c$4.append(this.nodes.wrapper, this.nodes.content), c$4.append(this.nodes.content, this.nodes.actions), this.nodes.plusButton = c$4.make("div", this.CSS.plusButton, {
      innerHTML: Fo
    }), c$4.append(this.nodes.actions, this.nodes.plusButton), this.readOnlyMutableListeners.on(this.nodes.plusButton, "click", () => {
      Re(true), this.plusButtonClicked();
    }, false);
    const e2 = c$4.make("div");
    e2.appendChild(document.createTextNode(z.ui(K.ui.toolbar.toolbox, "Add"))), e2.appendChild(c$4.make("div", this.CSS.plusButtonShortcut, {
      textContent: "/"
    })), ge(this.nodes.plusButton, e2, {
      hidingDelay: 400
    }), this.nodes.settingsToggler = c$4.make("span", this.CSS.settingsToggler, {
      innerHTML: Po
    }), c$4.append(this.nodes.actions, this.nodes.settingsToggler);
    const t2 = c$4.make("div"), o3 = c$4.text(z.ui(K.ui.blockTunes.toggler, "Click to tune")), i2 = await Go("Slash", "/");
    t2.appendChild(o3), t2.appendChild(c$4.make("div", this.CSS.plusButtonShortcut, {
      textContent: ye(`CMD + ${i2}`)
    })), ge(this.nodes.settingsToggler, t2, {
      hidingDelay: 400
    }), c$4.append(this.nodes.actions, this.makeToolbox()), c$4.append(this.nodes.actions, this.Editor.BlockSettings.getElement()), c$4.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);
  }
  /**
   * Creates the Toolbox instance and return it's rendered element
   */
  makeToolbox() {
    return this.toolboxInstance = new $e({
      api: this.Editor.API.methods,
      tools: this.Editor.Tools.blockTools,
      i18nLabels: {
        filter: z.ui(K.ui.popover, "Filter"),
        nothingFound: z.ui(K.ui.popover, "Nothing found")
      }
    }), this.toolboxInstance.on(ke.Opened, () => {
      this.Editor.UI.nodes.wrapper.classList.add(this.CSS.openedToolboxHolderModifier);
    }), this.toolboxInstance.on(ke.Closed, () => {
      this.Editor.UI.nodes.wrapper.classList.remove(this.CSS.openedToolboxHolderModifier);
    }), this.toolboxInstance.on(ke.BlockAdded, ({ block: e2 }) => {
      const { BlockManager: t2, Caret: o3 } = this.Editor, i2 = t2.getBlockById(e2.id);
      i2.inputs.length === 0 && (i2 === t2.lastBlock ? (t2.insertAtEnd(), o3.setToBlock(t2.lastBlock)) : o3.setToBlock(t2.nextBlock));
    }), this.toolboxInstance.make();
  }
  /**
   * Handler for Plus Button
   */
  plusButtonClicked() {
    var e2;
    this.Editor.BlockManager.currentBlock = this.hoveredBlock, (e2 = this.toolboxInstance) == null || e2.toggle();
  }
  /**
   * Enable bindings
   */
  enableModuleBindings() {
    this.readOnlyMutableListeners.on(this.nodes.settingsToggler, "mousedown", (e2) => {
      var t2;
      e2.stopPropagation(), this.settingsTogglerClicked(), (t2 = this.toolboxInstance) != null && t2.opened && this.toolboxInstance.close(), Re(true);
    }, true), te() || this.eventsDispatcher.on(yt, (e2) => {
      var t2;
      this.Editor.BlockSettings.opened || (t2 = this.toolboxInstance) != null && t2.opened || this.moveAndOpen(e2.block);
    });
  }
  /**
   * Disable bindings
   */
  disableModuleBindings() {
    this.readOnlyMutableListeners.clearAll();
  }
  /**
   * Clicks on the Block Settings toggler
   */
  settingsTogglerClicked() {
    this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.BlockSettings.open(this.hoveredBlock);
  }
  /**
   * Draws Toolbar UI
   *
   * Toolbar contains BlockSettings and Toolbox.
   * That's why at first we draw its components and then Toolbar itself
   *
   * Steps:
   *  - Make Toolbar dependent components like BlockSettings, Toolbox and so on
   *  - Make itself and append dependent nodes to itself
   *
   */
  drawUI() {
    this.Editor.BlockSettings.make(), this.make();
  }
  /**
   * Removes all created and saved HTMLElements
   * It is used in Read-Only mode
   */
  destroy() {
    this.removeAllNodes(), this.toolboxInstance && this.toolboxInstance.destroy();
  }
}
var Be = /* @__PURE__ */ ((s4) => (s4[s4.Block = 0] = "Block", s4[s4.Inline = 1] = "Inline", s4[s4.Tune = 2] = "Tune", s4))(Be || {}), ve = /* @__PURE__ */ ((s4) => (s4.Shortcut = "shortcut", s4.Toolbox = "toolbox", s4.EnabledInlineTools = "inlineToolbar", s4.EnabledBlockTunes = "tunes", s4.Config = "config", s4))(ve || {}), Et = /* @__PURE__ */ ((s4) => (s4.Shortcut = "shortcut", s4.SanitizeConfig = "sanitize", s4))(Et || {}), se = /* @__PURE__ */ ((s4) => (s4.IsEnabledLineBreaks = "enableLineBreaks", s4.Toolbox = "toolbox", s4.ConversionConfig = "conversionConfig", s4.IsReadOnlySupported = "isReadOnlySupported", s4.PasteConfig = "pasteConfig", s4))(se || {}), We = /* @__PURE__ */ ((s4) => (s4.IsInline = "isInline", s4.Title = "title", s4))(We || {}), Bt = /* @__PURE__ */ ((s4) => (s4.IsTune = "isTune", s4))(Bt || {});
class Ye {
  /**
   * @class
   * @param {ConstructorOptions} options - Constructor options
   */
  constructor({
    name: e2,
    constructable: t2,
    config: o3,
    api: i2,
    isDefault: n3,
    isInternal: r4 = false,
    defaultPlaceholder: a3
  }) {
    this.api = i2, this.name = e2, this.constructable = t2, this.config = o3, this.isDefault = n3, this.isInternal = r4, this.defaultPlaceholder = a3;
  }
  /**
   * Returns Tool user configuration
   */
  get settings() {
    const e2 = this.config.config || {};
    return this.isDefault && !("placeholder" in e2) && this.defaultPlaceholder && (e2.placeholder = this.defaultPlaceholder), e2;
  }
  /**
   * Calls Tool's reset method
   */
  reset() {
    if (M$2(this.constructable.reset))
      return this.constructable.reset();
  }
  /**
   * Calls Tool's prepare method
   */
  prepare() {
    if (M$2(this.constructable.prepare))
      return this.constructable.prepare({
        toolName: this.name,
        config: this.settings
      });
  }
  /**
   * Returns shortcut for Tool (internal or specified by user)
   */
  get shortcut() {
    const e2 = this.constructable.shortcut;
    return this.config.shortcut || e2;
  }
  /**
   * Returns Tool's sanitizer configuration
   */
  get sanitizeConfig() {
    return this.constructable.sanitize || {};
  }
  /**
   * Returns true if Tools is inline
   */
  isInline() {
    return this.type === 1;
  }
  /**
   * Returns true if Tools is block
   */
  isBlock() {
    return this.type === 0;
  }
  /**
   * Returns true if Tools is tune
   */
  isTune() {
    return this.type === 2;
  }
}
class Qo extends y$1 {
  /**
   * @class
   * @param moduleConfiguration - Module Configuration
   * @param moduleConfiguration.config - Editor's config
   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
   */
  constructor({ config: e2, eventsDispatcher: t2 }) {
    super({
      config: e2,
      eventsDispatcher: t2
    }), this.CSS = {
      inlineToolbar: "ce-inline-toolbar",
      inlineToolbarShowed: "ce-inline-toolbar--showed",
      inlineToolbarLeftOriented: "ce-inline-toolbar--left-oriented",
      inlineToolbarRightOriented: "ce-inline-toolbar--right-oriented",
      inlineToolbarShortcut: "ce-inline-toolbar__shortcut",
      buttonsWrapper: "ce-inline-toolbar__buttons",
      actionsWrapper: "ce-inline-toolbar__actions",
      inlineToolButton: "ce-inline-tool",
      inputField: "cdx-input",
      focusedButton: "ce-inline-tool--focused",
      conversionToggler: "ce-inline-toolbar__dropdown",
      conversionTogglerArrow: "ce-inline-toolbar__dropdown-arrow",
      conversionTogglerHidden: "ce-inline-toolbar__dropdown--hidden",
      conversionTogglerContent: "ce-inline-toolbar__dropdown-content",
      togglerAndButtonsWrapper: "ce-inline-toolbar__toggler-and-button-wrapper"
    }, this.opened = false, this.toolbarVerticalMargin = te() ? 20 : 6, this.buttonsList = null, this.width = 0, this.flipper = null;
  }
  /**
   * Toggles read-only mode
   *
   * @param {boolean} readOnlyEnabled - read-only mode
   */
  toggleReadOnly(e2) {
    e2 ? (this.destroy(), this.Editor.ConversionToolbar.destroy()) : window.requestIdleCallback(() => {
      this.make();
    }, { timeout: 2e3 });
  }
  /**
   *  Moving / appearance
   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   */
  /**
   * Shows Inline Toolbar if something is selected
   *
   * @param [needToClose] - pass true to close toolbar if it is not allowed.
   *                                  Avoid to use it just for closing IT, better call .close() clearly.
   * @param [needToShowConversionToolbar] - pass false to not to show Conversion Toolbar
   */
  async tryToShow(e2 = false, t2 = true) {
    e2 && this.close(), this.allowedToShow() && (await this.addToolsFiltered(t2), this.move(), this.open(t2), this.Editor.Toolbar.close());
  }
  /**
   * Hides Inline Toolbar
   */
  close() {
    this.opened && (this.Editor.ReadOnly.isEnabled || (this.nodes.wrapper.classList.remove(this.CSS.inlineToolbarShowed), Array.from(this.toolsInstances.entries()).forEach(([e2, t2]) => {
      const o3 = this.getToolShortcut(e2);
      o3 && ae.remove(this.Editor.UI.nodes.redactor, o3), M$2(t2.clear) && t2.clear();
    }), this.reset(), this.opened = false, this.flipper.deactivate(), this.Editor.ConversionToolbar.close()));
  }
  /**
   * Check if node is contained by Inline Toolbar
   *
   * @param {Node} node — node to check
   */
  containsNode(e2) {
    return this.nodes.wrapper === void 0 ? false : this.nodes.wrapper.contains(e2);
  }
  /**
   * Removes UI and its components
   */
  destroy() {
    this.flipper && (this.flipper.deactivate(), this.flipper = null), this.removeAllNodes();
  }
  /**
   * Making DOM
   */
  make() {
    this.nodes.wrapper = c$4.make("div", [
      this.CSS.inlineToolbar,
      ...this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []
    ]), this.nodes.togglerAndButtonsWrapper = c$4.make("div", this.CSS.togglerAndButtonsWrapper), this.nodes.buttons = c$4.make("div", this.CSS.buttonsWrapper), this.nodes.actions = c$4.make("div", this.CSS.actionsWrapper), this.listeners.on(this.nodes.wrapper, "mousedown", (e2) => {
      e2.target.closest(`.${this.CSS.actionsWrapper}`) || e2.preventDefault();
    }), c$4.append(this.nodes.wrapper, [this.nodes.togglerAndButtonsWrapper, this.nodes.actions]), c$4.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper), this.addConversionToggler(), c$4.append(this.nodes.togglerAndButtonsWrapper, this.nodes.buttons), this.prepareConversionToolbar(), window.requestAnimationFrame(() => {
      this.recalculateWidth();
    }), this.enableFlipper();
  }
  /**
   * Shows Inline Toolbar
   */
  open() {
    if (this.opened)
      return;
    this.nodes.wrapper.classList.add(this.CSS.inlineToolbarShowed), this.buttonsList = this.nodes.buttons.querySelectorAll(`.${this.CSS.inlineToolButton}`), this.opened = true;
    let e2 = Array.from(this.buttonsList);
    e2.unshift(this.nodes.conversionToggler), e2 = e2.filter((t2) => !t2.hidden), this.flipper.activate(e2);
  }
  /**
   * Move Toolbar to the selected text
   */
  move() {
    const e2 = b$1.rect, t2 = this.Editor.UI.nodes.wrapper.getBoundingClientRect(), o3 = {
      x: e2.x - t2.x,
      y: e2.y + e2.height - // + window.scrollY
      t2.top + this.toolbarVerticalMargin
    };
    o3.x + this.width + t2.x > this.Editor.UI.contentRect.right && (o3.x = this.Editor.UI.contentRect.right - this.width - t2.x), this.nodes.wrapper.style.left = Math.floor(o3.x) + "px", this.nodes.wrapper.style.top = Math.floor(o3.y) + "px";
  }
  /**
   * Clear orientation classes and reset position
   */
  reset() {
    this.nodes.wrapper.classList.remove(
      this.CSS.inlineToolbarLeftOriented,
      this.CSS.inlineToolbarRightOriented
    ), this.nodes.wrapper.style.left = "0", this.nodes.wrapper.style.top = "0";
  }
  /**
   * Need to show Inline Toolbar or not
   */
  allowedToShow() {
    const e2 = ["IMG", "INPUT"], t2 = b$1.get(), o3 = b$1.text;
    if (!t2 || !t2.anchorNode || t2.isCollapsed || o3.length < 1)
      return false;
    const i2 = c$4.isElement(t2.anchorNode) ? t2.anchorNode : t2.anchorNode.parentElement;
    if (t2 && e2.includes(i2.tagName) || i2.closest('[contenteditable="true"]') === null)
      return false;
    const r4 = this.Editor.BlockManager.getBlock(t2.anchorNode);
    return r4 ? r4.tool.inlineTools.size !== 0 : false;
  }
  /**
   * Recalculate inline toolbar width
   */
  recalculateWidth() {
    this.width = this.nodes.wrapper.offsetWidth;
  }
  /**
   * Create a toggler for Conversion Dropdown
   * and prepend it to the buttons list
   */
  addConversionToggler() {
    this.nodes.conversionToggler = c$4.make("div", this.CSS.conversionToggler), this.nodes.conversionTogglerContent = c$4.make("div", this.CSS.conversionTogglerContent);
    const e2 = c$4.make("div", this.CSS.conversionTogglerArrow, {
      innerHTML: kt
    });
    this.nodes.conversionToggler.appendChild(this.nodes.conversionTogglerContent), this.nodes.conversionToggler.appendChild(e2), this.nodes.togglerAndButtonsWrapper.appendChild(this.nodes.conversionToggler), this.listeners.on(this.nodes.conversionToggler, "click", () => {
      this.Editor.ConversionToolbar.toggle((t2) => {
        !t2 && this.opened ? this.flipper.activate() : this.opened && this.flipper.deactivate();
      });
    }), te() === false && ge(this.nodes.conversionToggler, z.ui(K.ui.inlineToolbar.converter, "Convert to"), {
      placement: "top",
      hidingDelay: 100
    });
  }
  /**
   * Changes Conversion Dropdown content for current block's Tool
   */
  async setConversionTogglerContent() {
    const { BlockManager: e2 } = this.Editor, { currentBlock: t2 } = e2, o3 = t2.name, i2 = t2.tool.conversionConfig, n3 = i2 && i2.export;
    this.nodes.conversionToggler.hidden = !n3, this.nodes.conversionToggler.classList.toggle(this.CSS.conversionTogglerHidden, !n3);
    const r4 = await t2.getActiveToolboxEntry() || {};
    this.nodes.conversionTogglerContent.innerHTML = r4.icon || r4.title || re(o3);
  }
  /**
   * Makes the Conversion Dropdown
   */
  prepareConversionToolbar() {
    const e2 = this.Editor.ConversionToolbar.make();
    c$4.append(this.nodes.wrapper, e2);
  }
  /**
   *  Working with Tools
   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   */
  /**
   * Append only allowed Tools
   *
   * @param {boolean} needToShowConversionToolbar - pass false to not to show Conversion Toolbar (e.g. for Footnotes-like tools)
   */
  async addToolsFiltered(e2 = true) {
    const t2 = b$1.get(), o3 = this.Editor.BlockManager.getBlock(t2.anchorNode);
    this.nodes.buttons.innerHTML = "", this.nodes.actions.innerHTML = "", this.toolsInstances = /* @__PURE__ */ new Map(), Array.from(o3.tool.inlineTools.values()).forEach((i2) => {
      this.addTool(i2);
    }), e2 && this.Editor.ConversionToolbar.hasTools() ? await this.setConversionTogglerContent() : this.nodes.conversionToggler.hidden = true, this.recalculateWidth();
  }
  /**
   * Add tool button and activate clicks
   *
   * @param {InlineTool} tool - InlineTool object
   */
  addTool(e2) {
    const t2 = e2.create(), o3 = t2.render();
    if (!o3) {
      T$1("Render method must return an instance of Node", "warn", e2.name);
      return;
    }
    if (o3.dataset.tool = e2.name, this.nodes.buttons.appendChild(o3), this.toolsInstances.set(e2.name, t2), M$2(t2.renderActions)) {
      const a3 = t2.renderActions();
      this.nodes.actions.appendChild(a3);
    }
    this.listeners.on(o3, "click", (a3) => {
      this.toolClicked(t2), a3.preventDefault();
    });
    const i2 = this.getToolShortcut(e2.name);
    if (i2)
      try {
        this.enableShortcuts(t2, i2);
      } catch {
      }
    const n3 = c$4.make("div"), r4 = z.t(
      K.toolNames,
      e2.title || re(e2.name)
    );
    n3.appendChild(c$4.text(r4)), i2 && n3.appendChild(c$4.make("div", this.CSS.inlineToolbarShortcut, {
      textContent: ye(i2)
    })), te() === false && ge(o3, n3, {
      placement: "top",
      hidingDelay: 100
    }), t2.checkState(b$1.get());
  }
  /**
   * Get shortcut name for tool
   *
   * @param toolName — Tool name
   */
  getToolShortcut(e2) {
    const { Tools: t2 } = this.Editor, o3 = t2.inlineTools.get(e2), i2 = t2.internal.inlineTools;
    return Array.from(i2.keys()).includes(e2) ? this.inlineTools[e2][Et.Shortcut] : o3.shortcut;
  }
  /**
   * Enable Tool shortcut with Editor Shortcuts Module
   *
   * @param {InlineTool} tool - Tool instance
   * @param {string} shortcut - shortcut according to the ShortcutData Module format
   */
  enableShortcuts(e2, t2) {
    ae.add({
      name: t2,
      handler: (o3) => {
        const { currentBlock: i2 } = this.Editor.BlockManager;
        i2 && i2.tool.enabledInlineTools && (o3.preventDefault(), this.toolClicked(e2));
      },
      on: this.Editor.UI.nodes.redactor
    });
  }
  /**
   * Inline Tool button clicks
   *
   * @param {InlineTool} tool - Tool's instance
   */
  toolClicked(e2) {
    const t2 = b$1.range;
    e2.surround(t2), this.checkToolsState(), e2.renderActions !== void 0 && this.flipper.deactivate();
  }
  /**
   * Check Tools` state by selection
   */
  checkToolsState() {
    this.toolsInstances.forEach((e2) => {
      e2.checkState(b$1.get());
    });
  }
  /**
   * Get inline tools tools
   * Tools that has isInline is true
   */
  get inlineTools() {
    const e2 = {};
    return Array.from(this.Editor.Tools.inlineTools.entries()).forEach(([t2, o3]) => {
      e2[t2] = o3.create();
    }), e2;
  }
  /**
   * Allow to leaf buttons by arrows / tab
   * Buttons will be filled on opening
   */
  enableFlipper() {
    this.flipper = new q({
      focusedItemClass: this.CSS.focusedButton,
      allowedKeys: [
        v$1.ENTER,
        v$1.TAB
      ]
    });
  }
}
class ei extends y$1 {
  /**
   * All keydowns on Block
   *
   * @param {KeyboardEvent} event - keydown
   */
  keydown(e2) {
    switch (this.beforeKeydownProcessing(e2), e2.keyCode) {
      case v$1.BACKSPACE:
        this.backspace(e2);
        break;
      case v$1.DELETE:
        this.delete(e2);
        break;
      case v$1.ENTER:
        this.enter(e2);
        break;
      case v$1.DOWN:
      case v$1.RIGHT:
        this.arrowRightAndDown(e2);
        break;
      case v$1.UP:
      case v$1.LEFT:
        this.arrowLeftAndUp(e2);
        break;
      case v$1.TAB:
        this.tabPressed(e2);
        break;
    }
    e2.key === "/" && !e2.ctrlKey && !e2.metaKey && this.slashPressed(), e2.code === "Slash" && (e2.ctrlKey || e2.metaKey) && (e2.preventDefault(), this.commandSlashPressed());
  }
  /**
   * Fires on keydown before event processing
   *
   * @param {KeyboardEvent} event - keydown
   */
  beforeKeydownProcessing(e2) {
    this.needToolbarClosing(e2) && lt(e2.keyCode) && (this.Editor.Toolbar.close(), this.Editor.ConversionToolbar.close(), e2.ctrlKey || e2.metaKey || e2.altKey || e2.shiftKey || this.Editor.BlockSelection.clearSelection(e2));
  }
  /**
   * Key up on Block:
   * - shows Inline Toolbar if something selected
   * - shows conversion toolbar with 85% of block selection
   *
   * @param {KeyboardEvent} event - keyup event
   */
  keyup(e2) {
    e2.shiftKey || this.Editor.UI.checkEmptiness();
  }
  /**
   * Add drop target styles
   *
   * @param {DragEvent} event - drag over event
   */
  dragOver(e2) {
    const t2 = this.Editor.BlockManager.getBlockByChildNode(e2.target);
    t2.dropTarget = true;
  }
  /**
   * Remove drop target style
   *
   * @param {DragEvent} event - drag leave event
   */
  dragLeave(e2) {
    const t2 = this.Editor.BlockManager.getBlockByChildNode(e2.target);
    t2.dropTarget = false;
  }
  /**
   * Copying selected blocks
   * Before putting to the clipboard we sanitize all blocks and then copy to the clipboard
   *
   * @param {ClipboardEvent} event - clipboard event
   */
  handleCommandC(e2) {
    const { BlockSelection: t2 } = this.Editor;
    t2.anyBlockSelected && t2.copySelectedBlocks(e2);
  }
  /**
   * Copy and Delete selected Blocks
   *
   * @param {ClipboardEvent} event - clipboard event
   */
  handleCommandX(e2) {
    const { BlockSelection: t2, BlockManager: o3, Caret: i2 } = this.Editor;
    t2.anyBlockSelected && t2.copySelectedBlocks(e2).then(() => {
      const n3 = o3.removeSelectedBlocks(), r4 = o3.insertDefaultBlockAtIndex(n3, true);
      i2.setToBlock(r4, i2.positions.START), t2.clearSelection(e2);
    });
  }
  /**
   * Tab pressed inside a Block.
   *
   * @param {KeyboardEvent} event - keydown
   */
  tabPressed(e2) {
    const { InlineToolbar: t2, ConversionToolbar: o3, Caret: i2 } = this.Editor;
    if (o3.opened || t2.opened)
      return;
    (e2.shiftKey ? i2.navigatePrevious(true) : i2.navigateNext(true)) && e2.preventDefault();
  }
  /**
   * '/' + 'command' keydown inside a Block
   */
  commandSlashPressed() {
    this.Editor.BlockSelection.selectedBlocks.length > 1 || this.activateBlockSettings();
  }
  /**
   * '/' keydown inside a Block
   */
  slashPressed() {
    this.Editor.BlockManager.currentBlock.isEmpty && this.activateToolbox();
  }
  /**
   * ENTER pressed on block
   *
   * @param {KeyboardEvent} event - keydown
   */
  enter(e2) {
    const { BlockManager: t2, UI: o3 } = this.Editor;
    if (t2.currentBlock.tool.isLineBreaksEnabled || o3.someToolbarOpened && o3.someFlipperButtonFocused || e2.shiftKey)
      return;
    let n3 = this.Editor.BlockManager.currentBlock;
    this.Editor.Caret.isAtStart && !this.Editor.BlockManager.currentBlock.hasMedia ? this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex) : this.Editor.Caret.isAtEnd ? n3 = this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex + 1) : n3 = this.Editor.BlockManager.split(), this.Editor.Caret.setToBlock(n3), this.Editor.Toolbar.moveAndOpen(n3), e2.preventDefault();
  }
  /**
   * Handle backspace keydown on Block
   *
   * @param {KeyboardEvent} event - keydown
   */
  backspace(e2) {
    const { BlockManager: t2, Caret: o3 } = this.Editor, { currentBlock: i2, previousBlock: n3 } = t2;
    if (!b$1.isCollapsed || !o3.isAtStart)
      return;
    if (e2.preventDefault(), this.Editor.Toolbar.close(), !(i2.currentInput === i2.firstInput)) {
      o3.navigatePrevious();
      return;
    }
    if (n3 === null)
      return;
    if (n3.isEmpty) {
      t2.removeBlock(n3);
      return;
    }
    if (i2.isEmpty) {
      t2.removeBlock(i2);
      const l2 = t2.currentBlock;
      o3.setToBlock(l2, o3.positions.END);
      return;
    }
    ot(i2, n3) ? this.mergeBlocks(n3, i2) : o3.setToBlock(n3, o3.positions.END);
  }
  /**
   * Handles delete keydown on Block
   * Removes char after the caret.
   * If caret is at the end of the block, merge next block with current
   *
   * @param {KeyboardEvent} event - keydown
   */
  delete(e2) {
    const { BlockManager: t2, Caret: o3 } = this.Editor, { currentBlock: i2, nextBlock: n3 } = t2;
    if (!b$1.isCollapsed || !o3.isAtEnd)
      return;
    if (e2.preventDefault(), this.Editor.Toolbar.close(), !(i2.currentInput === i2.lastInput)) {
      o3.navigateNext();
      return;
    }
    if (n3 === null)
      return;
    if (n3.isEmpty) {
      t2.removeBlock(n3);
      return;
    }
    if (i2.isEmpty) {
      t2.removeBlock(i2), o3.setToBlock(n3, o3.positions.START);
      return;
    }
    ot(i2, n3) ? this.mergeBlocks(i2, n3) : o3.setToBlock(n3, o3.positions.START);
  }
  /**
   * Merge passed Blocks
   *
   * @param targetBlock - to which Block we want to merge
   * @param blockToMerge - what Block we want to merge
   */
  mergeBlocks(e2, t2) {
    const { BlockManager: o3, Caret: i2, Toolbar: n3 } = this.Editor;
    i2.createShadow(e2.pluginsContent), o3.mergeBlocks(e2, t2).then(() => {
      window.requestAnimationFrame(() => {
        i2.restoreCaret(e2.pluginsContent), e2.pluginsContent.normalize(), n3.close();
      });
    });
  }
  /**
   * Handle right and down keyboard keys
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  arrowRightAndDown(e2) {
    const t2 = q.usedKeys.includes(e2.keyCode) && (!e2.shiftKey || e2.keyCode === v$1.TAB);
    if (this.Editor.UI.someToolbarOpened && t2)
      return;
    this.Editor.Toolbar.close();
    const o3 = this.Editor.Caret.isAtEnd || this.Editor.BlockSelection.anyBlockSelected;
    if (e2.shiftKey && e2.keyCode === v$1.DOWN && o3) {
      this.Editor.CrossBlockSelection.toggleBlockSelectedState();
      return;
    }
    if (e2.keyCode === v$1.DOWN || e2.keyCode === v$1.RIGHT && !this.isRtl ? this.Editor.Caret.navigateNext() : this.Editor.Caret.navigatePrevious()) {
      e2.preventDefault();
      return;
    }
    xe(() => {
      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();
    }, 20)(), this.Editor.BlockSelection.clearSelection(e2);
  }
  /**
   * Handle left and up keyboard keys
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  arrowLeftAndUp(e2) {
    if (this.Editor.UI.someToolbarOpened) {
      if (q.usedKeys.includes(e2.keyCode) && (!e2.shiftKey || e2.keyCode === v$1.TAB))
        return;
      this.Editor.UI.closeAllToolbars();
    }
    this.Editor.Toolbar.close();
    const t2 = this.Editor.Caret.isAtStart || this.Editor.BlockSelection.anyBlockSelected;
    if (e2.shiftKey && e2.keyCode === v$1.UP && t2) {
      this.Editor.CrossBlockSelection.toggleBlockSelectedState(false);
      return;
    }
    if (e2.keyCode === v$1.UP || e2.keyCode === v$1.LEFT && !this.isRtl ? this.Editor.Caret.navigatePrevious() : this.Editor.Caret.navigateNext()) {
      e2.preventDefault();
      return;
    }
    xe(() => {
      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();
    }, 20)(), this.Editor.BlockSelection.clearSelection(e2);
  }
  /**
   * Cases when we need to close Toolbar
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  needToolbarClosing(e2) {
    const t2 = e2.keyCode === v$1.ENTER && this.Editor.Toolbar.toolbox.opened, o3 = e2.keyCode === v$1.ENTER && this.Editor.BlockSettings.opened, i2 = e2.keyCode === v$1.ENTER && this.Editor.InlineToolbar.opened, n3 = e2.keyCode === v$1.ENTER && this.Editor.ConversionToolbar.opened, r4 = e2.keyCode === v$1.TAB;
    return !(e2.shiftKey || r4 || t2 || o3 || i2 || n3);
  }
  /**
   * If Toolbox is not open, then just open it and show plus button
   */
  activateToolbox() {
    this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open();
  }
  /**
   * Open Toolbar and show BlockSettings before flipping Tools
   */
  activateBlockSettings() {
    this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.opened || this.Editor.BlockSettings.open();
  }
}
class Se {
  /**
   * @class
   * @param {HTMLElement} workingArea — editor`s working node
   */
  constructor(e2) {
    this.blocks = [], this.workingArea = e2;
  }
  /**
   * Get length of Block instances array
   *
   * @returns {number}
   */
  get length() {
    return this.blocks.length;
  }
  /**
   * Get Block instances array
   *
   * @returns {Block[]}
   */
  get array() {
    return this.blocks;
  }
  /**
   * Get blocks html elements array
   *
   * @returns {HTMLElement[]}
   */
  get nodes() {
    return ct(this.workingArea.children);
  }
  /**
   * Proxy trap to implement array-like setter
   *
   * @example
   * blocks[0] = new Block(...)
   * @param {Blocks} instance — Blocks instance
   * @param {PropertyKey} property — block index or any Blocks class property key to set
   * @param {Block} value — value to set
   * @returns {boolean}
   */
  static set(e2, t2, o3) {
    return isNaN(Number(t2)) ? (Reflect.set(e2, t2, o3), true) : (e2.insert(+t2, o3), true);
  }
  /**
   * Proxy trap to implement array-like getter
   *
   * @param {Blocks} instance — Blocks instance
   * @param {PropertyKey} property — Blocks class property key
   * @returns {Block|*}
   */
  static get(e2, t2) {
    return isNaN(Number(t2)) ? Reflect.get(e2, t2) : e2.get(+t2);
  }
  /**
   * Push new Block to the blocks array and append it to working area
   *
   * @param {Block} block - Block to add
   */
  push(e2) {
    this.blocks.push(e2), this.insertToDOM(e2);
  }
  /**
   * Swaps blocks with indexes first and second
   *
   * @param {number} first - first block index
   * @param {number} second - second block index
   * @deprecated — use 'move' instead
   */
  swap(e2, t2) {
    const o3 = this.blocks[t2];
    c$4.swap(this.blocks[e2].holder, o3.holder), this.blocks[t2] = this.blocks[e2], this.blocks[e2] = o3;
  }
  /**
   * Move a block from one to another index
   *
   * @param {number} toIndex - new index of the block
   * @param {number} fromIndex - block to move
   */
  move(e2, t2) {
    const o3 = this.blocks.splice(t2, 1)[0], i2 = e2 - 1, n3 = Math.max(0, i2), r4 = this.blocks[n3];
    e2 > 0 ? this.insertToDOM(o3, "afterend", r4) : this.insertToDOM(o3, "beforebegin", r4), this.blocks.splice(e2, 0, o3);
    const a3 = this.composeBlockEvent("move", {
      fromIndex: t2,
      toIndex: e2
    });
    o3.call(X.MOVED, a3);
  }
  /**
   * Insert new Block at passed index
   *
   * @param {number} index — index to insert Block
   * @param {Block} block — Block to insert
   * @param {boolean} replace — it true, replace block on given index
   */
  insert(e2, t2, o3 = false) {
    if (!this.length) {
      this.push(t2);
      return;
    }
    e2 > this.length && (e2 = this.length), o3 && (this.blocks[e2].holder.remove(), this.blocks[e2].call(X.REMOVED));
    const i2 = o3 ? 1 : 0;
    if (this.blocks.splice(e2, i2, t2), e2 > 0) {
      const n3 = this.blocks[e2 - 1];
      this.insertToDOM(t2, "afterend", n3);
    } else {
      const n3 = this.blocks[e2 + 1];
      n3 ? this.insertToDOM(t2, "beforebegin", n3) : this.insertToDOM(t2);
    }
  }
  /**
   * Replaces block under passed index with passed block
   *
   * @param index - index of existed block
   * @param block - new block
   */
  replace(e2, t2) {
    if (this.blocks[e2] === void 0)
      throw Error("Incorrect index");
    this.blocks[e2].holder.replaceWith(t2.holder), this.blocks[e2] = t2;
  }
  /**
   * Inserts several blocks at once
   *
   * @param blocks - blocks to insert
   * @param index - index to insert blocks at
   */
  insertMany(e2, t2) {
    const o3 = new DocumentFragment();
    for (const i2 of e2)
      o3.appendChild(i2.holder);
    if (this.length > 0) {
      if (t2 > 0) {
        const i2 = Math.min(t2 - 1, this.length - 1);
        this.blocks[i2].holder.after(o3);
      } else
        t2 === 0 && this.workingArea.prepend(o3);
      this.blocks.splice(t2, 0, ...e2);
    } else
      this.blocks.push(...e2), this.workingArea.appendChild(o3);
    e2.forEach((i2) => i2.call(X.RENDERED));
  }
  /**
   * Remove block
   *
   * @param {number} index - index of Block to remove
   */
  remove(e2) {
    isNaN(e2) && (e2 = this.length - 1), this.blocks[e2].holder.remove(), this.blocks[e2].call(X.REMOVED), this.blocks.splice(e2, 1);
  }
  /**
   * Remove all blocks
   */
  removeAll() {
    this.workingArea.innerHTML = "", this.blocks.forEach((e2) => e2.call(X.REMOVED)), this.blocks.length = 0;
  }
  /**
   * Insert Block after passed target
   *
   * @todo decide if this method is necessary
   * @param {Block} targetBlock — target after which Block should be inserted
   * @param {Block} newBlock — Block to insert
   */
  insertAfter(e2, t2) {
    const o3 = this.blocks.indexOf(e2);
    this.insert(o3 + 1, t2);
  }
  /**
   * Get Block by index
   *
   * @param {number} index — Block index
   * @returns {Block}
   */
  get(e2) {
    return this.blocks[e2];
  }
  /**
   * Return index of passed Block
   *
   * @param {Block} block - Block to find
   * @returns {number}
   */
  indexOf(e2) {
    return this.blocks.indexOf(e2);
  }
  /**
   * Insert new Block into DOM
   *
   * @param {Block} block - Block to insert
   * @param {InsertPosition} position — insert position (if set, will use insertAdjacentElement)
   * @param {Block} target — Block related to position
   */
  insertToDOM(e2, t2, o3) {
    t2 ? o3.holder.insertAdjacentElement(t2, e2.holder) : this.workingArea.appendChild(e2.holder), e2.call(X.RENDERED);
  }
  /**
   * Composes Block event with passed type and details
   *
   * @param {string} type - event type
   * @param {object} detail - event detail
   */
  composeBlockEvent(e2, t2) {
    return new CustomEvent(e2, {
      detail: t2
    });
  }
}
const nt = "block-removed", st = "block-added", ti = "block-moved", rt = "block-changed";
class oi {
  constructor() {
    this.completed = Promise.resolve();
  }
  /**
   * Add new promise to queue
   *
   * @param operation - promise should be added to queue
   */
  add(e2) {
    return new Promise((t2, o3) => {
      this.completed = this.completed.then(e2).then(t2).catch(o3);
    });
  }
}
class ii extends y$1 {
  constructor() {
    super(...arguments), this._currentBlockIndex = -1, this._blocks = null;
  }
  /**
   * Returns current Block index
   *
   * @returns {number}
   */
  get currentBlockIndex() {
    return this._currentBlockIndex;
  }
  /**
   * Set current Block index and fire Block lifecycle callbacks
   *
   * @param {number} newIndex - index of Block to set as current
   */
  set currentBlockIndex(e2) {
    this._currentBlockIndex = e2;
  }
  /**
   * returns first Block
   *
   * @returns {Block}
   */
  get firstBlock() {
    return this._blocks[0];
  }
  /**
   * returns last Block
   *
   * @returns {Block}
   */
  get lastBlock() {
    return this._blocks[this._blocks.length - 1];
  }
  /**
   * Get current Block instance
   *
   * @returns {Block}
   */
  get currentBlock() {
    return this._blocks[this.currentBlockIndex];
  }
  /**
   * Set passed Block as a current
   *
   * @param block - block to set as a current
   */
  set currentBlock(e2) {
    this.currentBlockIndex = this.getBlockIndex(e2);
  }
  /**
   * Returns next Block instance
   *
   * @returns {Block|null}
   */
  get nextBlock() {
    return this.currentBlockIndex === this._blocks.length - 1 ? null : this._blocks[this.currentBlockIndex + 1];
  }
  /**
   * Return first Block with inputs after current Block
   *
   * @returns {Block | undefined}
   */
  get nextContentfulBlock() {
    return this.blocks.slice(this.currentBlockIndex + 1).find((t2) => !!t2.inputs.length);
  }
  /**
   * Return first Block with inputs before current Block
   *
   * @returns {Block | undefined}
   */
  get previousContentfulBlock() {
    return this.blocks.slice(0, this.currentBlockIndex).reverse().find((t2) => !!t2.inputs.length);
  }
  /**
   * Returns previous Block instance
   *
   * @returns {Block|null}
   */
  get previousBlock() {
    return this.currentBlockIndex === 0 ? null : this._blocks[this.currentBlockIndex - 1];
  }
  /**
   * Get array of Block instances
   *
   * @returns {Block[]} {@link Blocks#array}
   */
  get blocks() {
    return this._blocks.array;
  }
  /**
   * Check if each Block is empty
   *
   * @returns {boolean}
   */
  get isEditorEmpty() {
    return this.blocks.every((e2) => e2.isEmpty);
  }
  /**
   * Should be called after Editor.UI preparation
   * Define this._blocks property
   */
  prepare() {
    const e2 = new Se(this.Editor.UI.nodes.redactor);
    this._blocks = new Proxy(e2, {
      set: Se.set,
      get: Se.get
    }), this.listeners.on(
      document,
      "copy",
      (t2) => this.Editor.BlockEvents.handleCommandC(t2)
    );
  }
  /**
   * Toggle read-only state
   *
   * If readOnly is true:
   *  - Unbind event handlers from created Blocks
   *
   * if readOnly is false:
   *  - Bind event handlers to all existing Blocks
   *
   * @param {boolean} readOnlyEnabled - "read only" state
   */
  toggleReadOnly(e2) {
    e2 ? this.disableModuleBindings() : this.enableModuleBindings();
  }
  /**
   * Creates Block instance by tool name
   *
   * @param {object} options - block creation options
   * @param {string} options.tool - tools passed in editor config {@link EditorConfig#tools}
   * @param {string} [options.id] - unique id for this block
   * @param {BlockToolData} [options.data] - constructor params
   * @returns {Block}
   */
  composeBlock({
    tool: e2,
    data: t2 = {},
    id: o3 = void 0,
    tunes: i2 = {}
  }) {
    const n3 = this.Editor.ReadOnly.isEnabled, r4 = this.Editor.Tools.blockTools.get(e2), a3 = new R$3({
      id: o3,
      data: t2,
      tool: r4,
      api: this.Editor.API,
      readOnly: n3,
      tunesData: i2
    }, this.eventsDispatcher);
    return n3 || window.requestIdleCallback(() => {
      this.bindBlockEvents(a3);
    }, { timeout: 2e3 }), a3;
  }
  /**
   * Insert new block into _blocks
   *
   * @param {object} options - insert options
   * @param {string} [options.id] - block's unique id
   * @param {string} [options.tool] - plugin name, by default method inserts the default block type
   * @param {object} [options.data] - plugin data
   * @param {number} [options.index] - index where to insert new Block
   * @param {boolean} [options.needToFocus] - flag shows if needed to update current Block index
   * @param {boolean} [options.replace] - flag shows if block by passed index should be replaced with inserted one
   * @returns {Block}
   */
  insert({
    id: e2 = void 0,
    tool: t2 = this.config.defaultBlock,
    data: o3 = {},
    index: i2,
    needToFocus: n3 = true,
    replace: r4 = false,
    tunes: a3 = {}
  } = {}) {
    let l2 = i2;
    l2 === void 0 && (l2 = this.currentBlockIndex + (r4 ? 0 : 1));
    const d4 = this.composeBlock({
      id: e2,
      tool: t2,
      data: o3,
      tunes: a3
    });
    return r4 && this.blockDidMutated(nt, this.getBlockByIndex(l2), {
      index: l2
    }), this._blocks.insert(l2, d4, r4), this.blockDidMutated(st, d4, {
      index: l2
    }), n3 ? this.currentBlockIndex = l2 : l2 <= this.currentBlockIndex && this.currentBlockIndex++, d4;
  }
  /**
   * Inserts several blocks at once
   *
   * @param blocks - blocks to insert
   * @param index - index where to insert
   */
  insertMany(e2, t2 = 0) {
    this._blocks.insertMany(e2, t2);
  }
  /**
   * Update Block data.
   *
   * Currently we don't have an 'update' method in the Tools API, so we just create a new block with the same id and type
   * Should not trigger 'block-removed' or 'block-added' events
   *
   * @param block - block to update
   * @param data - new data
   */
  async update(e2, t2) {
    const o3 = await e2.data, i2 = this.composeBlock({
      id: e2.id,
      tool: e2.name,
      data: Object.assign({}, o3, t2),
      tunes: e2.tunes
    }), n3 = this.getBlockIndex(e2);
    return this._blocks.replace(n3, i2), this.blockDidMutated(rt, i2, {
      index: n3
    }), i2;
  }
  /**
   * Replace passed Block with the new one with specified Tool and data
   *
   * @param block - block to replace
   * @param newTool - new Tool name
   * @param data - new Tool data
   */
  replace(e2, t2, o3) {
    const i2 = this.getBlockIndex(e2);
    this.insert({
      tool: t2,
      data: o3,
      index: i2,
      replace: true
    });
  }
  /**
   * Insert pasted content. Call onPaste callback after insert.
   *
   * @param {string} toolName - name of Tool to insert
   * @param {PasteEvent} pasteEvent - pasted data
   * @param {boolean} replace - should replace current block
   */
  paste(e2, t2, o3 = false) {
    const i2 = this.insert({
      tool: e2,
      replace: o3
    });
    try {
      window.requestIdleCallback(() => {
        i2.call(X.ON_PASTE, t2);
      });
    } catch (n3) {
      T$1(`${e2}: onPaste callback call is failed`, "error", n3);
    }
    return i2;
  }
  /**
   * Insert new default block at passed index
   *
   * @param {number} index - index where Block should be inserted
   * @param {boolean} needToFocus - if true, updates current Block index
   *
   * TODO: Remove method and use insert() with index instead (?)
   * @returns {Block} inserted Block
   */
  insertDefaultBlockAtIndex(e2, t2 = false) {
    const o3 = this.composeBlock({ tool: this.config.defaultBlock });
    return this._blocks[e2] = o3, this.blockDidMutated(st, o3, {
      index: e2
    }), t2 ? this.currentBlockIndex = e2 : e2 <= this.currentBlockIndex && this.currentBlockIndex++, o3;
  }
  /**
   * Always inserts at the end
   *
   * @returns {Block}
   */
  insertAtEnd() {
    return this.currentBlockIndex = this.blocks.length - 1, this.insert();
  }
  /**
   * Merge two blocks
   *
   * @param {Block} targetBlock - previous block will be append to this block
   * @param {Block} blockToMerge - block that will be merged with target block
   * @returns {Promise} - the sequence that can be continued
   */
  async mergeBlocks(e2, t2) {
    const o3 = await t2.data;
    W(o3) || await e2.mergeWith(o3), this.removeBlock(t2), this.currentBlockIndex = this._blocks.indexOf(e2);
  }
  /**
   * Remove passed Block
   *
   * @param block - Block to remove
   * @param addLastBlock - if true, adds new default block at the end. @todo remove this logic and use event-bus instead
   */
  removeBlock(e2, t2 = true) {
    return new Promise((o3) => {
      const i2 = this._blocks.indexOf(e2);
      if (!this.validateIndex(i2))
        throw new Error("Can't find a Block to remove");
      e2.destroy(), this._blocks.remove(i2), this.blockDidMutated(nt, e2, {
        index: i2
      }), this.currentBlockIndex >= i2 && this.currentBlockIndex--, this.blocks.length ? i2 === 0 && (this.currentBlockIndex = 0) : (this.currentBlockIndex = -1, t2 && this.insert()), o3();
    });
  }
  /**
   * Remove only selected Blocks
   * and returns first Block index where started removing...
   *
   * @returns {number|undefined}
   */
  removeSelectedBlocks() {
    let e2;
    for (let t2 = this.blocks.length - 1; t2 >= 0; t2--)
      this.blocks[t2].selected && (this.removeBlock(this.blocks[t2]), e2 = t2);
    return e2;
  }
  /**
   * Attention!
   * After removing insert the new default typed Block and focus on it
   * Removes all blocks
   */
  removeAllBlocks() {
    for (let e2 = this.blocks.length - 1; e2 >= 0; e2--)
      this._blocks.remove(e2);
    this.currentBlockIndex = -1, this.insert(), this.currentBlock.firstInput.focus();
  }
  /**
   * Split current Block
   * 1. Extract content from Caret position to the Block`s end
   * 2. Insert a new Block below current one with extracted content
   *
   * @returns {Block}
   */
  split() {
    const e2 = this.Editor.Caret.extractFragmentFromCaretPosition(), t2 = c$4.make("div");
    t2.appendChild(e2);
    const o3 = {
      text: c$4.isEmpty(t2) ? "" : t2.innerHTML
    };
    return this.insert({ data: o3 });
  }
  /**
   * Returns Block by passed index
   *
   * @param {number} index - index to get. -1 to get last
   * @returns {Block}
   */
  getBlockByIndex(e2) {
    return e2 === -1 && (e2 = this._blocks.length - 1), this._blocks[e2];
  }
  /**
   * Returns an index for passed Block
   *
   * @param block - block to find index
   */
  getBlockIndex(e2) {
    return this._blocks.indexOf(e2);
  }
  /**
   * Returns the Block by passed id
   *
   * @param id - id of block to get
   * @returns {Block}
   */
  getBlockById(e2) {
    return this._blocks.array.find((t2) => t2.id === e2);
  }
  /**
   * Get Block instance by html element
   *
   * @param {Node} element - html element to get Block by
   */
  getBlock(e2) {
    c$4.isElement(e2) || (e2 = e2.parentNode);
    const t2 = this._blocks.nodes, o3 = e2.closest(`.${R$3.CSS.wrapper}`), i2 = t2.indexOf(o3);
    if (i2 >= 0)
      return this._blocks[i2];
  }
  /**
   * 1) Find first-level Block from passed child Node
   * 2) Mark it as current
   *
   * @param {Node} childNode - look ahead from this node.
   * @returns {Block | undefined} can return undefined in case when the passed child note is not a part of the current editor instance
   */
  setCurrentBlockByChildNode(e2) {
    c$4.isElement(e2) || (e2 = e2.parentNode);
    const t2 = e2.closest(`.${R$3.CSS.wrapper}`);
    if (!t2)
      return;
    const o3 = t2.closest(`.${this.Editor.UI.CSS.editorWrapper}`);
    if (o3 != null && o3.isEqualNode(this.Editor.UI.nodes.wrapper))
      return this.currentBlockIndex = this._blocks.nodes.indexOf(t2), this.currentBlock.updateCurrentInput(), this.currentBlock;
  }
  /**
   * Return block which contents passed node
   *
   * @param {Node} childNode - node to get Block by
   * @returns {Block}
   */
  getBlockByChildNode(e2) {
    if (!e2 || !(e2 instanceof Node))
      return;
    c$4.isElement(e2) || (e2 = e2.parentNode);
    const t2 = e2.closest(`.${R$3.CSS.wrapper}`);
    return this.blocks.find((o3) => o3.holder === t2);
  }
  /**
   * Swap Blocks Position
   *
   * @param {number} fromIndex - index of first block
   * @param {number} toIndex - index of second block
   * @deprecated — use 'move' instead
   */
  swap(e2, t2) {
    this._blocks.swap(e2, t2), this.currentBlockIndex = t2;
  }
  /**
   * Move a block to a new index
   *
   * @param {number} toIndex - index where to move Block
   * @param {number} fromIndex - index of Block to move
   */
  move(e2, t2 = this.currentBlockIndex) {
    if (isNaN(e2) || isNaN(t2)) {
      T$1("Warning during 'move' call: incorrect indices provided.", "warn");
      return;
    }
    if (!this.validateIndex(e2) || !this.validateIndex(t2)) {
      T$1("Warning during 'move' call: indices cannot be lower than 0 or greater than the amount of blocks.", "warn");
      return;
    }
    this._blocks.move(e2, t2), this.currentBlockIndex = e2, this.blockDidMutated(ti, this.currentBlock, {
      fromIndex: t2,
      toIndex: e2
    });
  }
  /**
   * Converts passed Block to the new Tool
   * Uses Conversion Config
   *
   * @param blockToConvert - Block that should be converted
   * @param targetToolName - name of the Tool to convert to
   * @param blockDataOverrides - optional new Block data overrides
   */
  async convert(e2, t2, o3) {
    if (!await e2.save())
      throw new Error("Could not convert Block. Failed to extract original Block data.");
    const n3 = this.Editor.Tools.blockTools.get(t2);
    if (!n3)
      throw new Error(`Could not convert Block. Tool «${t2}» not found.`);
    const r4 = await e2.exportDataAsString(), a3 = V(
      r4,
      n3.sanitizeConfig
    );
    let l2 = to(a3, n3.conversionConfig);
    o3 && (l2 = Object.assign(l2, o3)), this.replace(e2, n3.name, l2);
  }
  /**
   * Sets current Block Index -1 which means unknown
   * and clear highlights
   */
  dropPointer() {
    this.currentBlockIndex = -1;
  }
  /**
   * Clears Editor
   *
   * @param {boolean} needToAddDefaultBlock - 1) in internal calls (for example, in api.blocks.render)
   *                                             we don't need to add an empty default block
   *                                        2) in api.blocks.clear we should add empty block
   */
  async clear(e2 = false) {
    const t2 = new oi();
    this.blocks.forEach((o3) => {
      t2.add(async () => {
        await this.removeBlock(o3, false);
      });
    }), await t2.completed, this.dropPointer(), e2 && this.insert(), this.Editor.UI.checkEmptiness();
  }
  /**
   * Cleans up all the block tools' resources
   * This is called when editor is destroyed
   */
  async destroy() {
    await Promise.all(this.blocks.map((e2) => e2.destroy()));
  }
  /**
   * Bind Block events
   *
   * @param {Block} block - Block to which event should be bound
   */
  bindBlockEvents(e2) {
    const { BlockEvents: t2 } = this.Editor;
    this.readOnlyMutableListeners.on(e2.holder, "keydown", (o3) => {
      t2.keydown(o3);
    }), this.readOnlyMutableListeners.on(e2.holder, "keyup", (o3) => {
      t2.keyup(o3);
    }), this.readOnlyMutableListeners.on(e2.holder, "dragover", (o3) => {
      t2.dragOver(o3);
    }), this.readOnlyMutableListeners.on(e2.holder, "dragleave", (o3) => {
      t2.dragLeave(o3);
    }), e2.on("didMutated", (o3) => this.blockDidMutated(rt, o3, {
      index: this.getBlockIndex(o3)
    }));
  }
  /**
   * Disable mutable handlers and bindings
   */
  disableModuleBindings() {
    this.readOnlyMutableListeners.clearAll();
  }
  /**
   * Enables all module handlers and bindings for all Blocks
   */
  enableModuleBindings() {
    this.readOnlyMutableListeners.on(
      document,
      "cut",
      (e2) => this.Editor.BlockEvents.handleCommandX(e2)
    ), this.blocks.forEach((e2) => {
      this.bindBlockEvents(e2);
    });
  }
  /**
   * Validates that the given index is not lower than 0 or higher than the amount of blocks
   *
   * @param {number} index - index of blocks array to validate
   * @returns {boolean}
   */
  validateIndex(e2) {
    return !(e2 < 0 || e2 >= this._blocks.length);
  }
  /**
   * Block mutation callback
   *
   * @param mutationType - what happened with block
   * @param block - mutated block
   * @param detailData - additional data to pass with change event
   */
  blockDidMutated(e2, t2, o3) {
    const i2 = new CustomEvent(e2, {
      detail: {
        target: new ee(t2),
        ...o3
      }
    });
    return this.eventsDispatcher.emit(pt, {
      event: i2
    }), t2;
  }
}
class ni extends y$1 {
  constructor() {
    super(...arguments), this.anyBlockSelectedCache = null, this.needToSelectAll = false, this.nativeInputSelected = false, this.readyToBlockSelection = false;
  }
  /**
   * Sanitizer Config
   *
   * @returns {SanitizerConfig}
   */
  get sanitizerConfig() {
    return {
      p: {},
      h1: {},
      h2: {},
      h3: {},
      h4: {},
      h5: {},
      h6: {},
      ol: {},
      ul: {},
      li: {},
      br: true,
      img: {
        src: true,
        width: true,
        height: true
      },
      a: {
        href: true
      },
      b: {},
      i: {},
      u: {}
    };
  }
  /**
   * Flag that identifies all Blocks selection
   *
   * @returns {boolean}
   */
  get allBlocksSelected() {
    const { BlockManager: e2 } = this.Editor;
    return e2.blocks.every((t2) => t2.selected === true);
  }
  /**
   * Set selected all blocks
   *
   * @param {boolean} state - state to set
   */
  set allBlocksSelected(e2) {
    const { BlockManager: t2 } = this.Editor;
    t2.blocks.forEach((o3) => {
      o3.selected = e2;
    }), this.clearCache();
  }
  /**
   * Flag that identifies any Block selection
   *
   * @returns {boolean}
   */
  get anyBlockSelected() {
    const { BlockManager: e2 } = this.Editor;
    return this.anyBlockSelectedCache === null && (this.anyBlockSelectedCache = e2.blocks.some((t2) => t2.selected === true)), this.anyBlockSelectedCache;
  }
  /**
   * Return selected Blocks array
   *
   * @returns {Block[]}
   */
  get selectedBlocks() {
    return this.Editor.BlockManager.blocks.filter((e2) => e2.selected);
  }
  /**
   * Module Preparation
   * Registers Shortcuts CMD+A and CMD+C
   * to select all and copy them
   */
  prepare() {
    this.selection = new b$1(), ae.add({
      name: "CMD+A",
      handler: (e2) => {
        const { BlockManager: t2, ReadOnly: o3 } = this.Editor;
        if (o3.isEnabled) {
          e2.preventDefault(), this.selectAllBlocks();
          return;
        }
        t2.currentBlock && this.handleCommandA(e2);
      },
      on: this.Editor.UI.nodes.redactor
    });
  }
  /**
   * Toggle read-only state
   *
   *  - Remove all ranges
   *  - Unselect all Blocks
   */
  toggleReadOnly() {
    b$1.get().removeAllRanges(), this.allBlocksSelected = false;
  }
  /**
   * Remove selection of Block
   *
   * @param {number?} index - Block index according to the BlockManager's indexes
   */
  unSelectBlockByIndex(e2) {
    const { BlockManager: t2 } = this.Editor;
    let o3;
    isNaN(e2) ? o3 = t2.currentBlock : o3 = t2.getBlockByIndex(e2), o3.selected = false, this.clearCache();
  }
  /**
   * Clear selection from Blocks
   *
   * @param {Event} reason - event caused clear of selection
   * @param {boolean} restoreSelection - if true, restore saved selection
   */
  clearSelection(e2, t2 = false) {
    const { BlockManager: o3, Caret: i2, RectangleSelection: n3 } = this.Editor;
    this.needToSelectAll = false, this.nativeInputSelected = false, this.readyToBlockSelection = false;
    const r4 = e2 && e2 instanceof KeyboardEvent, a3 = r4 && lt(e2.keyCode);
    if (this.anyBlockSelected && r4 && a3 && !b$1.isSelectionExists) {
      const l2 = o3.removeSelectedBlocks();
      o3.insertDefaultBlockAtIndex(l2, true), i2.setToBlock(o3.currentBlock), xe(() => {
        const d4 = e2.key;
        i2.insertContentAtCaretPosition(d4.length > 1 ? "" : d4);
      }, 20)();
    }
    if (this.Editor.CrossBlockSelection.clear(e2), !this.anyBlockSelected || n3.isRectActivated()) {
      this.Editor.RectangleSelection.clearSelection();
      return;
    }
    t2 && this.selection.restore(), this.allBlocksSelected = false;
  }
  /**
   * Reduce each Block and copy its content
   *
   * @param {ClipboardEvent} e - copy/cut event
   * @returns {Promise<void>}
   */
  copySelectedBlocks(e2) {
    e2.preventDefault();
    const t2 = c$4.make("div");
    this.selectedBlocks.forEach((n3) => {
      const r4 = V(n3.holder.innerHTML, this.sanitizerConfig), a3 = c$4.make("p");
      a3.innerHTML = r4, t2.appendChild(a3);
    });
    const o3 = Array.from(t2.childNodes).map((n3) => n3.textContent).join(`

`), i2 = t2.innerHTML;
    return e2.clipboardData.setData("text/plain", o3), e2.clipboardData.setData("text/html", i2), Promise.all(this.selectedBlocks.map((n3) => n3.save())).then((n3) => {
      try {
        e2.clipboardData.setData(this.Editor.Paste.MIME_TYPE, JSON.stringify(n3));
      } catch {
      }
    });
  }
  /**
   * Select Block by its index
   *
   * @param {number?} index - Block index according to the BlockManager's indexes
   */
  selectBlockByIndex(e2) {
    const { BlockManager: t2 } = this.Editor, o3 = t2.getBlockByIndex(e2);
    o3 !== void 0 && this.selectBlock(o3);
  }
  /**
   * Select passed Block
   *
   * @param {Block} block - Block to select
   */
  selectBlock(e2) {
    this.selection.save(), b$1.get().removeAllRanges(), e2.selected = true, this.clearCache(), this.Editor.InlineToolbar.close();
  }
  /**
   * Remove selection from passed Block
   *
   * @param {Block} block - Block to unselect
   */
  unselectBlock(e2) {
    e2.selected = false, this.clearCache();
  }
  /**
   * Clear anyBlockSelected cache
   */
  clearCache() {
    this.anyBlockSelectedCache = null;
  }
  /**
   * Module destruction
   * De-registers Shortcut CMD+A
   */
  destroy() {
    ae.remove(this.Editor.UI.nodes.redactor, "CMD+A");
  }
  /**
   * First CMD+A selects all input content by native behaviour,
   * next CMD+A keypress selects all blocks
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  handleCommandA(e2) {
    if (this.Editor.RectangleSelection.clearSelection(), c$4.isNativeInput(e2.target) && !this.readyToBlockSelection) {
      this.readyToBlockSelection = true;
      return;
    }
    const t2 = this.Editor.BlockManager.getBlock(e2.target), o3 = t2.inputs;
    if (o3.length > 1 && !this.readyToBlockSelection) {
      this.readyToBlockSelection = true;
      return;
    }
    if (o3.length === 1 && !this.needToSelectAll) {
      this.needToSelectAll = true;
      return;
    }
    this.needToSelectAll ? (e2.preventDefault(), this.selectAllBlocks(), this.needToSelectAll = false, this.readyToBlockSelection = false, this.Editor.ConversionToolbar.close()) : this.readyToBlockSelection && (e2.preventDefault(), this.selectBlock(t2), this.needToSelectAll = true);
  }
  /**
   * Select All Blocks
   * Each Block has selected setter that makes Block copyable
   */
  selectAllBlocks() {
    this.selection.save(), b$1.get().removeAllRanges(), this.allBlocksSelected = true, this.Editor.InlineToolbar.close();
  }
}
class we extends y$1 {
  /**
   * Allowed caret positions in input
   *
   * @static
   * @returns {{START: string, END: string, DEFAULT: string}}
   */
  get positions() {
    return {
      START: "start",
      END: "end",
      DEFAULT: "default"
    };
  }
  /**
   * Elements styles that can be useful for Caret Module
   */
  static get CSS() {
    return {
      shadowCaret: "cdx-shadow-caret"
    };
  }
  /**
   * Get's deepest first node and checks if offset is zero
   *
   * @returns {boolean}
   */
  get isAtStart() {
    const { currentBlock: e2 } = this.Editor.BlockManager;
    if (!e2.focusable)
      return true;
    const t2 = b$1.get(), o3 = c$4.getDeepestNode(e2.currentInput);
    let i2 = t2.focusNode;
    if (c$4.isNativeInput(o3))
      return o3.selectionEnd === 0;
    if (!t2.anchorNode)
      return false;
    let n3 = i2.textContent.search(/\S/);
    n3 === -1 && (n3 = 0);
    let r4 = t2.focusOffset;
    return i2.nodeType !== Node.TEXT_NODE && i2.childNodes.length && (i2.childNodes[r4] ? (i2 = i2.childNodes[r4], r4 = 0) : (i2 = i2.childNodes[r4 - 1], r4 = i2.textContent.length)), (c$4.isLineBreakTag(o3) || c$4.isEmpty(o3)) && this.getHigherLevelSiblings(i2, "left").every((d4) => {
      const u3 = c$4.isLineBreakTag(d4), h2 = d4.children.length === 1 && c$4.isLineBreakTag(d4.children[0]), f2 = u3 || h2;
      return c$4.isEmpty(d4) && !f2;
    }) && r4 === n3 ? true : o3 === null || i2 === o3 && r4 <= n3;
  }
  /**
   * Get's deepest last node and checks if offset is last node text length
   *
   * @returns {boolean}
   */
  get isAtEnd() {
    const { currentBlock: e2 } = this.Editor.BlockManager;
    if (!e2.focusable)
      return true;
    const t2 = b$1.get();
    let o3 = t2.focusNode;
    const i2 = c$4.getDeepestNode(e2.currentInput, true);
    if (c$4.isNativeInput(i2))
      return i2.selectionEnd === i2.value.length;
    if (!t2.focusNode)
      return false;
    let n3 = t2.focusOffset;
    if (o3.nodeType !== Node.TEXT_NODE && o3.childNodes.length && (o3.childNodes[n3 - 1] ? (o3 = o3.childNodes[n3 - 1], n3 = o3.textContent.length) : (o3 = o3.childNodes[0], n3 = 0)), c$4.isLineBreakTag(i2) || c$4.isEmpty(i2)) {
      const a3 = this.getHigherLevelSiblings(o3, "right");
      if (a3.every((d4, u3) => u3 === a3.length - 1 && c$4.isLineBreakTag(d4) || c$4.isEmpty(d4) && !c$4.isLineBreakTag(d4)) && n3 === o3.textContent.length)
        return true;
    }
    const r4 = i2.textContent.replace(/\s+$/, "");
    return o3 === i2 && n3 >= r4.length;
  }
  /**
   * Method gets Block instance and puts caret to the text node with offset
   * There two ways that method applies caret position:
   *   - first found text node: sets at the beginning, but you can pass an offset
   *   - last found text node: sets at the end of the node. Also, you can customize the behaviour
   *
   * @param {Block} block - Block class
   * @param {string} position - position where to set caret.
   *                            If default - leave default behaviour and apply offset if it's passed
   * @param {number} offset - caret offset regarding to the text node
   */
  setToBlock(e2, t2 = this.positions.DEFAULT, o3 = 0) {
    var d4;
    const { BlockManager: i2, BlockSelection: n3 } = this.Editor;
    if (n3.clearSelection(), !e2.focusable) {
      (d4 = window.getSelection()) == null || d4.removeAllRanges(), n3.selectBlock(e2), i2.currentBlock = e2;
      return;
    }
    let r4;
    switch (t2) {
      case this.positions.START:
        r4 = e2.firstInput;
        break;
      case this.positions.END:
        r4 = e2.lastInput;
        break;
      default:
        r4 = e2.currentInput;
    }
    if (!r4)
      return;
    const a3 = c$4.getDeepestNode(r4, t2 === this.positions.END), l2 = c$4.getContentLength(a3);
    switch (true) {
      case t2 === this.positions.START:
        o3 = 0;
        break;
      case t2 === this.positions.END:
      case o3 > l2:
        o3 = l2;
        break;
    }
    this.set(a3, o3), i2.setCurrentBlockByChildNode(e2.holder), i2.currentBlock.currentInput = r4;
  }
  /**
   * Set caret to the current input of current Block.
   *
   * @param {HTMLElement} input - input where caret should be set
   * @param {string} position - position of the caret.
   *                            If default - leave default behaviour and apply offset if it's passed
   * @param {number} offset - caret offset regarding to the text node
   */
  setToInput(e2, t2 = this.positions.DEFAULT, o3 = 0) {
    const { currentBlock: i2 } = this.Editor.BlockManager, n3 = c$4.getDeepestNode(e2);
    switch (t2) {
      case this.positions.START:
        this.set(n3, 0);
        break;
      case this.positions.END:
        this.set(n3, c$4.getContentLength(n3));
        break;
      default:
        o3 && this.set(n3, o3);
    }
    i2.currentInput = e2;
  }
  /**
   * Creates Document Range and sets caret to the element with offset
   *
   * @param {HTMLElement} element - target node.
   * @param {number} offset - offset
   */
  set(e2, t2 = 0) {
    const { top: i2, bottom: n3 } = b$1.setCursor(e2, t2), { innerHeight: r4 } = window;
    i2 < 0 ? window.scrollBy(0, i2 - 30) : n3 > r4 && window.scrollBy(0, n3 - r4 + 30);
  }
  /**
   * Set Caret to the last Block
   * If last block is not empty, append another empty block
   */
  setToTheLastBlock() {
    const e2 = this.Editor.BlockManager.lastBlock;
    if (e2)
      if (e2.tool.isDefault && e2.isEmpty)
        this.setToBlock(e2);
      else {
        const t2 = this.Editor.BlockManager.insertAtEnd();
        this.setToBlock(t2);
      }
  }
  /**
   * Extract content fragment of current Block from Caret position to the end of the Block
   */
  extractFragmentFromCaretPosition() {
    const e2 = b$1.get();
    if (e2.rangeCount) {
      const t2 = e2.getRangeAt(0), o3 = this.Editor.BlockManager.currentBlock.currentInput;
      if (t2.deleteContents(), o3)
        if (c$4.isNativeInput(o3)) {
          const i2 = o3, n3 = document.createDocumentFragment(), r4 = i2.value.substring(0, i2.selectionStart), a3 = i2.value.substring(i2.selectionStart);
          return n3.textContent = a3, i2.value = r4, n3;
        } else {
          const i2 = t2.cloneRange();
          return i2.selectNodeContents(o3), i2.setStart(t2.endContainer, t2.endOffset), i2.extractContents();
        }
    }
  }
  /**
   * Set's caret to the next Block or Tool`s input
   * Before moving caret, we should check if caret position is at the end of Plugins node
   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection
   *
   * @param {boolean} force - pass true to skip check for caret position
   */
  navigateNext(e2 = false) {
    const { BlockManager: t2 } = this.Editor, { currentBlock: o3, nextBlock: i2 } = t2, { nextInput: n3 } = o3, r4 = this.isAtEnd;
    let a3 = i2;
    const l2 = e2 || r4;
    if (n3 && l2)
      return this.setToInput(n3, this.positions.START), true;
    if (a3 === null) {
      if (o3.tool.isDefault || !l2)
        return false;
      a3 = t2.insertAtEnd();
    }
    return l2 ? (this.setToBlock(a3, this.positions.START), true) : false;
  }
  /**
   * Set's caret to the previous Tool`s input or Block
   * Before moving caret, we should check if caret position is start of the Plugins node
   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection
   *
   * @param {boolean} force - pass true to skip check for caret position
   */
  navigatePrevious(e2 = false) {
    const { currentBlock: t2, previousBlock: o3 } = this.Editor.BlockManager;
    if (!t2)
      return false;
    const { previousInput: i2 } = t2, n3 = e2 || this.isAtStart;
    return i2 && n3 ? (this.setToInput(i2, this.positions.END), true) : o3 !== null && n3 ? (this.setToBlock(o3, this.positions.END), true) : false;
  }
  /**
   * Inserts shadow element after passed element where caret can be placed
   *
   * @param {Element} element - element after which shadow caret should be inserted
   */
  createShadow(e2) {
    const t2 = document.createElement("span");
    t2.classList.add(we.CSS.shadowCaret), e2.insertAdjacentElement("beforeend", t2);
  }
  /**
   * Restores caret position
   *
   * @param {HTMLElement} element - element where caret should be restored
   */
  restoreCaret(e2) {
    const t2 = e2.querySelector(`.${we.CSS.shadowCaret}`);
    if (!t2)
      return;
    new b$1().expandToTag(t2);
    const i2 = document.createRange();
    i2.selectNode(t2), i2.extractContents();
  }
  /**
   * Inserts passed content at caret position
   *
   * @param {string} content - content to insert
   */
  insertContentAtCaretPosition(e2) {
    const t2 = document.createDocumentFragment(), o3 = document.createElement("div"), i2 = b$1.get(), n3 = b$1.range;
    o3.innerHTML = e2, Array.from(o3.childNodes).forEach((d4) => t2.appendChild(d4)), t2.childNodes.length === 0 && t2.appendChild(new Text());
    const r4 = t2.lastChild;
    n3.deleteContents(), n3.insertNode(t2);
    const a3 = document.createRange(), l2 = r4.nodeType === Node.TEXT_NODE ? r4 : r4.firstChild;
    l2 !== null && l2.textContent !== null && a3.setStart(l2, l2.textContent.length), i2.removeAllRanges(), i2.addRange(a3);
  }
  /**
   * Get all first-level (first child of [contenteditable]) siblings from passed node
   * Then you can check it for emptiness
   *
   * @example
   * <div contenteditable>
   * <p></p>                            |
   * <p></p>                            | left first-level siblings
   * <p></p>                            |
   * <blockquote><a><b>adaddad</b><a><blockquote>       <-- passed node for example <b>
   * <p></p>                            |
   * <p></p>                            | right first-level siblings
   * <p></p>                            |
   * </div>
   * @param {HTMLElement} from - element from which siblings should be searched
   * @param {'left' | 'right'} direction - direction of search
   * @returns {HTMLElement[]}
   */
  getHigherLevelSiblings(e2, t2) {
    let o3 = e2;
    const i2 = [];
    for (; o3.parentNode && o3.parentNode.contentEditable !== "true"; )
      o3 = o3.parentNode;
    const n3 = t2 === "left" ? "previousSibling" : "nextSibling";
    for (; o3[n3]; )
      o3 = o3[n3], i2.push(o3);
    return i2;
  }
}
class si extends y$1 {
  constructor() {
    super(...arguments), this.onMouseUp = () => {
      this.listeners.off(document, "mouseover", this.onMouseOver), this.listeners.off(document, "mouseup", this.onMouseUp);
    }, this.onMouseOver = (e2) => {
      const { BlockManager: t2, BlockSelection: o3 } = this.Editor;
      if (e2.relatedTarget === null && e2.target === null)
        return;
      const i2 = t2.getBlockByChildNode(e2.relatedTarget) || this.lastSelectedBlock, n3 = t2.getBlockByChildNode(e2.target);
      if (!(!i2 || !n3) && n3 !== i2) {
        if (i2 === this.firstSelectedBlock) {
          b$1.get().removeAllRanges(), i2.selected = true, n3.selected = true, o3.clearCache();
          return;
        }
        if (n3 === this.firstSelectedBlock) {
          i2.selected = false, n3.selected = false, o3.clearCache();
          return;
        }
        this.Editor.InlineToolbar.close(), this.toggleBlocksSelectedState(i2, n3), this.lastSelectedBlock = n3;
      }
    };
  }
  /**
   * Module preparation
   *
   * @returns {Promise}
   */
  async prepare() {
    this.listeners.on(document, "mousedown", (e2) => {
      this.enableCrossBlockSelection(e2);
    });
  }
  /**
   * Sets up listeners
   *
   * @param {MouseEvent} event - mouse down event
   */
  watchSelection(e2) {
    if (e2.button !== Pt.LEFT)
      return;
    const { BlockManager: t2 } = this.Editor;
    this.firstSelectedBlock = t2.getBlock(e2.target), this.lastSelectedBlock = this.firstSelectedBlock, this.listeners.on(document, "mouseover", this.onMouseOver), this.listeners.on(document, "mouseup", this.onMouseUp);
  }
  /**
   * return boolean is cross block selection started
   */
  get isCrossBlockSelectionStarted() {
    return !!this.firstSelectedBlock && !!this.lastSelectedBlock;
  }
  /**
   * Change selection state of the next Block
   * Used for CBS via Shift + arrow keys
   *
   * @param {boolean} next - if true, toggle next block. Previous otherwise
   */
  toggleBlockSelectedState(e2 = true) {
    const { BlockManager: t2, BlockSelection: o3 } = this.Editor;
    this.lastSelectedBlock || (this.lastSelectedBlock = this.firstSelectedBlock = t2.currentBlock), this.firstSelectedBlock === this.lastSelectedBlock && (this.firstSelectedBlock.selected = true, o3.clearCache(), b$1.get().removeAllRanges());
    const i2 = t2.blocks.indexOf(this.lastSelectedBlock) + (e2 ? 1 : -1), n3 = t2.blocks[i2];
    n3 && (this.lastSelectedBlock.selected !== n3.selected ? (n3.selected = true, o3.clearCache()) : (this.lastSelectedBlock.selected = false, o3.clearCache()), this.lastSelectedBlock = n3, this.Editor.InlineToolbar.close(), n3.holder.scrollIntoView({
      block: "nearest"
    }));
  }
  /**
   * Clear saved state
   *
   * @param {Event} reason - event caused clear of selection
   */
  clear(e2) {
    const { BlockManager: t2, BlockSelection: o3, Caret: i2 } = this.Editor, n3 = t2.blocks.indexOf(this.firstSelectedBlock), r4 = t2.blocks.indexOf(this.lastSelectedBlock);
    if (o3.anyBlockSelected && n3 > -1 && r4 > -1 && e2 && e2 instanceof KeyboardEvent)
      switch (e2.keyCode) {
        case v$1.DOWN:
        case v$1.RIGHT:
          i2.setToBlock(t2.blocks[Math.max(n3, r4)], i2.positions.END);
          break;
        case v$1.UP:
        case v$1.LEFT:
          i2.setToBlock(t2.blocks[Math.min(n3, r4)], i2.positions.START);
          break;
        default:
          i2.setToBlock(t2.blocks[Math.max(n3, r4)], i2.positions.END);
      }
    this.firstSelectedBlock = this.lastSelectedBlock = null;
  }
  /**
   * Enables Cross Block Selection
   *
   * @param {MouseEvent} event - mouse down event
   */
  enableCrossBlockSelection(e2) {
    const { UI: t2 } = this.Editor;
    b$1.isCollapsed || this.Editor.BlockSelection.clearSelection(e2), t2.nodes.redactor.contains(e2.target) ? this.watchSelection(e2) : this.Editor.BlockSelection.clearSelection(e2);
  }
  /**
   * Change blocks selection state between passed two blocks.
   *
   * @param {Block} firstBlock - first block in range
   * @param {Block} lastBlock - last block in range
   */
  toggleBlocksSelectedState(e2, t2) {
    const { BlockManager: o3, BlockSelection: i2 } = this.Editor, n3 = o3.blocks.indexOf(e2), r4 = o3.blocks.indexOf(t2), a3 = e2.selected !== t2.selected;
    for (let l2 = Math.min(n3, r4); l2 <= Math.max(n3, r4); l2++) {
      const d4 = o3.blocks[l2];
      d4 !== this.firstSelectedBlock && d4 !== (a3 ? e2 : t2) && (o3.blocks[l2].selected = !o3.blocks[l2].selected, i2.clearCache());
    }
  }
}
class ri extends y$1 {
  constructor() {
    super(...arguments), this.isStartedAtEditor = false;
  }
  /**
   * Toggle read-only state
   *
   * if state is true:
   *  - disable all drag-n-drop event handlers
   *
   * if state is false:
   *  - restore drag-n-drop event handlers
   *
   * @param {boolean} readOnlyEnabled - "read only" state
   */
  toggleReadOnly(e2) {
    e2 ? this.disableModuleBindings() : this.enableModuleBindings();
  }
  /**
   * Add drag events listeners to editor zone
   */
  enableModuleBindings() {
    const { UI: e2 } = this.Editor;
    this.readOnlyMutableListeners.on(e2.nodes.holder, "drop", async (t2) => {
      await this.processDrop(t2);
    }, true), this.readOnlyMutableListeners.on(e2.nodes.holder, "dragstart", () => {
      this.processDragStart();
    }), this.readOnlyMutableListeners.on(e2.nodes.holder, "dragover", (t2) => {
      this.processDragOver(t2);
    }, true);
  }
  /**
   * Unbind drag-n-drop event handlers
   */
  disableModuleBindings() {
    this.readOnlyMutableListeners.clearAll();
  }
  /**
   * Handle drop event
   *
   * @param {DragEvent} dropEvent - drop event
   */
  async processDrop(e2) {
    const {
      BlockManager: t2,
      Caret: o3,
      Paste: i2
    } = this.Editor;
    e2.preventDefault(), t2.blocks.forEach((r4) => {
      r4.dropTarget = false;
    }), b$1.isAtEditor && !b$1.isCollapsed && this.isStartedAtEditor && document.execCommand("delete"), this.isStartedAtEditor = false;
    const n3 = t2.setCurrentBlockByChildNode(e2.target);
    if (n3)
      this.Editor.Caret.setToBlock(n3, o3.positions.END);
    else {
      const r4 = t2.setCurrentBlockByChildNode(t2.lastBlock.holder);
      this.Editor.Caret.setToBlock(r4, o3.positions.END);
    }
    await i2.processDataTransfer(e2.dataTransfer, true);
  }
  /**
   * Handle drag start event
   */
  processDragStart() {
    b$1.isAtEditor && !b$1.isCollapsed && (this.isStartedAtEditor = true), this.Editor.InlineToolbar.close();
  }
  /**
   * @param {DragEvent} dragEvent - drag event
   */
  processDragOver(e2) {
    e2.preventDefault();
  }
}
class ai extends y$1 {
  /**
   * Prepare the module
   *
   * @param options - options used by the modification observer module
   * @param options.config - Editor configuration object
   * @param options.eventsDispatcher - common Editor event bus
   */
  constructor({ config: e2, eventsDispatcher: t2 }) {
    super({
      config: e2,
      eventsDispatcher: t2
    }), this.disabled = false, this.batchingTimeout = null, this.batchingOnChangeQueue = /* @__PURE__ */ new Map(), this.batchTime = 400, this.mutationObserver = new MutationObserver((o3) => {
      this.redactorChanged(o3);
    }), this.eventsDispatcher.on(pt, (o3) => {
      this.particularBlockChanged(o3.event);
    }), this.eventsDispatcher.on(ft, () => {
      this.disable();
    }), this.eventsDispatcher.on(gt, () => {
      this.enable();
    });
  }
  /**
   * Enables onChange event
   */
  enable() {
    this.mutationObserver.observe(
      this.Editor.UI.nodes.redactor,
      {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: true
      }
    ), this.disabled = false;
  }
  /**
   * Disables onChange event
   */
  disable() {
    this.mutationObserver.disconnect(), this.disabled = true;
  }
  /**
   * Call onChange event passed to Editor.js configuration
   *
   * @param event - some of our custom change events
   */
  particularBlockChanged(e2) {
    this.disabled || !M$2(this.config.onChange) || (this.batchingOnChangeQueue.set(`block:${e2.detail.target.id}:event:${e2.type}`, e2), this.batchingTimeout && clearTimeout(this.batchingTimeout), this.batchingTimeout = setTimeout(() => {
      let t2;
      this.batchingOnChangeQueue.size === 1 ? t2 = this.batchingOnChangeQueue.values().next().value : t2 = Array.from(this.batchingOnChangeQueue.values()), this.config.onChange && this.config.onChange(this.Editor.API.methods, t2), this.batchingOnChangeQueue.clear();
    }, this.batchTime));
  }
  /**
   * Fired on every blocks wrapper dom change
   *
   * @param mutations - mutations happened
   */
  redactorChanged(e2) {
    this.eventsDispatcher.emit(Ae, {
      mutations: e2
    });
  }
}
const Ct = class extends y$1 {
  constructor() {
    super(...arguments), this.MIME_TYPE = "application/x-editor-js", this.toolsTags = {}, this.tagsByTool = {}, this.toolsPatterns = [], this.toolsFiles = {}, this.exceptionList = [], this.processTool = (s4) => {
      try {
        const e2 = s4.create({}, {}, false);
        if (s4.pasteConfig === false) {
          this.exceptionList.push(s4.name);
          return;
        }
        if (!M$2(e2.onPaste))
          return;
        this.getTagsConfig(s4), this.getFilesConfig(s4), this.getPatternsConfig(s4);
      } catch (e2) {
        T$1(
          `Paste handling for «${s4.name}» Tool hasn't been set up because of the error`,
          "warn",
          e2
        );
      }
    }, this.handlePasteEvent = async (s4) => {
      const { BlockManager: e2, Toolbar: t2 } = this.Editor, o3 = e2.setCurrentBlockByChildNode(s4.target);
      !o3 || this.isNativeBehaviour(s4.target) && !s4.clipboardData.types.includes("Files") || o3 && this.exceptionList.includes(o3.name) || (s4.preventDefault(), this.processDataTransfer(s4.clipboardData), t2.close());
    };
  }
  /**
   * Set onPaste callback and collect tools` paste configurations
   */
  async prepare() {
    this.processTools();
  }
  /**
   * Set read-only state
   *
   * @param {boolean} readOnlyEnabled - read only flag value
   */
  toggleReadOnly(s4) {
    s4 ? this.unsetCallback() : this.setCallback();
  }
  /**
   * Handle pasted or dropped data transfer object
   *
   * @param {DataTransfer} dataTransfer - pasted or dropped data transfer object
   * @param {boolean} isDragNDrop - true if data transfer comes from drag'n'drop events
   */
  async processDataTransfer(s4, e2 = false) {
    const { Tools: t2 } = this.Editor, o3 = s4.types;
    if ((o3.includes ? o3.includes("Files") : o3.contains("Files")) && !W(this.toolsFiles)) {
      await this.processFiles(s4.files);
      return;
    }
    const n3 = s4.getData(this.MIME_TYPE), r4 = s4.getData("text/plain");
    let a3 = s4.getData("text/html");
    if (n3)
      try {
        this.insertEditorJSData(JSON.parse(n3));
        return;
      } catch {
      }
    e2 && r4.trim() && a3.trim() && (a3 = "<p>" + (a3.trim() ? a3 : r4) + "</p>");
    const l2 = Object.keys(this.toolsTags).reduce((h2, f2) => (h2[f2.toLowerCase()] = this.toolsTags[f2].sanitizationConfig ?? {}, h2), {}), d4 = Object.assign({}, l2, t2.getAllInlineToolsSanitizeConfig(), { br: {} }), u3 = V(a3, d4);
    !u3.trim() || u3.trim() === r4 || !c$4.isHTMLString(u3) ? await this.processText(r4) : await this.processText(u3, true);
  }
  /**
   * Process pasted text and divide them into Blocks
   *
   * @param {string} data - text to process. Can be HTML or plain.
   * @param {boolean} isHTML - if passed string is HTML, this parameter should be true
   */
  async processText(s4, e2 = false) {
    const { Caret: t2, BlockManager: o3 } = this.Editor, i2 = e2 ? this.processHTML(s4) : this.processPlain(s4);
    if (!i2.length)
      return;
    if (i2.length === 1) {
      i2[0].isBlock ? this.processSingleBlock(i2.pop()) : this.processInlinePaste(i2.pop());
      return;
    }
    const r4 = o3.currentBlock && o3.currentBlock.tool.isDefault && o3.currentBlock.isEmpty;
    i2.map(
      async (a3, l2) => this.insertBlock(a3, l2 === 0 && r4)
    ), o3.currentBlock && t2.setToBlock(o3.currentBlock, t2.positions.END);
  }
  /**
   * Set onPaste callback handler
   */
  setCallback() {
    this.listeners.on(this.Editor.UI.nodes.holder, "paste", this.handlePasteEvent);
  }
  /**
   * Unset onPaste callback handler
   */
  unsetCallback() {
    this.listeners.off(this.Editor.UI.nodes.holder, "paste", this.handlePasteEvent);
  }
  /**
   * Get and process tool`s paste configs
   */
  processTools() {
    const s4 = this.Editor.Tools.blockTools;
    Array.from(s4.values()).forEach(this.processTool);
  }
  /**
   * Get tags name list from either tag name or sanitization config.
   *
   * @param {string | object} tagOrSanitizeConfig - tag name or sanitize config object.
   * @returns {string[]} array of tags.
   */
  collectTagNames(s4) {
    return G(s4) ? [s4] : D$1(s4) ? Object.keys(s4) : [];
  }
  /**
   * Get tags to substitute by Tool
   *
   * @param tool - BlockTool object
   */
  getTagsConfig(s4) {
    if (s4.pasteConfig === false)
      return;
    const e2 = s4.pasteConfig.tags || [], t2 = [];
    e2.forEach((o3) => {
      const i2 = this.collectTagNames(o3);
      t2.push(...i2), i2.forEach((n3) => {
        if (Object.prototype.hasOwnProperty.call(this.toolsTags, n3)) {
          T$1(
            `Paste handler for «${s4.name}» Tool on «${n3}» tag is skipped because it is already used by «${this.toolsTags[n3].tool.name}» Tool.`,
            "warn"
          );
          return;
        }
        const r4 = D$1(o3) ? o3[n3] : null;
        this.toolsTags[n3.toUpperCase()] = {
          tool: s4,
          sanitizationConfig: r4
        };
      });
    }), this.tagsByTool[s4.name] = t2.map((o3) => o3.toUpperCase());
  }
  /**
   * Get files` types and extensions to substitute by Tool
   *
   * @param tool - BlockTool object
   */
  getFilesConfig(s4) {
    if (s4.pasteConfig === false)
      return;
    const { files: e2 = {} } = s4.pasteConfig;
    let { extensions: t2, mimeTypes: o3 } = e2;
    !t2 && !o3 || (t2 && !Array.isArray(t2) && (T$1(`«extensions» property of the onDrop config for «${s4.name}» Tool should be an array`), t2 = []), o3 && !Array.isArray(o3) && (T$1(`«mimeTypes» property of the onDrop config for «${s4.name}» Tool should be an array`), o3 = []), o3 && (o3 = o3.filter((i2) => jt(i2) ? true : (T$1(`MIME type value «${i2}» for the «${s4.name}» Tool is not a valid MIME type`, "warn"), false))), this.toolsFiles[s4.name] = {
      extensions: t2 || [],
      mimeTypes: o3 || []
    });
  }
  /**
   * Get RegExp patterns to substitute by Tool
   *
   * @param tool - BlockTool object
   */
  getPatternsConfig(s4) {
    s4.pasteConfig === false || !s4.pasteConfig.patterns || W(s4.pasteConfig.patterns) || Object.entries(s4.pasteConfig.patterns).forEach(([e2, t2]) => {
      t2 instanceof RegExp || T$1(
        `Pattern ${t2} for «${s4.name}» Tool is skipped because it should be a Regexp instance.`,
        "warn"
      ), this.toolsPatterns.push({
        key: e2,
        pattern: t2,
        tool: s4
      });
    });
  }
  /**
   * Check if browser behavior suits better
   *
   * @param {EventTarget} element - element where content has been pasted
   * @returns {boolean}
   */
  isNativeBehaviour(s4) {
    return c$4.isNativeInput(s4);
  }
  /**
   * Get files from data transfer object and insert related Tools
   *
   * @param {FileList} items - pasted or dropped items
   */
  async processFiles(s4) {
    const { BlockManager: e2 } = this.Editor;
    let t2;
    t2 = await Promise.all(
      Array.from(s4).map((n3) => this.processFile(n3))
    ), t2 = t2.filter((n3) => !!n3);
    const i2 = e2.currentBlock.tool.isDefault && e2.currentBlock.isEmpty;
    t2.forEach(
      (n3, r4) => {
        e2.paste(n3.type, n3.event, r4 === 0 && i2);
      }
    );
  }
  /**
   * Get information about file and find Tool to handle it
   *
   * @param {File} file - file to process
   */
  async processFile(s4) {
    const e2 = Ut(s4), t2 = Object.entries(this.toolsFiles).find(([n3, { mimeTypes: r4, extensions: a3 }]) => {
      const [l2, d4] = s4.type.split("/"), u3 = a3.find((f2) => f2.toLowerCase() === e2.toLowerCase()), h2 = r4.find((f2) => {
        const [x2, p2] = f2.split("/");
        return x2 === l2 && (p2 === d4 || p2 === "*");
      });
      return !!u3 || !!h2;
    });
    if (!t2)
      return;
    const [o3] = t2;
    return {
      event: this.composePasteEvent("file", {
        file: s4
      }),
      type: o3
    };
  }
  /**
   * Split HTML string to blocks and return it as array of Block data
   *
   * @param {string} innerHTML - html string to process
   * @returns {PasteData[]}
   */
  processHTML(s4) {
    const { Tools: e2 } = this.Editor, t2 = c$4.make("DIV");
    return t2.innerHTML = s4, this.getNodes(t2).map((i2) => {
      let n3, r4 = e2.defaultTool, a3 = false;
      switch (i2.nodeType) {
        case Node.DOCUMENT_FRAGMENT_NODE:
          n3 = c$4.make("div"), n3.appendChild(i2);
          break;
        case Node.ELEMENT_NODE:
          n3 = i2, a3 = true, this.toolsTags[n3.tagName] && (r4 = this.toolsTags[n3.tagName].tool);
          break;
      }
      const { tags: l2 } = r4.pasteConfig || { tags: [] }, d4 = l2.reduce((f2, x2) => (this.collectTagNames(x2).forEach((m3) => {
        const L2 = D$1(x2) ? x2[m3] : null;
        f2[m3.toLowerCase()] = L2 || {};
      }), f2), {}), u3 = Object.assign({}, d4, r4.baseSanitizeConfig);
      if (n3.tagName.toLowerCase() === "table") {
        const f2 = V(n3.outerHTML, u3);
        n3 = c$4.make("div", void 0, {
          innerHTML: f2
        }).firstChild;
      } else
        n3.innerHTML = V(n3.innerHTML, u3);
      const h2 = this.composePasteEvent("tag", {
        data: n3
      });
      return {
        content: n3,
        isBlock: a3,
        tool: r4.name,
        event: h2
      };
    }).filter((i2) => {
      const n3 = c$4.isEmpty(i2.content), r4 = c$4.isSingleTag(i2.content);
      return !n3 || r4;
    });
  }
  /**
   * Split plain text by new line symbols and return it as array of Block data
   *
   * @param {string} plain - string to process
   * @returns {PasteData[]}
   */
  processPlain(s4) {
    const { defaultBlock: e2 } = this.config;
    if (!s4)
      return [];
    const t2 = e2;
    return s4.split(/\r?\n/).filter((o3) => o3.trim()).map((o3) => {
      const i2 = c$4.make("div");
      i2.textContent = o3;
      const n3 = this.composePasteEvent("tag", {
        data: i2
      });
      return {
        content: i2,
        tool: t2,
        isBlock: false,
        event: n3
      };
    });
  }
  /**
   * Process paste of single Block tool content
   *
   * @param {PasteData} dataToInsert - data of Block to insert
   */
  async processSingleBlock(s4) {
    const { Caret: e2, BlockManager: t2 } = this.Editor, { currentBlock: o3 } = t2;
    if (!o3 || s4.tool !== o3.name || !c$4.containsOnlyInlineElements(s4.content.innerHTML)) {
      this.insertBlock(s4, (o3 == null ? void 0 : o3.tool.isDefault) && o3.isEmpty);
      return;
    }
    e2.insertContentAtCaretPosition(s4.content.innerHTML);
  }
  /**
   * Process paste to single Block:
   * 1. Find patterns` matches
   * 2. Insert new block if it is not the same type as current one
   * 3. Just insert text if there is no substitutions
   *
   * @param {PasteData} dataToInsert - data of Block to insert
   */
  async processInlinePaste(s4) {
    const { BlockManager: e2, Caret: t2 } = this.Editor, { content: o3 } = s4;
    if (e2.currentBlock && e2.currentBlock.tool.isDefault && o3.textContent.length < Ct.PATTERN_PROCESSING_MAX_LENGTH) {
      const n3 = await this.processPattern(o3.textContent);
      if (n3) {
        const r4 = e2.currentBlock && e2.currentBlock.tool.isDefault && e2.currentBlock.isEmpty, a3 = e2.paste(n3.tool, n3.event, r4);
        t2.setToBlock(a3, t2.positions.END);
        return;
      }
    }
    if (e2.currentBlock && e2.currentBlock.currentInput) {
      const n3 = e2.currentBlock.tool.baseSanitizeConfig;
      document.execCommand(
        "insertHTML",
        false,
        V(o3.innerHTML, n3)
      );
    } else
      this.insertBlock(s4);
  }
  /**
   * Get patterns` matches
   *
   * @param {string} text - text to process
   * @returns {Promise<{event: PasteEvent, tool: string}>}
   */
  async processPattern(s4) {
    const e2 = this.toolsPatterns.find((o3) => {
      const i2 = o3.pattern.exec(s4);
      return i2 ? s4 === i2.shift() : false;
    });
    return e2 ? {
      event: this.composePasteEvent("pattern", {
        key: e2.key,
        data: s4
      }),
      tool: e2.tool.name
    } : void 0;
  }
  /**
   * Insert pasted Block content to Editor
   *
   * @param {PasteData} data - data to insert
   * @param {boolean} canReplaceCurrentBlock - if true and is current Block is empty, will replace current Block
   * @returns {void}
   */
  insertBlock(s4, e2 = false) {
    const { BlockManager: t2, Caret: o3 } = this.Editor, { currentBlock: i2 } = t2;
    let n3;
    if (e2 && i2 && i2.isEmpty) {
      n3 = t2.paste(s4.tool, s4.event, true), o3.setToBlock(n3, o3.positions.END);
      return;
    }
    n3 = t2.paste(s4.tool, s4.event), o3.setToBlock(n3, o3.positions.END);
  }
  /**
   * Insert data passed as application/x-editor-js JSON
   *
   * @param {Array} blocks — Blocks' data to insert
   * @returns {void}
   */
  insertEditorJSData(s4) {
    const { BlockManager: e2, Caret: t2, Tools: o3 } = this.Editor;
    bt(
      s4,
      (n3) => o3.blockTools.get(n3).sanitizeConfig
    ).forEach(({ tool: n3, data: r4 }, a3) => {
      let l2 = false;
      a3 === 0 && (l2 = e2.currentBlock && e2.currentBlock.tool.isDefault && e2.currentBlock.isEmpty);
      const d4 = e2.insert({
        tool: n3,
        data: r4,
        replace: l2
      });
      t2.setToBlock(d4, t2.positions.END);
    });
  }
  /**
   * Fetch nodes from Element node
   *
   * @param {Node} node - current node
   * @param {Node[]} nodes - processed nodes
   * @param {Node} destNode - destination node
   */
  processElementNode(s4, e2, t2) {
    const o3 = Object.keys(this.toolsTags), i2 = s4, { tool: n3 } = this.toolsTags[i2.tagName] || {}, r4 = this.tagsByTool[n3 == null ? void 0 : n3.name] || [], a3 = o3.includes(i2.tagName), l2 = c$4.blockElements.includes(i2.tagName.toLowerCase()), d4 = Array.from(i2.children).some(
      ({ tagName: h2 }) => o3.includes(h2) && !r4.includes(h2)
    ), u3 = Array.from(i2.children).some(
      ({ tagName: h2 }) => c$4.blockElements.includes(h2.toLowerCase())
    );
    if (!l2 && !a3 && !d4)
      return t2.appendChild(i2), [...e2, t2];
    if (a3 && !d4 || l2 && !u3 && !d4)
      return [...e2, t2, i2];
  }
  /**
   * Recursively divide HTML string to two types of nodes:
   * 1. Block element
   * 2. Document Fragments contained text and markup tags like a, b, i etc.
   *
   * @param {Node} wrapper - wrapper of paster HTML content
   * @returns {Node[]}
   */
  getNodes(s4) {
    const e2 = Array.from(s4.childNodes);
    let t2;
    const o3 = (i2, n3) => {
      if (c$4.isEmpty(n3) && !c$4.isSingleTag(n3))
        return i2;
      const r4 = i2[i2.length - 1];
      let a3 = new DocumentFragment();
      switch (r4 && c$4.isFragment(r4) && (a3 = i2.pop()), n3.nodeType) {
        case Node.ELEMENT_NODE:
          if (t2 = this.processElementNode(n3, i2, a3), t2)
            return t2;
          break;
        case Node.TEXT_NODE:
          return a3.appendChild(n3), [...i2, a3];
        default:
          return [...i2, a3];
      }
      return [...i2, ...Array.from(n3.childNodes).reduce(o3, [])];
    };
    return e2.reduce(o3, []);
  }
  /**
   * Compose paste event with passed type and detail
   *
   * @param {string} type - event type
   * @param {PasteEventDetail} detail - event detail
   */
  composePasteEvent(s4, e2) {
    return new CustomEvent(s4, {
      detail: e2
    });
  }
};
let Tt = Ct;
Tt.PATTERN_PROCESSING_MAX_LENGTH = 450;
class li extends y$1 {
  constructor() {
    super(...arguments), this.toolsDontSupportReadOnly = [], this.readOnlyEnabled = false;
  }
  /**
   * Returns state of read only mode
   */
  get isEnabled() {
    return this.readOnlyEnabled;
  }
  /**
   * Set initial state
   */
  async prepare() {
    const { Tools: e2 } = this.Editor, { blockTools: t2 } = e2, o3 = [];
    Array.from(t2.entries()).forEach(([i2, n3]) => {
      n3.isReadOnlySupported || o3.push(i2);
    }), this.toolsDontSupportReadOnly = o3, this.config.readOnly && o3.length > 0 && this.throwCriticalError(), this.toggle(this.config.readOnly);
  }
  /**
   * Set read-only mode or toggle current state
   * Call all Modules `toggleReadOnly` method and re-render Editor
   *
   * @param {boolean} state - (optional) read-only state or toggle
   */
  async toggle(e2 = !this.readOnlyEnabled) {
    e2 && this.toolsDontSupportReadOnly.length > 0 && this.throwCriticalError();
    const t2 = this.readOnlyEnabled;
    this.readOnlyEnabled = e2;
    for (const i2 in this.Editor)
      this.Editor[i2].toggleReadOnly && this.Editor[i2].toggleReadOnly(e2);
    if (t2 === e2)
      return this.readOnlyEnabled;
    const o3 = await this.Editor.Saver.save();
    return await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(o3.blocks), this.readOnlyEnabled;
  }
  /**
   * Throws an error about tools which don't support read-only mode
   */
  throwCriticalError() {
    throw new ut(
      `To enable read-only mode all connected tools should support it. Tools ${this.toolsDontSupportReadOnly.join(", ")} don't support read-only mode.`
    );
  }
}
class fe extends y$1 {
  constructor() {
    super(...arguments), this.isRectSelectionActivated = false, this.SCROLL_SPEED = 3, this.HEIGHT_OF_SCROLL_ZONE = 40, this.BOTTOM_SCROLL_ZONE = 1, this.TOP_SCROLL_ZONE = 2, this.MAIN_MOUSE_BUTTON = 0, this.mousedown = false, this.isScrolling = false, this.inScrollZone = null, this.startX = 0, this.startY = 0, this.mouseX = 0, this.mouseY = 0, this.stackOfSelected = [], this.listenerIds = [];
  }
  /**
   * CSS classes for the Block
   *
   * @returns {{wrapper: string, content: string}}
   */
  static get CSS() {
    return {
      overlay: "codex-editor-overlay",
      overlayContainer: "codex-editor-overlay__container",
      rect: "codex-editor-overlay__rectangle",
      topScrollZone: "codex-editor-overlay__scroll-zone--top",
      bottomScrollZone: "codex-editor-overlay__scroll-zone--bottom"
    };
  }
  /**
   * Module Preparation
   * Creating rect and hang handlers
   */
  prepare() {
    this.enableModuleBindings();
  }
  /**
   * Init rect params
   *
   * @param {number} pageX - X coord of mouse
   * @param {number} pageY - Y coord of mouse
   */
  startSelection(e2, t2) {
    const o3 = document.elementFromPoint(e2 - window.pageXOffset, t2 - window.pageYOffset);
    o3.closest(`.${this.Editor.Toolbar.CSS.toolbar}`) || (this.Editor.BlockSelection.allBlocksSelected = false, this.clearSelection(), this.stackOfSelected = []);
    const n3 = [
      `.${R$3.CSS.content}`,
      `.${this.Editor.Toolbar.CSS.toolbar}`,
      `.${this.Editor.InlineToolbar.CSS.inlineToolbar}`
    ], r4 = o3.closest("." + this.Editor.UI.CSS.editorWrapper), a3 = n3.some((l2) => !!o3.closest(l2));
    !r4 || a3 || (this.mousedown = true, this.startX = e2, this.startY = t2);
  }
  /**
   * Clear all params to end selection
   */
  endSelection() {
    this.mousedown = false, this.startX = 0, this.startY = 0, this.overlayRectangle.style.display = "none";
  }
  /**
   * is RectSelection Activated
   */
  isRectActivated() {
    return this.isRectSelectionActivated;
  }
  /**
   * Mark that selection is end
   */
  clearSelection() {
    this.isRectSelectionActivated = false;
  }
  /**
   * Sets Module necessary event handlers
   */
  enableModuleBindings() {
    const { container: e2 } = this.genHTML();
    this.listeners.on(e2, "mousedown", (t2) => {
      this.processMouseDown(t2);
    }, false), this.listeners.on(document.body, "mousemove", Ie((t2) => {
      this.processMouseMove(t2);
    }, 10), {
      passive: true
    }), this.listeners.on(document.body, "mouseleave", () => {
      this.processMouseLeave();
    }), this.listeners.on(window, "scroll", Ie((t2) => {
      this.processScroll(t2);
    }, 10), {
      passive: true
    }), this.listeners.on(document.body, "mouseup", () => {
      this.processMouseUp();
    }, false);
  }
  /**
   * Handle mouse down events
   *
   * @param {MouseEvent} mouseEvent - mouse event payload
   */
  processMouseDown(e2) {
    if (e2.button !== this.MAIN_MOUSE_BUTTON)
      return;
    e2.target.closest(c$4.allInputsSelector) !== null || this.startSelection(e2.pageX, e2.pageY);
  }
  /**
   * Handle mouse move events
   *
   * @param {MouseEvent} mouseEvent - mouse event payload
   */
  processMouseMove(e2) {
    this.changingRectangle(e2), this.scrollByZones(e2.clientY);
  }
  /**
   * Handle mouse leave
   */
  processMouseLeave() {
    this.clearSelection(), this.endSelection();
  }
  /**
   * @param {MouseEvent} mouseEvent - mouse event payload
   */
  processScroll(e2) {
    this.changingRectangle(e2);
  }
  /**
   * Handle mouse up
   */
  processMouseUp() {
    this.clearSelection(), this.endSelection();
  }
  /**
   * Scroll If mouse in scroll zone
   *
   * @param {number} clientY - Y coord of mouse
   */
  scrollByZones(e2) {
    if (this.inScrollZone = null, e2 <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.TOP_SCROLL_ZONE), document.documentElement.clientHeight - e2 <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.BOTTOM_SCROLL_ZONE), !this.inScrollZone) {
      this.isScrolling = false;
      return;
    }
    this.isScrolling || (this.scrollVertical(this.inScrollZone === this.TOP_SCROLL_ZONE ? -this.SCROLL_SPEED : this.SCROLL_SPEED), this.isScrolling = true);
  }
  /**
   * Generates required HTML elements
   *
   * @returns {Object<string, Element>}
   */
  genHTML() {
    const { UI: e2 } = this.Editor, t2 = e2.nodes.holder.querySelector("." + e2.CSS.editorWrapper), o3 = c$4.make("div", fe.CSS.overlay, {}), i2 = c$4.make("div", fe.CSS.overlayContainer, {}), n3 = c$4.make("div", fe.CSS.rect, {});
    return i2.appendChild(n3), o3.appendChild(i2), t2.appendChild(o3), this.overlayRectangle = n3, {
      container: t2,
      overlay: o3
    };
  }
  /**
   * Activates scrolling if blockSelection is active and mouse is in scroll zone
   *
   * @param {number} speed - speed of scrolling
   */
  scrollVertical(e2) {
    if (!(this.inScrollZone && this.mousedown))
      return;
    const t2 = window.pageYOffset;
    window.scrollBy(0, e2), this.mouseY += window.pageYOffset - t2, setTimeout(() => {
      this.scrollVertical(e2);
    }, 0);
  }
  /**
   * Handles the change in the rectangle and its effect
   *
   * @param {MouseEvent} event - mouse event
   */
  changingRectangle(e2) {
    if (!this.mousedown)
      return;
    e2.pageY !== void 0 && (this.mouseX = e2.pageX, this.mouseY = e2.pageY);
    const { rightPos: t2, leftPos: o3, index: i2 } = this.genInfoForMouseSelection(), n3 = this.startX > t2 && this.mouseX > t2, r4 = this.startX < o3 && this.mouseX < o3;
    this.rectCrossesBlocks = !(n3 || r4), this.isRectSelectionActivated || (this.rectCrossesBlocks = false, this.isRectSelectionActivated = true, this.shrinkRectangleToPoint(), this.overlayRectangle.style.display = "block"), this.updateRectangleSize(), this.Editor.Toolbar.close(), i2 !== void 0 && (this.trySelectNextBlock(i2), this.inverseSelection(), b$1.get().removeAllRanges());
  }
  /**
   * Shrink rect to singular point
   */
  shrinkRectangleToPoint() {
    this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`;
  }
  /**
   * Select or unselect all of blocks in array if rect is out or in selectable area
   */
  inverseSelection() {
    const t2 = this.Editor.BlockManager.getBlockByIndex(this.stackOfSelected[0]).selected;
    if (this.rectCrossesBlocks && !t2)
      for (const o3 of this.stackOfSelected)
        this.Editor.BlockSelection.selectBlockByIndex(o3);
    if (!this.rectCrossesBlocks && t2)
      for (const o3 of this.stackOfSelected)
        this.Editor.BlockSelection.unSelectBlockByIndex(o3);
  }
  /**
   * Updates size of rectangle
   */
  updateRectangleSize() {
    this.mouseY >= this.startY ? (this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.mouseY - window.pageYOffset}px`) : (this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.top = `${this.mouseY - window.pageYOffset}px`), this.mouseX >= this.startX ? (this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.mouseX - window.pageXOffset}px`) : (this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.left = `${this.mouseX - window.pageXOffset}px`);
  }
  /**
   * Collects information needed to determine the behavior of the rectangle
   *
   * @returns {object} index - index next Block, leftPos - start of left border of Block, rightPos - right border
   */
  genInfoForMouseSelection() {
    const t2 = document.body.offsetWidth / 2, o3 = this.mouseY - window.pageYOffset, i2 = document.elementFromPoint(t2, o3), n3 = this.Editor.BlockManager.getBlockByChildNode(i2);
    let r4;
    n3 !== void 0 && (r4 = this.Editor.BlockManager.blocks.findIndex((h2) => h2.holder === n3.holder));
    const a3 = this.Editor.BlockManager.lastBlock.holder.querySelector("." + R$3.CSS.content), l2 = Number.parseInt(window.getComputedStyle(a3).width, 10) / 2, d4 = t2 - l2, u3 = t2 + l2;
    return {
      index: r4,
      leftPos: d4,
      rightPos: u3
    };
  }
  /**
   * Select block with index index
   *
   * @param index - index of block in redactor
   */
  addBlockInSelection(e2) {
    this.rectCrossesBlocks && this.Editor.BlockSelection.selectBlockByIndex(e2), this.stackOfSelected.push(e2);
  }
  /**
   * Adds a block to the selection and determines which blocks should be selected
   *
   * @param {object} index - index of new block in the reactor
   */
  trySelectNextBlock(e2) {
    const t2 = this.stackOfSelected[this.stackOfSelected.length - 1] === e2, o3 = this.stackOfSelected.length, i2 = 1, n3 = -1, r4 = 0;
    if (t2)
      return;
    const a3 = this.stackOfSelected[o3 - 1] - this.stackOfSelected[o3 - 2] > 0;
    let l2 = r4;
    o3 > 1 && (l2 = a3 ? i2 : n3);
    const d4 = e2 > this.stackOfSelected[o3 - 1] && l2 === i2, u3 = e2 < this.stackOfSelected[o3 - 1] && l2 === n3, f2 = !(d4 || u3 || l2 === r4);
    if (!f2 && (e2 > this.stackOfSelected[o3 - 1] || this.stackOfSelected[o3 - 1] === void 0)) {
      let m3 = this.stackOfSelected[o3 - 1] + 1 || e2;
      for (m3; m3 <= e2; m3++)
        this.addBlockInSelection(m3);
      return;
    }
    if (!f2 && e2 < this.stackOfSelected[o3 - 1]) {
      for (let m3 = this.stackOfSelected[o3 - 1] - 1; m3 >= e2; m3--)
        this.addBlockInSelection(m3);
      return;
    }
    if (!f2)
      return;
    let x2 = o3 - 1, p2;
    for (e2 > this.stackOfSelected[o3 - 1] ? p2 = () => e2 > this.stackOfSelected[x2] : p2 = () => e2 < this.stackOfSelected[x2]; p2(); )
      this.rectCrossesBlocks && this.Editor.BlockSelection.unSelectBlockByIndex(this.stackOfSelected[x2]), this.stackOfSelected.pop(), x2--;
  }
}
class ci extends y$1 {
  /**
   * Renders passed blocks as one batch
   *
   * @param blocksData - blocks to render
   */
  async render(e2) {
    return new Promise((t2) => {
      const { Tools: o3, BlockManager: i2 } = this.Editor;
      if (e2.length === 0)
        i2.insert();
      else {
        const n3 = e2.map(({ type: r4, data: a3, tunes: l2, id: d4 }) => {
          o3.available.has(r4) === false && (Y(`Tool «${r4}» is not found. Check 'tools' property at the Editor.js config.`, "warn"), a3 = this.composeStubDataForTool(r4, a3, d4), r4 = o3.stubTool);
          let u3;
          try {
            u3 = i2.composeBlock({
              id: d4,
              tool: r4,
              data: a3,
              tunes: l2
            });
          } catch (h2) {
            T$1(`Block «${r4}» skipped because of plugins error`, "error", {
              data: a3,
              error: h2
            }), a3 = this.composeStubDataForTool(r4, a3, d4), r4 = o3.stubTool, u3 = i2.composeBlock({
              id: d4,
              tool: r4,
              data: a3,
              tunes: l2
            });
          }
          return u3;
        });
        i2.insertMany(n3);
      }
      window.requestIdleCallback(() => {
        t2();
      }, { timeout: 2e3 });
    });
  }
  /**
   * Create data for the Stub Tool that will be used instead of unavailable tool
   *
   * @param tool - unavailable tool name to stub
   * @param data - data of unavailable block
   * @param [id] - id of unavailable block
   */
  composeStubDataForTool(e2, t2, o3) {
    const { Tools: i2 } = this.Editor;
    let n3 = e2;
    if (i2.unavailable.has(e2)) {
      const r4 = i2.unavailable.get(e2).toolbox;
      r4 !== void 0 && r4[0].title !== void 0 && (n3 = r4[0].title);
    }
    return {
      savedData: {
        id: o3,
        type: e2,
        data: t2
      },
      title: n3
    };
  }
}
class di extends y$1 {
  /**
   * Composes new chain of Promises to fire them alternatelly
   *
   * @returns {OutputData}
   */
  async save() {
    const { BlockManager: e2, Tools: t2 } = this.Editor, o3 = e2.blocks, i2 = [];
    try {
      o3.forEach((a3) => {
        i2.push(this.getSavedData(a3));
      });
      const n3 = await Promise.all(i2), r4 = await bt(n3, (a3) => t2.blockTools.get(a3).sanitizeConfig);
      return this.makeOutput(r4);
    } catch (n3) {
      Y("Saving failed due to the Error %o", "error", n3);
    }
  }
  /**
   * Saves and validates
   *
   * @param {Block} block - Editor's Tool
   * @returns {ValidatedData} - Tool's validated data
   */
  async getSavedData(e2) {
    const t2 = await e2.save(), o3 = t2 && await e2.validate(t2.data);
    return {
      ...t2,
      isValid: o3
    };
  }
  /**
   * Creates output object with saved data, time and version of editor
   *
   * @param {ValidatedData} allExtractedData - data extracted from Blocks
   * @returns {OutputData}
   */
  makeOutput(e2) {
    const t2 = [];
    return e2.forEach(({ id: o3, tool: i2, data: n3, tunes: r4, isValid: a3 }) => {
      if (!a3) {
        T$1(`Block «${i2}» skipped because saved data is invalid`);
        return;
      }
      if (i2 === this.Editor.Tools.stubTool) {
        t2.push(n3);
        return;
      }
      const l2 = {
        id: o3,
        type: i2,
        data: n3,
        ...!W(r4) && {
          tunes: r4
        }
      };
      t2.push(l2);
    }), {
      time: +/* @__PURE__ */ new Date(),
      blocks: t2,
      version: "2.29.1"
    };
  }
}
(function() {
  try {
    if (typeof document < "u") {
      var s4 = document.createElement("style");
      s4.appendChild(document.createTextNode(".ce-paragraph{line-height:1.6em;outline:none}.ce-paragraph[data-placeholder]:empty:before{content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:before{opacity:1}.codex-editor--toolbox-opened .ce-block:first-child .ce-paragraph[data-placeholder]:empty:before,.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:focus:before{opacity:0}.ce-paragraph p:first-of-type{margin-top:0}.ce-paragraph p:last-of-type{margin-bottom:0}")), document.head.appendChild(s4);
    }
  } catch (e2) {
    console.error("vite-plugin-css-injected-by-js", e2);
  }
})();
const hi = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14"/></svg>';
/**
 * Base Paragraph Block for the Editor.js.
 * Represents a regular text block
 *
 * @author CodeX (team@codex.so)
 * @copyright CodeX 2018
 * @license The MIT License (MIT)
 */
class Ke {
  /**
   * Default placeholder for Paragraph Tool
   *
   * @returns {string}
   * @class
   */
  static get DEFAULT_PLACEHOLDER() {
    return "";
  }
  /**
   * Render plugin`s main Element and fill it with saved data
   *
   * @param {object} params - constructor params
   * @param {ParagraphData} params.data - previously saved data
   * @param {ParagraphConfig} params.config - user config for Tool
   * @param {object} params.api - editor.js api
   * @param {boolean} readOnly - read only mode flag
   */
  constructor({ data: e2, config: t2, api: o3, readOnly: i2 }) {
    this.api = o3, this.readOnly = i2, this._CSS = {
      block: this.api.styles.block,
      wrapper: "ce-paragraph"
    }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = t2.placeholder ? t2.placeholder : Ke.DEFAULT_PLACEHOLDER, this._data = {}, this._element = null, this._preserveBlank = t2.preserveBlank !== void 0 ? t2.preserveBlank : false, this.data = e2;
  }
  /**
   * Check if text content is empty and set empty string to inner html.
   * We need this because some browsers (e.g. Safari) insert <br> into empty contenteditanle elements
   *
   * @param {KeyboardEvent} e - key up event
   */
  onKeyUp(e2) {
    if (e2.code !== "Backspace" && e2.code !== "Delete")
      return;
    const { textContent: t2 } = this._element;
    t2 === "" && (this._element.innerHTML = "");
  }
  /**
   * Create Tool's view
   *
   * @returns {HTMLElement}
   * @private
   */
  drawView() {
    const e2 = document.createElement("DIV");
    return e2.classList.add(this._CSS.wrapper, this._CSS.block), e2.contentEditable = false, e2.dataset.placeholder = this.api.i18n.t(this._placeholder), this._data.text && (e2.innerHTML = this._data.text), this.readOnly || (e2.contentEditable = true, e2.addEventListener("keyup", this.onKeyUp)), e2;
  }
  /**
   * Return Tool's view
   *
   * @returns {HTMLDivElement}
   */
  render() {
    return this._element = this.drawView(), this._element;
  }
  /**
   * Method that specified how to merge two Text blocks.
   * Called by Editor.js by backspace at the beginning of the Block
   *
   * @param {ParagraphData} data
   * @public
   */
  merge(e2) {
    const t2 = {
      text: this.data.text + e2.text
    };
    this.data = t2;
  }
  /**
   * Validate Paragraph block data:
   * - check for emptiness
   *
   * @param {ParagraphData} savedData — data received after saving
   * @returns {boolean} false if saved data is not correct, otherwise true
   * @public
   */
  validate(e2) {
    return !(e2.text.trim() === "" && !this._preserveBlank);
  }
  /**
   * Extract Tool's data from the view
   *
   * @param {HTMLDivElement} toolsContent - Paragraph tools rendered view
   * @returns {ParagraphData} - saved data
   * @public
   */
  save(e2) {
    return {
      text: e2.innerHTML
    };
  }
  /**
   * On paste callback fired from Editor.
   *
   * @param {PasteEvent} event - event with pasted data
   */
  onPaste(e2) {
    const t2 = {
      text: e2.detail.data.innerHTML
    };
    this.data = t2;
  }
  /**
   * Enable Conversion Toolbar. Paragraph can be converted to/from other tools
   */
  static get conversionConfig() {
    return {
      export: "text",
      // to convert Paragraph to other block, use 'text' property of saved data
      import: "text"
      // to covert other block's exported string to Paragraph, fill 'text' property of tool data
    };
  }
  /**
   * Sanitizer rules
   */
  static get sanitize() {
    return {
      text: {
        br: true
      }
    };
  }
  /**
   * Returns true to notify the core that read-only mode is supported
   *
   * @returns {boolean}
   */
  static get isReadOnlySupported() {
    return true;
  }
  /**
   * Get current Tools`s data
   *
   * @returns {ParagraphData} Current data
   * @private
   */
  get data() {
    if (this._element !== null) {
      const e2 = this._element.innerHTML;
      this._data.text = e2;
    }
    return this._data;
  }
  /**
   * Store data in plugin:
   * - at the this._data property
   * - at the HTML
   *
   * @param {ParagraphData} data — data to set
   * @private
   */
  set data(e2) {
    this._data = e2 || {}, this._element !== null && this.hydrate();
  }
  /**
   * Fill tool's view with data
   */
  hydrate() {
    window.requestAnimationFrame(() => {
      this._element.innerHTML = this._data.text || "";
    });
  }
  /**
   * Used by Editor paste handling API.
   * Provides configuration to handle P tags.
   *
   * @returns {{tags: string[]}}
   */
  static get pasteConfig() {
    return {
      tags: ["P"]
    };
  }
  /**
   * Icon and title for displaying at the Toolbox
   *
   * @returns {{icon: string, title: string}}
   */
  static get toolbox() {
    return {
      icon: hi,
      title: "Text"
    };
  }
}
class Xe {
  constructor() {
    this.commandName = "bold", this.CSS = {
      button: "ce-inline-tool",
      buttonActive: "ce-inline-tool--active",
      buttonModifier: "ce-inline-tool--bold"
    }, this.nodes = {
      button: void 0
    };
  }
  /**
   * Sanitizer Rule
   * Leave <b> tags
   *
   * @returns {object}
   */
  static get sanitize() {
    return {
      b: {}
    };
  }
  /**
   * Create button for Inline Toolbar
   */
  render() {
    return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = _o, this.nodes.button;
  }
  /**
   * Wrap range with <b> tag
   */
  surround() {
    document.execCommand(this.commandName);
  }
  /**
   * Check selection and set activated state to button if there are <b> tag
   *
   * @returns {boolean}
   */
  checkState() {
    const e2 = document.queryCommandState(this.commandName);
    return this.nodes.button.classList.toggle(this.CSS.buttonActive, e2), e2;
  }
  /**
   * Set a shortcut
   *
   * @returns {boolean}
   */
  get shortcut() {
    return "CMD+B";
  }
}
Xe.isInline = true;
Xe.title = "Bold";
class Ve {
  constructor() {
    this.commandName = "italic", this.CSS = {
      button: "ce-inline-tool",
      buttonActive: "ce-inline-tool--active",
      buttonModifier: "ce-inline-tool--italic"
    }, this.nodes = {
      button: null
    };
  }
  /**
   * Sanitizer Rule
   * Leave <i> tags
   *
   * @returns {object}
   */
  static get sanitize() {
    return {
      i: {}
    };
  }
  /**
   * Create button for Inline Toolbar
   */
  render() {
    return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Do, this.nodes.button;
  }
  /**
   * Wrap range with <i> tag
   */
  surround() {
    document.execCommand(this.commandName);
  }
  /**
   * Check selection and set activated state to button if there are <i> tag
   */
  checkState() {
    const e2 = document.queryCommandState(this.commandName);
    return this.nodes.button.classList.toggle(this.CSS.buttonActive, e2), e2;
  }
  /**
   * Set a shortcut
   */
  get shortcut() {
    return "CMD+I";
  }
}
Ve.isInline = true;
Ve.title = "Italic";
class qe {
  /**
   * @param api - Editor.js API
   */
  constructor({ api: e2 }) {
    this.commandLink = "createLink", this.commandUnlink = "unlink", this.ENTER_KEY = 13, this.CSS = {
      button: "ce-inline-tool",
      buttonActive: "ce-inline-tool--active",
      buttonModifier: "ce-inline-tool--link",
      buttonUnlink: "ce-inline-tool--unlink",
      input: "ce-inline-tool-input",
      inputShowed: "ce-inline-tool-input--showed"
    }, this.nodes = {
      button: null,
      input: null
    }, this.inputOpened = false, this.toolbar = e2.toolbar, this.inlineToolbar = e2.inlineToolbar, this.notifier = e2.notifier, this.i18n = e2.i18n, this.selection = new b$1();
  }
  /**
   * Sanitizer Rule
   * Leave <a> tags
   *
   * @returns {object}
   */
  static get sanitize() {
    return {
      a: {
        href: true,
        target: "_blank",
        rel: "nofollow"
      }
    };
  }
  /**
   * Create button for Inline Toolbar
   */
  render() {
    return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = it, this.nodes.button;
  }
  /**
   * Input for the link
   */
  renderActions() {
    return this.nodes.input = document.createElement("input"), this.nodes.input.placeholder = this.i18n.t("Add a link"), this.nodes.input.classList.add(this.CSS.input), this.nodes.input.addEventListener("keydown", (e2) => {
      e2.keyCode === this.ENTER_KEY && this.enterPressed(e2);
    }), this.nodes.input;
  }
  /**
   * Handle clicks on the Inline Toolbar icon
   *
   * @param {Range} range - range to wrap with link
   */
  surround(e2) {
    if (e2) {
      this.inputOpened ? (this.selection.restore(), this.selection.removeFakeBackground()) : (this.selection.setFakeBackground(), this.selection.save());
      const t2 = this.selection.findParentTag("A");
      if (t2) {
        this.selection.expandToTag(t2), this.unlink(), this.closeActions(), this.checkState(), this.toolbar.close();
        return;
      }
    }
    this.toggleActions();
  }
  /**
   * Check selection and set activated state to button if there are <a> tag
   */
  checkState() {
    const e2 = this.selection.findParentTag("A");
    if (e2) {
      this.nodes.button.innerHTML = zo, this.nodes.button.classList.add(this.CSS.buttonUnlink), this.nodes.button.classList.add(this.CSS.buttonActive), this.openActions();
      const t2 = e2.getAttribute("href");
      this.nodes.input.value = t2 !== "null" ? t2 : "", this.selection.save();
    } else
      this.nodes.button.innerHTML = it, this.nodes.button.classList.remove(this.CSS.buttonUnlink), this.nodes.button.classList.remove(this.CSS.buttonActive);
    return !!e2;
  }
  /**
   * Function called with Inline Toolbar closing
   */
  clear() {
    this.closeActions();
  }
  /**
   * Set a shortcut
   */
  get shortcut() {
    return "CMD+K";
  }
  /**
   * Show/close link input
   */
  toggleActions() {
    this.inputOpened ? this.closeActions(false) : this.openActions(true);
  }
  /**
   * @param {boolean} needFocus - on link creation we need to focus input. On editing - nope.
   */
  openActions(e2 = false) {
    this.nodes.input.classList.add(this.CSS.inputShowed), e2 && this.nodes.input.focus(), this.inputOpened = true;
  }
  /**
   * Close input
   *
   * @param {boolean} clearSavedSelection — we don't need to clear saved selection
   *                                        on toggle-clicks on the icon of opened Toolbar
   */
  closeActions(e2 = true) {
    if (this.selection.isFakeBackgroundEnabled) {
      const t2 = new b$1();
      t2.save(), this.selection.restore(), this.selection.removeFakeBackground(), t2.restore();
    }
    this.nodes.input.classList.remove(this.CSS.inputShowed), this.nodes.input.value = "", e2 && this.selection.clearSaved(), this.inputOpened = false;
  }
  /**
   * Enter pressed on input
   *
   * @param {KeyboardEvent} event - enter keydown event
   */
  enterPressed(e2) {
    let t2 = this.nodes.input.value || "";
    if (!t2.trim()) {
      this.selection.restore(), this.unlink(), e2.preventDefault(), this.closeActions();
      return;
    }
    if (!this.validateURL(t2)) {
      this.notifier.show({
        message: "Pasted link is not valid.",
        style: "error"
      }), T$1("Incorrect Link pasted", "warn", t2);
      return;
    }
    t2 = this.prepareLink(t2), this.selection.restore(), this.selection.removeFakeBackground(), this.insertLink(t2), e2.preventDefault(), e2.stopPropagation(), e2.stopImmediatePropagation(), this.selection.collapseToEnd(), this.inlineToolbar.close();
  }
  /**
   * Detects if passed string is URL
   *
   * @param {string} str - string to validate
   * @returns {boolean}
   */
  validateURL(e2) {
    return !/\s/.test(e2);
  }
  /**
   * Process link before injection
   * - sanitize
   * - add protocol for links like 'google.com'
   *
   * @param {string} link - raw user input
   */
  prepareLink(e2) {
    return e2 = e2.trim(), e2 = this.addProtocol(e2), e2;
  }
  /**
   * Add 'http' protocol to the links like 'vc.ru', 'google.com'
   *
   * @param {string} link - string to process
   */
  addProtocol(e2) {
    if (/^(\w+):(\/\/)?/.test(e2))
      return e2;
    const t2 = /^\/[^/\s]/.test(e2), o3 = e2.substring(0, 1) === "#", i2 = /^\/\/[^/\s]/.test(e2);
    return !t2 && !o3 && !i2 && (e2 = "http://" + e2), e2;
  }
  /**
   * Inserts <a> tag with "href"
   *
   * @param {string} link - "href" value
   */
  insertLink(e2) {
    const t2 = this.selection.findParentTag("A");
    t2 && this.selection.expandToTag(t2), document.execCommand(this.commandLink, false, e2);
  }
  /**
   * Removes <a> tag
   */
  unlink() {
    document.execCommand(this.commandUnlink);
  }
}
qe.isInline = true;
qe.title = "Link";
class St {
  /**
   * @param options - constructor options
   * @param options.data - stub tool data
   * @param options.api - Editor.js API
   */
  constructor({ data: e2, api: t2 }) {
    this.CSS = {
      wrapper: "ce-stub",
      info: "ce-stub__info",
      title: "ce-stub__title",
      subtitle: "ce-stub__subtitle"
    }, this.api = t2, this.title = e2.title || this.api.i18n.t("Error"), this.subtitle = this.api.i18n.t("The block can not be displayed correctly."), this.savedData = e2.savedData, this.wrapper = this.make();
  }
  /**
   * Returns stub holder
   *
   * @returns {HTMLElement}
   */
  render() {
    return this.wrapper;
  }
  /**
   * Return original Tool data
   *
   * @returns {BlockToolData}
   */
  save() {
    return this.savedData;
  }
  /**
   * Create Tool html markup
   *
   * @returns {HTMLElement}
   */
  make() {
    const e2 = c$4.make("div", this.CSS.wrapper), t2 = Uo, o3 = c$4.make("div", this.CSS.info), i2 = c$4.make("div", this.CSS.title, {
      textContent: this.title
    }), n3 = c$4.make("div", this.CSS.subtitle, {
      textContent: this.subtitle
    });
    return e2.innerHTML = t2, o3.appendChild(i2), o3.appendChild(n3), e2.appendChild(o3), e2;
  }
}
St.isReadOnlySupported = true;
class ui extends Ye {
  constructor() {
    super(...arguments), this.type = Be.Inline;
  }
  /**
   * Returns title for Inline Tool if specified by user
   */
  get title() {
    return this.constructable[We.Title];
  }
  /**
   * Constructs new InlineTool instance from constructable
   */
  create() {
    return new this.constructable({
      api: this.api.getMethodsForTool(this),
      config: this.settings
    });
  }
}
class pi extends Ye {
  constructor() {
    super(...arguments), this.type = Be.Tune;
  }
  /**
   * Constructs new BlockTune instance from constructable
   *
   * @param data - Tune data
   * @param block - Block API object
   */
  create(e2, t2) {
    return new this.constructable({
      api: this.api.getMethodsForTool(this),
      config: this.settings,
      block: t2,
      data: e2
    });
  }
}
let P$2 = class P extends Map {
  /**
   * Returns Block Tools collection
   */
  get blockTools() {
    const e2 = Array.from(this.entries()).filter(([, t2]) => t2.isBlock());
    return new P(e2);
  }
  /**
   * Returns Inline Tools collection
   */
  get inlineTools() {
    const e2 = Array.from(this.entries()).filter(([, t2]) => t2.isInline());
    return new P(e2);
  }
  /**
   * Returns Block Tunes collection
   */
  get blockTunes() {
    const e2 = Array.from(this.entries()).filter(([, t2]) => t2.isTune());
    return new P(e2);
  }
  /**
   * Returns internal Tools collection
   */
  get internalTools() {
    const e2 = Array.from(this.entries()).filter(([, t2]) => t2.isInternal);
    return new P(e2);
  }
  /**
   * Returns Tools collection provided by user
   */
  get externalTools() {
    const e2 = Array.from(this.entries()).filter(([, t2]) => !t2.isInternal);
    return new P(e2);
  }
};
var fi = Object.defineProperty, gi = Object.getOwnPropertyDescriptor, It = (s4, e2, t2, o3) => {
  for (var i2 = o3 > 1 ? void 0 : o3 ? gi(e2, t2) : e2, n3 = s4.length - 1, r4; n3 >= 0; n3--)
    (r4 = s4[n3]) && (i2 = (o3 ? r4(e2, t2, i2) : r4(i2)) || i2);
  return o3 && i2 && fi(e2, t2, i2), i2;
};
class Ze extends Ye {
  constructor() {
    super(...arguments), this.type = Be.Block, this.inlineTools = new P$2(), this.tunes = new P$2();
  }
  /**
   * Creates new Tool instance
   *
   * @param data - Tool data
   * @param block - BlockAPI for current Block
   * @param readOnly - True if Editor is in read-only mode
   */
  create(e2, t2, o3) {
    return new this.constructable({
      data: e2,
      block: t2,
      readOnly: o3,
      api: this.api.getMethodsForTool(this),
      config: this.settings
    });
  }
  /**
   * Returns true if read-only mode is supported by Tool
   */
  get isReadOnlySupported() {
    return this.constructable[se.IsReadOnlySupported] === true;
  }
  /**
   * Returns true if Tool supports linebreaks
   */
  get isLineBreaksEnabled() {
    return this.constructable[se.IsEnabledLineBreaks];
  }
  /**
   * Returns Tool toolbox configuration (internal or user-specified).
   *
   * Merges internal and user-defined toolbox configs based on the following rules:
   *
   * - If both internal and user-defined toolbox configs are arrays their items are merged.
   * Length of the second one is kept.
   *
   * - If both are objects their properties are merged.
   *
   * - If one is an object and another is an array than internal config is replaced with user-defined
   * config. This is made to allow user to override default tool's toolbox representation (single/multiple entries)
   */
  get toolbox() {
    const e2 = this.constructable[se.Toolbox], t2 = this.config[ve.Toolbox];
    if (!W(e2) && t2 !== false)
      return t2 ? Array.isArray(e2) ? Array.isArray(t2) ? t2.map((o3, i2) => {
        const n3 = e2[i2];
        return n3 ? {
          ...n3,
          ...o3
        } : o3;
      }) : [t2] : Array.isArray(t2) ? t2 : [
        {
          ...e2,
          ...t2
        }
      ] : Array.isArray(e2) ? e2 : [e2];
  }
  /**
   * Returns Tool conversion configuration
   */
  get conversionConfig() {
    return this.constructable[se.ConversionConfig];
  }
  /**
   * Returns enabled inline tools for Tool
   */
  get enabledInlineTools() {
    return this.config[ve.EnabledInlineTools] || false;
  }
  /**
   * Returns enabled tunes for Tool
   */
  get enabledBlockTunes() {
    return this.config[ve.EnabledBlockTunes];
  }
  /**
   * Returns Tool paste configuration
   */
  get pasteConfig() {
    return this.constructable[se.PasteConfig] ?? {};
  }
  get sanitizeConfig() {
    const e2 = super.sanitizeConfig, t2 = this.baseSanitizeConfig;
    if (W(e2))
      return t2;
    const o3 = {};
    for (const i2 in e2)
      if (Object.prototype.hasOwnProperty.call(e2, i2)) {
        const n3 = e2[i2];
        D$1(n3) ? o3[i2] = Object.assign({}, t2, n3) : o3[i2] = n3;
      }
    return o3;
  }
  get baseSanitizeConfig() {
    const e2 = {};
    return Array.from(this.inlineTools.values()).forEach((t2) => Object.assign(e2, t2.sanitizeConfig)), Array.from(this.tunes.values()).forEach((t2) => Object.assign(e2, t2.sanitizeConfig)), e2;
  }
}
It([
  le
], Ze.prototype, "sanitizeConfig", 1);
It([
  le
], Ze.prototype, "baseSanitizeConfig", 1);
class bi {
  /**
   * @class
   * @param config - tools config
   * @param editorConfig - EditorJS config
   * @param api - EditorJS API module
   */
  constructor(e2, t2, o3) {
    this.api = o3, this.config = e2, this.editorConfig = t2;
  }
  /**
   * Returns Tool object based on it's type
   *
   * @param name - tool name
   */
  get(e2) {
    const { class: t2, isInternal: o3 = false, ...i2 } = this.config[e2], n3 = this.getConstructor(t2);
    return new n3({
      name: e2,
      constructable: t2,
      config: i2,
      api: this.api,
      isDefault: e2 === this.editorConfig.defaultBlock,
      defaultPlaceholder: this.editorConfig.placeholder,
      isInternal: o3
    });
  }
  /**
   * Find appropriate Tool object constructor for Tool constructable
   *
   * @param constructable - Tools constructable
   */
  getConstructor(e2) {
    switch (true) {
      case e2[We.IsInline]:
        return ui;
      case e2[Bt.IsTune]:
        return pi;
      default:
        return Ze;
    }
  }
}
class Mt {
  /**
   * MoveDownTune constructor
   *
   * @param {API} api — Editor's API
   */
  constructor({ api: e2 }) {
    this.CSS = {
      animation: "wobble"
    }, this.api = e2;
  }
  /**
   * Tune's appearance in block settings menu
   */
  render() {
    return {
      icon: kt,
      title: this.api.i18n.t("Move down"),
      onActivate: () => this.handleClick(),
      name: "move-down"
    };
  }
  /**
   * Handle clicks on 'move down' button
   */
  handleClick() {
    const e2 = this.api.blocks.getCurrentBlockIndex(), t2 = this.api.blocks.getBlockByIndex(e2 + 1);
    if (!t2)
      throw new Error("Unable to move Block down since it is already the last");
    const o3 = t2.holder, i2 = o3.getBoundingClientRect();
    let n3 = Math.abs(window.innerHeight - o3.offsetHeight);
    i2.top < window.innerHeight && (n3 = window.scrollY + o3.offsetHeight), window.scrollTo(0, n3), this.api.blocks.move(e2 + 1), this.api.toolbar.toggleBlockSettings(true);
  }
}
Mt.isTune = true;
class Lt {
  /**
   * DeleteTune constructor
   *
   * @param {API} api - Editor's API
   */
  constructor({ api: e2 }) {
    this.api = e2;
  }
  /**
   * Tune's appearance in block settings menu
   */
  render() {
    return {
      icon: No,
      title: this.api.i18n.t("Delete"),
      name: "delete",
      confirmation: {
        title: this.api.i18n.t("Click to delete"),
        onActivate: () => this.handleClick()
      }
    };
  }
  /**
   * Delete block conditions passed
   */
  handleClick() {
    this.api.blocks.delete();
  }
}
Lt.isTune = true;
class At {
  /**
   * MoveUpTune constructor
   *
   * @param {API} api - Editor's API
   */
  constructor({ api: e2 }) {
    this.CSS = {
      animation: "wobble"
    }, this.api = e2;
  }
  /**
   * Tune's appearance in block settings menu
   */
  render() {
    return {
      icon: Oo,
      title: this.api.i18n.t("Move up"),
      onActivate: () => this.handleClick(),
      name: "move-up"
    };
  }
  /**
   * Move current block up
   */
  handleClick() {
    const e2 = this.api.blocks.getCurrentBlockIndex(), t2 = this.api.blocks.getBlockByIndex(e2), o3 = this.api.blocks.getBlockByIndex(e2 - 1);
    if (e2 === 0 || !t2 || !o3)
      throw new Error("Unable to move Block up since it is already the first");
    const i2 = t2.holder, n3 = o3.holder, r4 = i2.getBoundingClientRect(), a3 = n3.getBoundingClientRect();
    let l2;
    a3.top > 0 ? l2 = Math.abs(r4.top) - Math.abs(a3.top) : l2 = Math.abs(r4.top) + a3.height, window.scrollBy(0, -1 * l2), this.api.blocks.move(e2 - 1), this.api.toolbar.toggleBlockSettings(true);
  }
}
At.isTune = true;
var mi = Object.defineProperty, ki = Object.getOwnPropertyDescriptor, vi = (s4, e2, t2, o3) => {
  for (var i2 = o3 > 1 ? void 0 : o3 ? ki(e2, t2) : e2, n3 = s4.length - 1, r4; n3 >= 0; n3--)
    (r4 = s4[n3]) && (i2 = (o3 ? r4(e2, t2, i2) : r4(i2)) || i2);
  return o3 && i2 && mi(e2, t2, i2), i2;
};
class _t extends y$1 {
  constructor() {
    super(...arguments), this.stubTool = "stub", this.toolsAvailable = new P$2(), this.toolsUnavailable = new P$2();
  }
  /**
   * Returns available Tools
   */
  get available() {
    return this.toolsAvailable;
  }
  /**
   * Returns unavailable Tools
   */
  get unavailable() {
    return this.toolsUnavailable;
  }
  /**
   * Return Tools for the Inline Toolbar
   */
  get inlineTools() {
    return this.available.inlineTools;
  }
  /**
   * Return editor block tools
   */
  get blockTools() {
    return this.available.blockTools;
  }
  /**
   * Return available Block Tunes
   *
   * @returns {object} - object of Inline Tool's classes
   */
  get blockTunes() {
    return this.available.blockTunes;
  }
  /**
   * Returns default Tool object
   */
  get defaultTool() {
    return this.blockTools.get(this.config.defaultBlock);
  }
  /**
   * Returns internal tools
   */
  get internal() {
    return this.available.internalTools;
  }
  /**
   * Creates instances via passed or default configuration
   *
   * @returns {Promise<void>}
   */
  async prepare() {
    if (this.validateTools(), this.config.tools = Me({}, this.internalTools, this.config.tools), !Object.prototype.hasOwnProperty.call(this.config, "tools") || Object.keys(this.config.tools).length === 0)
      throw Error("Can't start without tools");
    const e2 = this.prepareConfig();
    this.factory = new bi(e2, this.config, this.Editor.API);
    const t2 = this.getListOfPrepareFunctions(e2);
    if (t2.length === 0)
      return Promise.resolve();
    await zt(t2, (o3) => {
      this.toolPrepareMethodSuccess(o3);
    }, (o3) => {
      this.toolPrepareMethodFallback(o3);
    }), this.prepareBlockTools();
  }
  getAllInlineToolsSanitizeConfig() {
    const e2 = {};
    return Array.from(this.inlineTools.values()).forEach((t2) => {
      Object.assign(e2, t2.sanitizeConfig);
    }), e2;
  }
  /**
   * Calls each Tool reset method to clean up anything set by Tool
   */
  destroy() {
    Object.values(this.available).forEach(async (e2) => {
      M$2(e2.reset) && await e2.reset();
    });
  }
  /**
   * Returns internal tools
   * Includes Bold, Italic, Link and Paragraph
   */
  get internalTools() {
    return {
      bold: {
        class: Xe,
        isInternal: true
      },
      italic: {
        class: Ve,
        isInternal: true
      },
      link: {
        class: qe,
        isInternal: true
      },
      paragraph: {
        class: Ke,
        inlineToolbar: true,
        isInternal: true
      },
      stub: {
        class: St,
        isInternal: true
      },
      moveUp: {
        class: At,
        isInternal: true
      },
      delete: {
        class: Lt,
        isInternal: true
      },
      moveDown: {
        class: Mt,
        isInternal: true
      }
    };
  }
  /**
   * Tool prepare method success callback
   *
   * @param {object} data - append tool to available list
   */
  toolPrepareMethodSuccess(e2) {
    const t2 = this.factory.get(e2.toolName);
    if (t2.isInline()) {
      const i2 = ["render", "surround", "checkState"].filter((n3) => !t2.create()[n3]);
      if (i2.length) {
        T$1(
          `Incorrect Inline Tool: ${t2.name}. Some of required methods is not implemented %o`,
          "warn",
          i2
        ), this.toolsUnavailable.set(t2.name, t2);
        return;
      }
    }
    this.toolsAvailable.set(t2.name, t2);
  }
  /**
   * Tool prepare method fail callback
   *
   * @param {object} data - append tool to unavailable list
   */
  toolPrepareMethodFallback(e2) {
    this.toolsUnavailable.set(e2.toolName, this.factory.get(e2.toolName));
  }
  /**
   * Binds prepare function of plugins with user or default config
   *
   * @returns {Array} list of functions that needs to be fired sequentially
   * @param config - tools config
   */
  getListOfPrepareFunctions(e2) {
    const t2 = [];
    return Object.entries(e2).forEach(([o3, i2]) => {
      t2.push({
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        function: M$2(i2.class.prepare) ? i2.class.prepare : () => {
        },
        data: {
          toolName: o3,
          config: i2.config
        }
      });
    }), t2;
  }
  /**
   * Assign enabled Inline Tools and Block Tunes for Block Tool
   */
  prepareBlockTools() {
    Array.from(this.blockTools.values()).forEach((e2) => {
      this.assignInlineToolsToBlockTool(e2), this.assignBlockTunesToBlockTool(e2);
    });
  }
  /**
   * Assign enabled Inline Tools for Block Tool
   *
   * @param tool - Block Tool
   */
  assignInlineToolsToBlockTool(e2) {
    if (this.config.inlineToolbar !== false) {
      if (e2.enabledInlineTools === true) {
        e2.inlineTools = new P$2(
          Array.isArray(this.config.inlineToolbar) ? this.config.inlineToolbar.map((t2) => [t2, this.inlineTools.get(t2)]) : Array.from(this.inlineTools.entries())
        );
        return;
      }
      Array.isArray(e2.enabledInlineTools) && (e2.inlineTools = new P$2(
        e2.enabledInlineTools.map((t2) => [t2, this.inlineTools.get(t2)])
      ));
    }
  }
  /**
   * Assign enabled Block Tunes for Block Tool
   *
   * @param tool — Block Tool
   */
  assignBlockTunesToBlockTool(e2) {
    if (e2.enabledBlockTunes !== false) {
      if (Array.isArray(e2.enabledBlockTunes)) {
        const t2 = new P$2(
          e2.enabledBlockTunes.map((o3) => [o3, this.blockTunes.get(o3)])
        );
        e2.tunes = new P$2([...t2, ...this.blockTunes.internalTools]);
        return;
      }
      if (Array.isArray(this.config.tunes)) {
        const t2 = new P$2(
          this.config.tunes.map((o3) => [o3, this.blockTunes.get(o3)])
        );
        e2.tunes = new P$2([...t2, ...this.blockTunes.internalTools]);
        return;
      }
      e2.tunes = this.blockTunes.internalTools;
    }
  }
  /**
   * Validate Tools configuration objects and throw Error for user if it is invalid
   */
  validateTools() {
    for (const e2 in this.config.tools)
      if (Object.prototype.hasOwnProperty.call(this.config.tools, e2)) {
        if (e2 in this.internalTools)
          return;
        const t2 = this.config.tools[e2];
        if (!M$2(t2) && !M$2(t2.class))
          throw Error(
            `Tool «${e2}» must be a constructor function or an object with function in the «class» property`
          );
      }
  }
  /**
   * Unify tools config
   */
  prepareConfig() {
    const e2 = {};
    for (const t2 in this.config.tools)
      D$1(this.config.tools[t2]) ? e2[t2] = this.config.tools[t2] : e2[t2] = { class: this.config.tools[t2] };
    return e2;
  }
}
vi([
  le
], _t.prototype, "getAllInlineToolsSanitizeConfig", 1);
const xi = `:root{--selectionColor: #e1f2ff;--inlineSelectionColor: #d4ecff;--bg-light: #eff2f5;--grayText: #707684;--color-dark: #1D202B;--color-active-icon: #388AE5;--color-gray-border: rgba(201, 201, 204, .48);--content-width: 650px;--narrow-mode-right-padding: 50px;--toolbox-buttons-size: 26px;--toolbox-buttons-size--mobile: 36px;--icon-size: 20px;--icon-size--mobile: 28px;--block-padding-vertical: .4em;--color-line-gray: #EFF0F1 }.codex-editor{position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:1}.codex-editor .hide{display:none}.codex-editor__redactor [contenteditable]:empty:after{content:"\\feff"}@media (min-width: 651px){.codex-editor--narrow .codex-editor__redactor{margin-right:50px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .codex-editor__redactor{margin-left:50px;margin-right:0}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__actions{right:-5px}}.codex-editor-copyable{position:absolute;height:1px;width:1px;top:-400%;opacity:.001}.codex-editor-overlay{position:fixed;top:0px;left:0px;right:0px;bottom:0px;z-index:999;pointer-events:none;overflow:hidden}.codex-editor-overlay__container{position:relative;pointer-events:auto;z-index:0}.codex-editor-overlay__rectangle{position:absolute;pointer-events:none;background-color:#2eaadc33;border:1px solid transparent}.codex-editor svg{max-height:100%}.codex-editor path{stroke:currentColor}.codex-editor ::-moz-selection{background-color:#d4ecff}.codex-editor ::selection{background-color:#d4ecff}.codex-editor--toolbox-opened [contentEditable=true][data-placeholder]:focus:before{opacity:0!important}.ce-scroll-locked{overflow:hidden}.ce-scroll-locked--hard{overflow:hidden;top:calc(-1 * var(--window-scroll-offset));position:fixed;width:100%}.ce-toolbar{position:absolute;left:0;right:0;top:0;-webkit-transition:opacity .1s ease;transition:opacity .1s ease;will-change:opacity,top;display:none}.ce-toolbar--opened{display:block}.ce-toolbar__content{max-width:650px;margin:0 auto;position:relative}.ce-toolbar__plus{color:#1d202b;cursor:pointer;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-flex-negative:0;flex-shrink:0}@media (max-width: 650px){.ce-toolbar__plus{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__plus:hover{background-color:#eff2f5}}.ce-toolbar__plus--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-toolbar__plus-shortcut{opacity:.6;word-spacing:-2px;margin-top:5px}@media (max-width: 650px){.ce-toolbar__plus{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__plus--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__plus--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__actions{position:absolute;right:100%;opacity:0;display:-webkit-box;display:-ms-flexbox;display:flex;padding-right:5px}.ce-toolbar__actions--opened{opacity:1}@media (max-width: 650px){.ce-toolbar__actions{right:auto}}.ce-toolbar__settings-btn{color:#1d202b;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;margin-left:3px;cursor:pointer;user-select:none}@media (max-width: 650px){.ce-toolbar__settings-btn{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__settings-btn:hover{background-color:#eff2f5}}.ce-toolbar__settings-btn--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}@media (min-width: 651px){.ce-toolbar__settings-btn{width:24px}}.ce-toolbar__settings-btn--hidden{display:none}@media (max-width: 650px){.ce-toolbar__settings-btn{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__settings-btn--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__settings-btn--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__plus svg,.ce-toolbar__settings-btn svg{width:24px;height:24px}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__plus{left:5px}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbox .ce-popover{right:0;left:auto;left:initial}}.ce-inline-toolbar{--y-offset: 8px;position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;opacity:0;visibility:hidden;-webkit-transition:opacity .25s ease;transition:opacity .25s ease;will-change:opacity,left,top;top:0;left:0;z-index:3}.ce-inline-toolbar--left-oriented:before{left:15px;margin-left:0}.ce-inline-toolbar--right-oriented:before{left:auto;right:15px;margin-left:0}.ce-inline-toolbar--showed{opacity:1;visibility:visible}.ce-inline-toolbar [hidden]{display:none!important}.ce-inline-toolbar__toggler-and-button-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;padding:0 6px}.ce-inline-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown{display:-webkit-box;display:-ms-flexbox;display:flex;padding:6px;margin:0 6px 0 -6px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;border-right:1px solid rgba(201,201,204,.48);-webkit-box-sizing:border-box;box-sizing:border-box}@media (hover: hover){.ce-inline-toolbar__dropdown:hover{background:#eff2f5}}.ce-inline-toolbar__dropdown--hidden{display:none}.ce-inline-toolbar__dropdown-content,.ce-inline-toolbar__dropdown-arrow{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown-content svg,.ce-inline-toolbar__dropdown-arrow svg{width:20px;height:20px}.ce-inline-toolbar__shortcut{opacity:.6;word-spacing:-3px;margin-top:3px}.ce-inline-tool{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:6px 1px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;border-radius:0;line-height:normal}.ce-inline-tool svg{width:20px;height:20px}@media (max-width: 650px){.ce-inline-tool svg{width:28px;height:28px}}@media (hover: hover){.ce-inline-tool:hover{background-color:#eff2f5}}.ce-inline-tool--active{color:#388ae5}.ce-inline-tool--focused{background:rgba(34,186,255,.08)!important}.ce-inline-tool--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.ce-inline-tool--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-inline-tool--link .icon--unlink,.ce-inline-tool--unlink .icon--link{display:none}.ce-inline-tool--unlink .icon--unlink{display:inline-block;margin-bottom:-1px}.ce-inline-tool-input{outline:none;border:0;border-radius:0 0 4px 4px;margin:0;font-size:13px;padding:10px;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box;display:none;font-weight:500;border-top:1px solid rgba(201,201,204,.48);-webkit-appearance:none;font-family:inherit}@media (max-width: 650px){.ce-inline-tool-input{font-size:15px;font-weight:500}}.ce-inline-tool-input::-webkit-input-placeholder{color:#707684}.ce-inline-tool-input::-moz-placeholder{color:#707684}.ce-inline-tool-input:-ms-input-placeholder{color:#707684}.ce-inline-tool-input::-ms-input-placeholder{color:#707684}.ce-inline-tool-input::placeholder{color:#707684}.ce-inline-tool-input--showed{display:block}.ce-conversion-toolbar{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;opacity:0;visibility:hidden;will-change:transform,opacity;-webkit-transition:opacity .1s ease,-webkit-transform .1s ease;transition:opacity .1s ease,-webkit-transform .1s ease;transition:transform .1s ease,opacity .1s ease;transition:transform .1s ease,opacity .1s ease,-webkit-transform .1s ease;-webkit-transform:translateY(-8px);transform:translateY(-8px);left:-1px;width:190px;margin-top:5px;-webkit-box-sizing:content-box;box-sizing:content-box}.ce-conversion-toolbar--left-oriented:before{left:15px;margin-left:0}.ce-conversion-toolbar--right-oriented:before{left:auto;right:15px;margin-left:0}.ce-conversion-toolbar--showed{opacity:1;visibility:visible;-webkit-transform:none;transform:none}.ce-conversion-toolbar [hidden]{display:none!important}.ce-conversion-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-conversion-toolbar__label{color:#707684;font-size:11px;font-weight:500;letter-spacing:.33px;padding:10px 10px 5px;text-transform:uppercase}.ce-conversion-tool{display:-webkit-box;display:-ms-flexbox;display:flex;padding:5px 10px;font-size:14px;line-height:20px;font-weight:500;cursor:pointer;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-conversion-tool--hidden{display:none}.ce-conversion-tool--focused{background:rgba(34,186,255,.08)!important}.ce-conversion-tool--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.ce-conversion-tool--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-conversion-tool:hover{background:#eff2f5}.ce-conversion-tool__icon{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;width:26px;height:26px;-webkit-box-shadow:0 0 0 1px rgba(201,201,204,.48);box-shadow:0 0 0 1px #c9c9cc7a;border-radius:5px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;background:#fff;-webkit-box-sizing:content-box;box-sizing:content-box;-ms-flex-negative:0;flex-shrink:0;margin-right:10px}.ce-conversion-tool__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-conversion-tool__icon{width:36px;height:36px;border-radius:8px}.ce-conversion-tool__icon svg{width:28px;height:28px}}.ce-conversion-tool--last{margin-right:0!important}.ce-conversion-tool--active{color:#388ae5!important}.ce-conversion-tool--active{-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-conversion-tool__secondary-label{color:#707684;font-size:12px;margin-left:auto;white-space:nowrap;letter-spacing:-.1em;padding-right:5px;margin-bottom:-2px;opacity:.6}@media (max-width: 650px){.ce-conversion-tool__secondary-label{display:none}}.ce-settings__button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:6px 1px;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;line-height:32px}.ce-settings__button svg{width:20px;height:20px}@media (max-width: 650px){.ce-settings__button svg{width:28px;height:28px}}@media (hover: hover){.ce-settings__button:hover{background-color:#eff2f5}}.ce-settings__button--active{color:#388ae5}.ce-settings__button--focused{background:rgba(34,186,255,.08)!important}.ce-settings__button--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.ce-settings__button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-settings__button:not(:nth-child(3n+3)){margin-right:3px}.ce-settings__button:nth-child(n+4){margin-top:3px}.ce-settings__button--disabled{cursor:not-allowed!important}.ce-settings__button--disabled{opacity:.3}.ce-settings__button--selected{color:#388ae5}@media (min-width: 651px){.codex-editor--narrow .ce-settings .ce-popover{right:0;left:auto;left:initial}}@-webkit-keyframes fade-in{0%{opacity:0}to{opacity:1}}@keyframes fade-in{0%{opacity:0}to{opacity:1}}.ce-block{-webkit-animation:fade-in .3s ease;animation:fade-in .3s ease;-webkit-animation-fill-mode:none;animation-fill-mode:none;-webkit-animation-fill-mode:initial;animation-fill-mode:initial}.ce-block:first-of-type{margin-top:0}.ce-block--selected .ce-block__content{background:#e1f2ff}.ce-block--selected .ce-block__content [contenteditable]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ce-block--selected .ce-block__content img,.ce-block--selected .ce-block__content .ce-stub{opacity:.55}.ce-block--stretched .ce-block__content{max-width:none}.ce-block__content{position:relative;max-width:650px;margin:0 auto;-webkit-transition:background-color .15s ease;transition:background-color .15s ease}.ce-block--drop-target .ce-block__content:before{content:"";position:absolute;top:100%;left:-20px;margin-top:-1px;height:8px;width:8px;border:solid #388AE5;border-width:1px 1px 0 0;-webkit-transform-origin:right;transform-origin:right;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.ce-block--drop-target .ce-block__content:after{content:"";position:absolute;top:100%;height:1px;width:100%;color:#388ae5;background:repeating-linear-gradient(90deg,#388AE5,#388AE5 1px,#fff 1px,#fff 6px)}.ce-block a{cursor:pointer;-webkit-text-decoration:underline;text-decoration:underline}.ce-block b{font-weight:700}.ce-block i{font-style:italic}@-webkit-keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}.cdx-block{padding:.4em 0}.cdx-block::-webkit-input-placeholder{line-height:normal!important}.cdx-input{border:1px solid rgba(201,201,204,.48);-webkit-box-shadow:inset 0 1px 2px 0 rgba(35,44,72,.06);box-shadow:inset 0 1px 2px #232c480f;border-radius:3px;padding:10px 12px;outline:none;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box}.cdx-input[data-placeholder]:before{position:static!important}.cdx-input[data-placeholder]:before{display:inline-block;width:0;white-space:nowrap;pointer-events:none}.cdx-settings-button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:6px 1px;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;min-width:26px;min-height:26px}.cdx-settings-button svg{width:20px;height:20px}@media (max-width: 650px){.cdx-settings-button svg{width:28px;height:28px}}@media (hover: hover){.cdx-settings-button:hover{background-color:#eff2f5}}.cdx-settings-button--focused{background:rgba(34,186,255,.08)!important}.cdx-settings-button--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.cdx-settings-button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.cdx-settings-button--active{color:#388ae5}.cdx-settings-button svg{width:auto;height:auto}@media (max-width: 650px){.cdx-settings-button{width:36px;height:36px;border-radius:8px}}.cdx-loader{position:relative;border:1px solid rgba(201,201,204,.48)}.cdx-loader:before{content:"";position:absolute;left:50%;top:50%;width:18px;height:18px;margin:-11px 0 0 -11px;border:2px solid rgba(201,201,204,.48);border-left-color:#388ae5;border-radius:50%;-webkit-animation:cdxRotation 1.2s infinite linear;animation:cdxRotation 1.2s infinite linear}@-webkit-keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.cdx-button{padding:13px;border-radius:3px;border:1px solid rgba(201,201,204,.48);font-size:14.9px;background:#fff;-webkit-box-shadow:0 2px 2px 0 rgba(18,30,57,.04);box-shadow:0 2px 2px #121e390a;color:#707684;text-align:center;cursor:pointer}@media (hover: hover){.cdx-button:hover{background:#FBFCFE;-webkit-box-shadow:0 1px 3px 0 rgba(18,30,57,.08);box-shadow:0 1px 3px #121e3914}}.cdx-button svg{height:20px;margin-right:.2em;margin-top:-2px}.ce-stub{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:12px 18px;margin:10px 0;border-radius:10px;background:#eff2f5;border:1px solid #EFF0F1;color:#707684;font-size:14px}.ce-stub svg{width:20px;height:20px}.ce-stub__info{margin-left:14px}.ce-stub__title{font-weight:500;text-transform:capitalize}.codex-editor.codex-editor--rtl{direction:rtl}.codex-editor.codex-editor--rtl .cdx-list{padding-left:0;padding-right:40px}.codex-editor.codex-editor--rtl .ce-toolbar__plus{right:-26px;left:auto}.codex-editor.codex-editor--rtl .ce-toolbar__actions{right:auto;left:-26px}@media (max-width: 650px){.codex-editor.codex-editor--rtl .ce-toolbar__actions{margin-left:0;margin-right:auto;padding-right:0;padding-left:10px}}.codex-editor.codex-editor--rtl .ce-settings{left:5px;right:auto}.codex-editor.codex-editor--rtl .ce-settings:before{right:auto;left:25px}.codex-editor.codex-editor--rtl .ce-settings__button:not(:nth-child(3n+3)){margin-left:3px;margin-right:0}.codex-editor.codex-editor--rtl .ce-conversion-tool__icon{margin-right:0;margin-left:10px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown{border-right:0px solid transparent;border-left:1px solid rgba(201,201,204,.48);margin:0 -6px 0 6px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown .icon--toggler-down{margin-left:0;margin-right:4px}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__plus{left:0px;right:5px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__actions{left:-5px}}.cdx-search-field{--icon-margin-right: 10px;background:rgba(232,232,235,.49);border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:2px;display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto}.cdx-search-field__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:var(--icon-margin-right)}.cdx-search-field__icon svg{width:20px;height:20px;color:#707684}.cdx-search-field__input{font-size:14px;outline:none;font-weight:500;font-family:inherit;border:0;background:transparent;margin:0;padding:0;line-height:22px;min-width:calc(100% - 26px - var(--icon-margin-right))}.cdx-search-field__input::-webkit-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-moz-placeholder{color:#707684;font-weight:500}.cdx-search-field__input:-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::placeholder{color:#707684;font-weight:500}.ce-popover{--border-radius: 6px;--width: 200px;--max-height: 270px;--padding: 6px;--offset-from-target: 8px;--color-border: #e8e8eb;--color-shadow: rgba(13,20,33,.13);--color-background: white;--color-text-primary: black;--color-text-secondary: #707684;--color-border-icon: rgba(201, 201, 204, .48);--color-border-icon-disabled: #EFF0F1;--color-text-icon-active: #388AE5;--color-background-icon-active: rgba(56, 138, 229, .1);--color-background-item-focus: rgba(34, 186, 255, .08);--color-shadow-item-focus: rgba(7, 161, 227, .08);--color-background-item-hover: #eff2f5;--color-background-item-confirm: #E24A4A;--color-background-item-confirm-hover: #CE4343;min-width:var(--width);width:var(--width);max-height:var(--max-height);border-radius:var(--border-radius);overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-box-shadow:0 3px 15px -3px var(--color-shadow);box-shadow:0 3px 15px -3px var(--color-shadow);position:absolute;left:0;top:calc(100% + var(--offset-from-target));background:var(--color-background);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:4;opacity:0;max-height:0;pointer-events:none;padding:0;border:none}.ce-popover--opened{opacity:1;padding:var(--padding);max-height:var(--max-height);pointer-events:auto;-webkit-animation:panelShowing .1s ease;animation:panelShowing .1s ease;border:1px solid var(--color-border)}@media (max-width: 650px){.ce-popover--opened{-webkit-animation:panelShowingMobile .25s ease;animation:panelShowingMobile .25s ease}}.ce-popover__items{overflow-y:auto;-ms-scroll-chaining:none;overscroll-behavior:contain}@media (max-width: 650px){.ce-popover__overlay{position:fixed;top:0;bottom:0;left:0;right:0;background:#1D202B;z-index:3;opacity:.5;-webkit-transition:opacity .12s ease-in;transition:opacity .12s ease-in;will-change:opacity;visibility:visible}}.ce-popover__overlay--hidden{display:none}.ce-popover--open-top{top:calc(-1 * (var(--offset-from-target) + var(--popover-height)))}@media (max-width: 650px){.ce-popover{--offset: 5px;position:fixed;max-width:none;min-width:calc(100% - var(--offset) * 2);left:var(--offset);right:var(--offset);bottom:calc(var(--offset) + env(safe-area-inset-bottom));top:auto;border-radius:10px}.ce-popover .ce-popover__search{display:none}}.ce-popover__search,.ce-popover__custom-content:not(:empty){margin-bottom:5px}.ce-popover__nothing-found-message{color:#707684;display:none;cursor:default;padding:3px;font-size:14px;line-height:20px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ce-popover__nothing-found-message--displayed{display:block}.ce-popover__custom-content:not(:empty){padding:4px}@media (min-width: 651px){.ce-popover__custom-content:not(:empty){padding:0}}.ce-popover__custom-content--hidden{display:none}.ce-popover-item{--border-radius: 6px;--icon-size: 20px;--icon-size-mobile: 28px;border-radius:var(--border-radius);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:3px;color:var(--color-text-primary);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}@media (max-width: 650px){.ce-popover-item{padding:4px}}.ce-popover-item:not(:last-of-type){margin-bottom:1px}.ce-popover-item__icon{border-radius:5px;width:26px;height:26px;-webkit-box-shadow:0 0 0 1px var(--color-border-icon);box-shadow:0 0 0 1px var(--color-border-icon);background:#fff;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:10px}.ce-popover-item__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-popover-item__icon{width:36px;height:36px;border-radius:8px}.ce-popover-item__icon svg{width:var(--icon-size-mobile);height:var(--icon-size-mobile)}}.ce-popover-item__title{font-size:14px;line-height:20px;font-weight:500;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}@media (max-width: 650px){.ce-popover-item__title{font-size:16px}}.ce-popover-item__secondary-title{color:var(--color-text-secondary);font-size:12px;margin-left:auto;white-space:nowrap;letter-spacing:-.1em;padding-right:5px;margin-bottom:-2px;opacity:.6}@media (max-width: 650px){.ce-popover-item__secondary-title{display:none}}.ce-popover-item--active{background:var(--color-background-icon-active);color:var(--color-text-icon-active)}.ce-popover-item--active .ce-popover-item__icon{-webkit-box-shadow:none;box-shadow:none}.ce-popover-item--disabled{color:var(--color-text-secondary);cursor:default;pointer-events:none}.ce-popover-item--disabled .ce-popover-item__icon{-webkit-box-shadow:0 0 0 1px var(--color-border-icon-disabled);box-shadow:0 0 0 1px var(--color-border-icon-disabled)}.ce-popover-item--focused:not(.ce-popover-item--no-focus){background:var(--color-background-item-focus)!important}.ce-popover-item--focused:not(.ce-popover-item--no-focus){-webkit-box-shadow:inset 0 0 0px 1px var(--color-shadow-item-focus);box-shadow:inset 0 0 0 1px var(--color-shadow-item-focus)}.ce-popover-item--hidden{display:none}@media (hover: hover){.ce-popover-item:hover{cursor:pointer}.ce-popover-item:hover:not(.ce-popover-item--no-hover){background-color:var(--color-background-item-hover)}.ce-popover-item:hover .ce-popover-item__icon{-webkit-box-shadow:none;box-shadow:none}}.ce-popover-item--confirmation{background:var(--color-background-item-confirm)}.ce-popover-item--confirmation .ce-popover-item__icon{color:var(--color-background-item-confirm)}.ce-popover-item--confirmation .ce-popover-item__title{color:#fff}@media (hover: hover){.ce-popover-item--confirmation:not(.ce-popover-item--no-hover):hover{background:var(--color-background-item-confirm-hover)}}.ce-popover-item--confirmation:not(.ce-popover-item--no-focus).ce-popover-item--focused{background:var(--color-background-item-confirm-hover)!important}.ce-popover-item--confirmation .ce-popover-item__icon,.ce-popover-item--active .ce-popover-item__icon,.ce-popover-item--focused .ce-popover-item__icon{-webkit-box-shadow:none;box-shadow:none}@-webkit-keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}.wobble{-webkit-animation-name:wobble;animation-name:wobble;-webkit-animation-duration:.4s;animation-duration:.4s}@-webkit-keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}@keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}
`;
class wi extends y$1 {
  constructor() {
    super(...arguments), this.isMobile = false, this.contentRectCache = void 0, this.resizeDebouncer = et(() => {
      this.windowResize();
    }, 200);
  }
  /**
   * Editor.js UI CSS class names
   *
   * @returns {{editorWrapper: string, editorZone: string}}
   */
  get CSS() {
    return {
      editorWrapper: "codex-editor",
      editorWrapperNarrow: "codex-editor--narrow",
      editorZone: "codex-editor__redactor",
      editorZoneHidden: "codex-editor__redactor--hidden",
      editorEmpty: "codex-editor--empty",
      editorRtlFix: "codex-editor--rtl"
    };
  }
  /**
   * Return Width of center column of Editor
   *
   * @returns {DOMRect}
   */
  get contentRect() {
    if (this.contentRectCache)
      return this.contentRectCache;
    const e2 = this.nodes.wrapper.querySelector(`.${R$3.CSS.content}`);
    return e2 ? (this.contentRectCache = e2.getBoundingClientRect(), this.contentRectCache) : {
      width: 650,
      left: 0,
      right: 0
    };
  }
  /**
   * Making main interface
   */
  async prepare() {
    this.checkIsMobile(), this.make(), this.loadStyles();
  }
  /**
   * Toggle read-only state
   *
   * If readOnly is true:
   *  - removes all listeners from main UI module elements
   *
   * if readOnly is false:
   *  - enables all listeners to UI module elements
   *
   * @param {boolean} readOnlyEnabled - "read only" state
   */
  toggleReadOnly(e2) {
    e2 ? this.disableModuleBindings() : window.requestIdleCallback(() => {
      this.enableModuleBindings();
    }, {
      timeout: 2e3
    });
  }
  /**
   * Check if Editor is empty and set CSS class to wrapper
   */
  checkEmptiness() {
    const { BlockManager: e2 } = this.Editor;
    this.nodes.wrapper.classList.toggle(this.CSS.editorEmpty, e2.isEditorEmpty);
  }
  /**
   * Check if one of Toolbar is opened
   * Used to prevent global keydowns (for example, Enter) conflicts with Enter-on-toolbar
   *
   * @returns {boolean}
   */
  get someToolbarOpened() {
    const { Toolbar: e2, BlockSettings: t2, InlineToolbar: o3, ConversionToolbar: i2 } = this.Editor;
    return t2.opened || o3.opened || i2.opened || e2.toolbox.opened;
  }
  /**
   * Check for some Flipper-buttons is under focus
   */
  get someFlipperButtonFocused() {
    return this.Editor.Toolbar.toolbox.hasFocus() ? true : Object.entries(this.Editor).filter(([e2, t2]) => t2.flipper instanceof q).some(([e2, t2]) => t2.flipper.hasFocus());
  }
  /**
   * Clean editor`s UI
   */
  destroy() {
    this.nodes.holder.innerHTML = "";
  }
  /**
   * Close all Editor's toolbars
   */
  closeAllToolbars() {
    const { Toolbar: e2, BlockSettings: t2, InlineToolbar: o3, ConversionToolbar: i2 } = this.Editor;
    t2.close(), o3.close(), i2.close(), e2.toolbox.close();
  }
  /**
   * Check for mobile mode and cache a result
   */
  checkIsMobile() {
    this.isMobile = window.innerWidth < dt;
  }
  /**
   * Makes Editor.js interface
   */
  make() {
    this.nodes.holder = c$4.getHolder(this.config.holder), this.nodes.wrapper = c$4.make("div", [
      this.CSS.editorWrapper,
      ...this.isRtl ? [this.CSS.editorRtlFix] : []
    ]), this.nodes.redactor = c$4.make("div", this.CSS.editorZone), this.nodes.holder.offsetWidth < this.contentRect.width && this.nodes.wrapper.classList.add(this.CSS.editorWrapperNarrow), this.nodes.redactor.style.paddingBottom = this.config.minHeight + "px", this.nodes.wrapper.appendChild(this.nodes.redactor), this.nodes.holder.appendChild(this.nodes.wrapper);
  }
  /**
   * Appends CSS
   */
  loadStyles() {
    const e2 = "editor-js-styles";
    if (c$4.get(e2))
      return;
    const t2 = c$4.make("style", null, {
      id: e2,
      textContent: xi.toString()
    });
    this.config.style && !W(this.config.style) && this.config.style.nonce && t2.setAttribute("nonce", this.config.style.nonce), c$4.prepend(document.head, t2);
  }
  /**
   * Bind events on the Editor.js interface
   */
  enableModuleBindings() {
    this.readOnlyMutableListeners.on(this.nodes.redactor, "click", (o3) => {
      this.redactorClicked(o3);
    }, false), this.readOnlyMutableListeners.on(this.nodes.redactor, "mousedown", (o3) => {
      this.documentTouched(o3);
    }, {
      capture: true,
      passive: true
    }), this.readOnlyMutableListeners.on(this.nodes.redactor, "touchstart", (o3) => {
      this.documentTouched(o3);
    }, {
      capture: true,
      passive: true
    }), this.readOnlyMutableListeners.on(document, "keydown", (o3) => {
      this.documentKeydown(o3);
    }, true), this.readOnlyMutableListeners.on(document, "mousedown", (o3) => {
      this.documentClicked(o3);
    }, true);
    const t2 = et(() => {
      this.selectionChanged();
    }, 180);
    this.readOnlyMutableListeners.on(document, "selectionchange", t2, true), this.readOnlyMutableListeners.on(window, "resize", () => {
      this.resizeDebouncer();
    }, {
      passive: true
    }), this.watchBlockHoveredEvents();
  }
  /**
   * Listen redactor mousemove to emit 'block-hovered' event
   */
  watchBlockHoveredEvents() {
    let e2;
    this.readOnlyMutableListeners.on(this.nodes.redactor, "mousemove", Ie((t2) => {
      const o3 = t2.target.closest(".ce-block");
      this.Editor.BlockSelection.anyBlockSelected || o3 && e2 !== o3 && (e2 = o3, this.eventsDispatcher.emit(yt, {
        block: this.Editor.BlockManager.getBlockByChildNode(o3)
      }));
    }, 20), {
      passive: true
    });
  }
  /**
   * Unbind events on the Editor.js interface
   */
  disableModuleBindings() {
    this.readOnlyMutableListeners.clearAll();
  }
  /**
   * Resize window handler
   */
  windowResize() {
    this.contentRectCache = null, this.checkIsMobile();
  }
  /**
   * All keydowns on document
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  documentKeydown(e2) {
    switch (e2.keyCode) {
      case v$1.ENTER:
        this.enterPressed(e2);
        break;
      case v$1.BACKSPACE:
      case v$1.DELETE:
        this.backspacePressed(e2);
        break;
      case v$1.ESC:
        this.escapePressed(e2);
        break;
      default:
        this.defaultBehaviour(e2);
        break;
    }
  }
  /**
   * Ignore all other document's keydown events
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  defaultBehaviour(e2) {
    const { currentBlock: t2 } = this.Editor.BlockManager, o3 = e2.target.closest(`.${this.CSS.editorWrapper}`), i2 = e2.altKey || e2.ctrlKey || e2.metaKey || e2.shiftKey;
    if (t2 !== void 0 && o3 === null) {
      this.Editor.BlockEvents.keydown(e2);
      return;
    }
    o3 || t2 && i2 || (this.Editor.BlockManager.dropPointer(), this.Editor.Toolbar.close());
  }
  /**
   * @param {KeyboardEvent} event - keyboard event
   */
  backspacePressed(e2) {
    const { BlockManager: t2, BlockSelection: o3, Caret: i2 } = this.Editor;
    if (o3.anyBlockSelected && !b$1.isSelectionExists) {
      const n3 = t2.removeSelectedBlocks(), r4 = t2.insertDefaultBlockAtIndex(n3, true);
      i2.setToBlock(r4, i2.positions.START), o3.clearSelection(e2), e2.preventDefault(), e2.stopPropagation(), e2.stopImmediatePropagation();
    }
  }
  /**
   * Escape pressed
   * If some of Toolbar components are opened, then close it otherwise close Toolbar
   *
   * @param {Event} event - escape keydown event
   */
  escapePressed(e2) {
    this.Editor.BlockSelection.clearSelection(e2), this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.toolbox.close(), this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END)) : this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.ConversionToolbar.opened ? this.Editor.ConversionToolbar.close() : this.Editor.InlineToolbar.opened ? this.Editor.InlineToolbar.close() : this.Editor.Toolbar.close();
  }
  /**
   * Enter pressed on document
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  enterPressed(e2) {
    const { BlockManager: t2, BlockSelection: o3 } = this.Editor, i2 = t2.currentBlockIndex >= 0;
    if (o3.anyBlockSelected && !b$1.isSelectionExists) {
      o3.clearSelection(e2), e2.preventDefault(), e2.stopImmediatePropagation(), e2.stopPropagation();
      return;
    }
    if (!this.someToolbarOpened && i2 && e2.target.tagName === "BODY") {
      const n3 = this.Editor.BlockManager.insert();
      this.Editor.Caret.setToBlock(n3), this.Editor.Toolbar.moveAndOpen(n3);
    }
    this.Editor.BlockSelection.clearSelection(e2);
  }
  /**
   * All clicks on document
   *
   * @param {MouseEvent} event - Click event
   */
  documentClicked(e2) {
    var a3, l2;
    if (!e2.isTrusted)
      return;
    const t2 = e2.target;
    this.nodes.holder.contains(t2) || b$1.isAtEditor || (this.Editor.BlockManager.dropPointer(), this.Editor.Toolbar.close());
    const i2 = (a3 = this.Editor.BlockSettings.nodes.wrapper) == null ? void 0 : a3.contains(t2), n3 = (l2 = this.Editor.Toolbar.nodes.settingsToggler) == null ? void 0 : l2.contains(t2), r4 = i2 || n3;
    if (this.Editor.BlockSettings.opened && !r4) {
      this.Editor.BlockSettings.close();
      const d4 = this.Editor.BlockManager.getBlockByChildNode(t2);
      this.Editor.Toolbar.moveAndOpen(d4);
    }
    this.Editor.BlockSelection.clearSelection(e2);
  }
  /**
   * First touch on editor
   * Fired before click
   *
   * Used to change current block — we need to do it before 'selectionChange' event.
   * Also:
   * - Move and show the Toolbar
   * - Set a Caret
   *
   * @param {MouseEvent | TouchEvent} event - touch or mouse event
   */
  documentTouched(e2) {
    let t2 = e2.target;
    if (t2 === this.nodes.redactor) {
      const o3 = e2 instanceof MouseEvent ? e2.clientX : e2.touches[0].clientX, i2 = e2 instanceof MouseEvent ? e2.clientY : e2.touches[0].clientY;
      t2 = document.elementFromPoint(o3, i2);
    }
    try {
      this.Editor.BlockManager.setCurrentBlockByChildNode(t2);
    } catch {
      this.Editor.RectangleSelection.isRectActivated() || this.Editor.Caret.setToTheLastBlock();
    }
    this.Editor.Toolbar.moveAndOpen();
  }
  /**
   * All clicks on the redactor zone
   *
   * @param {MouseEvent} event - click event
   * @description
   * - By clicks on the Editor's bottom zone:
   *      - if last Block is empty, set a Caret to this
   *      - otherwise, add a new empty Block and set a Caret to that
   */
  redactorClicked(e2) {
    if (!b$1.isCollapsed)
      return;
    const t2 = e2.target, o3 = e2.metaKey || e2.ctrlKey;
    if (c$4.isAnchor(t2) && o3) {
      e2.stopImmediatePropagation(), e2.stopPropagation();
      const i2 = t2.getAttribute("href"), n3 = Wt(i2);
      Kt(n3);
      return;
    }
    this.processBottomZoneClick(e2);
  }
  /**
   * Check if user clicks on the Editor's bottom zone:
   *  - set caret to the last block
   *  - or add new empty block
   *
   * @param event - click event
   */
  processBottomZoneClick(e2) {
    const t2 = this.Editor.BlockManager.getBlockByIndex(-1), o3 = c$4.offset(t2.holder).bottom, i2 = e2.pageY, { BlockSelection: n3 } = this.Editor;
    if (e2.target instanceof Element && e2.target.isEqualNode(this.nodes.redactor) && /**
    * If there is cross block selection started, target will be equal to redactor so we need additional check
    */
    !n3.anyBlockSelected && /**
    * Prevent caret jumping (to last block) when clicking between blocks
    */
    o3 < i2) {
      e2.stopImmediatePropagation(), e2.stopPropagation();
      const { BlockManager: a3, Caret: l2, Toolbar: d4 } = this.Editor;
      (!a3.lastBlock.tool.isDefault || !a3.lastBlock.isEmpty) && a3.insertAtEnd(), l2.setToTheLastBlock(), d4.moveAndOpen(a3.lastBlock);
    }
  }
  /**
   * Handle selection changes on mobile devices
   * Uses for showing the Inline Toolbar
   */
  selectionChanged() {
    const { CrossBlockSelection: e2, BlockSelection: t2 } = this.Editor, o3 = b$1.anchorElement;
    if (e2.isCrossBlockSelectionStarted && t2.anyBlockSelected && b$1.get().removeAllRanges(), !o3) {
      b$1.range || this.Editor.InlineToolbar.close();
      return;
    }
    const i2 = o3.closest(`.${R$3.CSS.content}`) === null;
    if (i2 && (this.Editor.InlineToolbar.containsNode(o3) || this.Editor.InlineToolbar.close(), !(o3.dataset.inlineToolbar === "true")))
      return;
    this.Editor.BlockManager.currentBlock || this.Editor.BlockManager.setCurrentBlockByChildNode(o3);
    const n3 = i2 !== true;
    this.Editor.InlineToolbar.tryToShow(true, n3);
  }
}
const yi = {
  // API Modules
  BlocksAPI: oo,
  CaretAPI: io,
  EventsAPI: no,
  I18nAPI: He,
  API: so,
  InlineToolbarAPI: ro,
  ListenersAPI: ao,
  NotifierAPI: uo,
  ReadOnlyAPI: po,
  SanitizerAPI: xo,
  SaverAPI: wo,
  SelectionAPI: yo,
  StylesAPI: Eo,
  ToolbarAPI: Bo,
  TooltipAPI: Mo,
  UiAPI: Lo,
  // Toolbar Modules
  BlockSettings: Yo,
  ConversionToolbar: $,
  Toolbar: Jo,
  InlineToolbar: Qo,
  // Modules
  BlockEvents: ei,
  BlockManager: ii,
  BlockSelection: ni,
  Caret: we,
  CrossBlockSelection: si,
  DragNDrop: ri,
  ModificationsObserver: ai,
  Paste: Tt,
  ReadOnly: li,
  RectangleSelection: fe,
  Renderer: ci,
  Saver: di,
  Tools: _t,
  UI: wi
};
class Ei {
  /**
   * @param {EditorConfig} config - user configuration
   */
  constructor(e2) {
    this.moduleInstances = {}, this.eventsDispatcher = new Ee();
    let t2, o3;
    this.isReady = new Promise((i2, n3) => {
      t2 = i2, o3 = n3;
    }), Promise.resolve().then(async () => {
      this.configuration = e2, this.validate(), this.init(), await this.start(), await this.render();
      const { BlockManager: i2, Caret: n3, UI: r4, ModificationsObserver: a3 } = this.moduleInstances;
      r4.checkEmptiness(), a3.enable(), this.configuration.autofocus && n3.setToBlock(i2.blocks[0], n3.positions.START), t2();
    }).catch((i2) => {
      T$1(`Editor.js is not ready because of ${i2}`, "error"), o3(i2);
    });
  }
  /**
   * Setting for configuration
   *
   * @param {EditorConfig|string} config - Editor's config to set
   */
  set configuration(e2) {
    var o3, i2;
    D$1(e2) ? this.config = {
      ...e2
    } : this.config = {
      holder: e2
    }, Le(!!this.config.holderId, "config.holderId", "config.holder"), this.config.holderId && !this.config.holder && (this.config.holder = this.config.holderId, this.config.holderId = null), this.config.holder == null && (this.config.holder = "editorjs"), this.config.logLevel || (this.config.logLevel = at.VERBOSE), Ft(this.config.logLevel), Le(!!this.config.initialBlock, "config.initialBlock", "config.defaultBlock"), this.config.defaultBlock = this.config.defaultBlock || this.config.initialBlock || "paragraph", this.config.minHeight = this.config.minHeight !== void 0 ? this.config.minHeight : 300;
    const t2 = {
      type: this.config.defaultBlock,
      data: {}
    };
    this.config.placeholder = this.config.placeholder || false, this.config.sanitizer = this.config.sanitizer || {
      p: true,
      b: true,
      a: true
    }, this.config.hideToolbar = this.config.hideToolbar ? this.config.hideToolbar : false, this.config.tools = this.config.tools || {}, this.config.i18n = this.config.i18n || {}, this.config.data = this.config.data || { blocks: [] }, this.config.onReady = this.config.onReady || (() => {
    }), this.config.onChange = this.config.onChange || (() => {
    }), this.config.inlineToolbar = this.config.inlineToolbar !== void 0 ? this.config.inlineToolbar : true, (W(this.config.data) || !this.config.data.blocks || this.config.data.blocks.length === 0) && (this.config.data = { blocks: [t2] }), this.config.readOnly = this.config.readOnly || false, (o3 = this.config.i18n) != null && o3.messages && z.setDictionary(this.config.i18n.messages), this.config.i18n.direction = ((i2 = this.config.i18n) == null ? void 0 : i2.direction) || "ltr";
  }
  /**
   * Returns private property
   *
   * @returns {EditorConfig}
   */
  get configuration() {
    return this.config;
  }
  /**
   * Checks for required fields in Editor's config
   */
  validate() {
    const { holderId: e2, holder: t2 } = this.config;
    if (e2 && t2)
      throw Error("«holderId» and «holder» param can't assign at the same time.");
    if (G(t2) && !c$4.get(t2))
      throw Error(`element with ID «${t2}» is missing. Pass correct holder's ID.`);
    if (t2 && D$1(t2) && !c$4.isElement(t2))
      throw Error("«holder» value must be an Element node");
  }
  /**
   * Initializes modules:
   *  - make and save instances
   *  - configure
   */
  init() {
    this.constructModules(), this.configureModules();
  }
  /**
   * Start Editor!
   *
   * Get list of modules that needs to be prepared and return a sequence (Promise)
   *
   * @returns {Promise<void>}
   */
  async start() {
    await [
      "Tools",
      "UI",
      "BlockManager",
      "Paste",
      "BlockSelection",
      "RectangleSelection",
      "CrossBlockSelection",
      "ReadOnly"
    ].reduce(
      (t2, o3) => t2.then(async () => {
        try {
          await this.moduleInstances[o3].prepare();
        } catch (i2) {
          if (i2 instanceof ut)
            throw new Error(i2.message);
          T$1(`Module ${o3} was skipped because of %o`, "warn", i2);
        }
      }),
      Promise.resolve()
    );
  }
  /**
   * Render initial data
   */
  render() {
    return this.moduleInstances.Renderer.render(this.config.data.blocks);
  }
  /**
   * Make modules instances and save it to the @property this.moduleInstances
   */
  constructModules() {
    Object.entries(yi).forEach(([e2, t2]) => {
      try {
        this.moduleInstances[e2] = new t2({
          config: this.configuration,
          eventsDispatcher: this.eventsDispatcher
        });
      } catch (o3) {
        T$1("[constructModules]", `Module ${e2} skipped because`, "error", o3);
      }
    });
  }
  /**
   * Modules instances configuration:
   *  - pass other modules to the 'state' property
   *  - ...
   */
  configureModules() {
    for (const e2 in this.moduleInstances)
      Object.prototype.hasOwnProperty.call(this.moduleInstances, e2) && (this.moduleInstances[e2].state = this.getModulesDiff(e2));
  }
  /**
   * Return modules without passed name
   *
   * @param {string} name - module for witch modules difference should be calculated
   */
  getModulesDiff(e2) {
    const t2 = {};
    for (const o3 in this.moduleInstances)
      o3 !== e2 && (t2[o3] = this.moduleInstances[o3]);
    return t2;
  }
}
/**
 * Editor.js
 *
 * @license Apache-2.0
 * @see Editor.js <https://editorjs.io>
 * @author CodeX Team <https://codex.so>
 */
class Bi {
  /** Editor version */
  static get version() {
    return "2.29.1";
  }
  /**
   * @param {EditorConfig|string|undefined} [configuration] - user configuration
   */
  constructor(e2) {
    let t2 = () => {
    };
    D$1(e2) && M$2(e2.onReady) && (t2 = e2.onReady);
    const o3 = new Ei(e2);
    this.isReady = o3.isReady.then(() => {
      this.exportAPI(o3), t2();
    });
  }
  /**
   * Export external API methods
   *
   * @param {Core} editor — Editor's instance
   */
  exportAPI(e2) {
    const t2 = ["configuration"], o3 = () => {
      Object.values(e2.moduleInstances).forEach((n3) => {
        M$2(n3.destroy) && n3.destroy(), n3.listeners.removeAll();
      }), Io(), e2 = null;
      for (const n3 in this)
        Object.prototype.hasOwnProperty.call(this, n3) && delete this[n3];
      Object.setPrototypeOf(this, null);
    };
    t2.forEach((n3) => {
      this[n3] = e2[n3];
    }), this.destroy = o3, Object.setPrototypeOf(this, e2.moduleInstances.API.methods), delete this.exportAPI, Object.entries({
      blocks: {
        clear: "clear",
        render: "render"
      },
      caret: {
        focus: "focus"
      },
      events: {
        on: "on",
        off: "off",
        emit: "emit"
      },
      saver: {
        save: "save"
      }
    }).forEach(([n3, r4]) => {
      Object.entries(r4).forEach(([a3, l2]) => {
        this[l2] = e2.moduleInstances.API.methods[n3][a3];
      });
    });
  }
}
(function() {
  try {
    if (typeof document < "u") {
      var e2 = document.createElement("style");
      e2.appendChild(document.createTextNode(".ce-paragraph{line-height:1.6em;outline:none}.ce-paragraph[data-placeholder]:empty:before{content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:before{opacity:1}.codex-editor--toolbox-opened .ce-block:first-child .ce-paragraph[data-placeholder]:empty:before,.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:focus:before{opacity:0}.ce-paragraph p:first-of-type{margin-top:0}.ce-paragraph p:last-of-type{margin-bottom:0}")), document.head.appendChild(e2);
    }
  } catch (t2) {
    console.error("vite-plugin-css-injected-by-js", t2);
  }
})();
const s$3 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14"/></svg>';
function o$5(r4) {
  const t2 = document.createElement("div");
  t2.innerHTML = r4.trim();
  const e2 = document.createDocumentFragment();
  return e2.append(...Array.from(t2.childNodes)), e2;
}
/**
 * Base Paragraph Block for the Editor.js.
 * Represents a regular text block
 *
 * @author CodeX (team@codex.so)
 * @copyright CodeX 2018
 * @license The MIT License (MIT)
 */
let n$1 = class n {
  /**
   * Default placeholder for Paragraph Tool
   *
   * @returns {string}
   * @class
   */
  static get DEFAULT_PLACEHOLDER() {
    return "";
  }
  /**
   * Render plugin`s main Element and fill it with saved data
   *
   * @param {object} params - constructor params
   * @param {ParagraphData} params.data - previously saved data
   * @param {ParagraphConfig} params.config - user config for Tool
   * @param {object} params.api - editor.js api
   * @param {boolean} readOnly - read only mode flag
   */
  constructor({ data: t2, config: e2, api: i2, readOnly: a3 }) {
    this.api = i2, this.readOnly = a3, this._CSS = {
      block: this.api.styles.block,
      wrapper: "ce-paragraph"
    }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = e2.placeholder ? e2.placeholder : n.DEFAULT_PLACEHOLDER, this._data = t2 ?? {}, this._element = null, this._preserveBlank = e2.preserveBlank !== void 0 ? e2.preserveBlank : false;
  }
  /**
   * Check if text content is empty and set empty string to inner html.
   * We need this because some browsers (e.g. Safari) insert <br> into empty contenteditanle elements
   *
   * @param {KeyboardEvent} e - key up event
   */
  onKeyUp(t2) {
    if (t2.code !== "Backspace" && t2.code !== "Delete")
      return;
    const { textContent: e2 } = this._element;
    e2 === "" && (this._element.innerHTML = "");
  }
  /**
   * Create Tool's view
   *
   * @returns {HTMLElement}
   * @private
   */
  drawView() {
    const t2 = document.createElement("DIV");
    return t2.classList.add(this._CSS.wrapper, this._CSS.block), t2.contentEditable = false, t2.dataset.placeholder = this.api.i18n.t(this._placeholder), this._data.text && (t2.innerHTML = this._data.text), this.readOnly || (t2.contentEditable = true, t2.addEventListener("keyup", this.onKeyUp)), t2;
  }
  /**
   * Return Tool's view
   *
   * @returns {HTMLDivElement}
   */
  render() {
    return this._element = this.drawView(), this._element;
  }
  /**
   * Method that specified how to merge two Text blocks.
   * Called by Editor.js by backspace at the beginning of the Block
   *
   * @param {ParagraphData} data
   * @public
   */
  merge(t2) {
    this._data.text += t2.text;
    const e2 = o$5(t2.text);
    this._element.appendChild(e2), this._element.normalize();
  }
  /**
   * Validate Paragraph block data:
   * - check for emptiness
   *
   * @param {ParagraphData} savedData — data received after saving
   * @returns {boolean} false if saved data is not correct, otherwise true
   * @public
   */
  validate(t2) {
    return !(t2.text.trim() === "" && !this._preserveBlank);
  }
  /**
   * Extract Tool's data from the view
   *
   * @param {HTMLDivElement} toolsContent - Paragraph tools rendered view
   * @returns {ParagraphData} - saved data
   * @public
   */
  save(t2) {
    return {
      text: t2.innerHTML
    };
  }
  /**
   * On paste callback fired from Editor.
   *
   * @param {PasteEvent} event - event with pasted data
   */
  onPaste(t2) {
    const e2 = {
      text: t2.detail.data.innerHTML
    };
    this._data = e2, window.requestAnimationFrame(() => {
      this._element.innerHTML = this._data.text || "";
    });
  }
  /**
   * Enable Conversion Toolbar. Paragraph can be converted to/from other tools
   */
  static get conversionConfig() {
    return {
      export: "text",
      // to convert Paragraph to other block, use 'text' property of saved data
      import: "text"
      // to covert other block's exported string to Paragraph, fill 'text' property of tool data
    };
  }
  /**
   * Sanitizer rules
   */
  static get sanitize() {
    return {
      text: {
        br: true
      }
    };
  }
  /**
   * Returns true to notify the core that read-only mode is supported
   *
   * @returns {boolean}
   */
  static get isReadOnlySupported() {
    return true;
  }
  /**
   * Used by Editor paste handling API.
   * Provides configuration to handle P tags.
   *
   * @returns {{tags: string[]}}
   */
  static get pasteConfig() {
    return {
      tags: ["P"]
    };
  }
  /**
   * Icon and title for displaying at the Toolbox
   *
   * @returns {{icon: string, title: string}}
   */
  static get toolbox() {
    return {
      icon: s$3,
      title: "Text"
    };
  }
};
(function() {
  try {
    if (typeof document < "u") {
      var e2 = document.createElement("style");
      e2.appendChild(document.createTextNode('.embed-tool--loading .embed-tool__caption{display:none}.embed-tool--loading .embed-tool__preloader{display:block}.embed-tool--loading .embed-tool__content{display:none}.embed-tool__preloader{display:none;position:relative;height:200px;box-sizing:border-box;border-radius:5px;border:1px solid #e6e9eb}.embed-tool__preloader:before{content:"";position:absolute;z-index:3;left:50%;top:50%;width:30px;height:30px;margin-top:-25px;margin-left:-15px;border-radius:50%;border:2px solid #cdd1e0;border-top-color:#388ae5;box-sizing:border-box;animation:embed-preloader-spin 2s infinite linear}.embed-tool__url{position:absolute;bottom:20px;left:50%;transform:translate(-50%);max-width:250px;color:#7b7e89;font-size:11px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.embed-tool__content{width:100%}.embed-tool__caption{margin-top:7px}.embed-tool__caption[contentEditable=true][data-placeholder]:before{position:absolute;content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.embed-tool__caption[contentEditable=true][data-placeholder]:empty:before{opacity:1}.embed-tool__caption[contentEditable=true][data-placeholder]:empty:focus:before{opacity:0}@keyframes embed-preloader-spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}')), document.head.appendChild(e2);
    }
  } catch (o3) {
    console.error("vite-plugin-css-injected-by-js", o3);
  }
})();
const g$2 = {
  vimeo: {
    regex: /(?:http[s]?:\/\/)?(?:www.)?(?:player.)?vimeo\.co(?:.+\/([^\/]\d+)(?:#t=[\d]+)?s?$)/,
    embedUrl: "https://player.vimeo.com/video/<%= remote_id %>?title=0&byline=0",
    html: '<iframe style="width:100%;" height="320" frameborder="0"></iframe>',
    height: 320,
    width: 580
  },
  youtube: {
    regex: /(?:https?:\/\/)?(?:www\.)?(?:(?:youtu\.be\/)|(?:youtube\.com)\/(?:v\/|u\/\w\/|embed\/|watch))(?:(?:\?v=)?([^#&?=]*))?((?:[?&]\w*=\w*)*)/,
    embedUrl: "https://www.youtube.com/embed/<%= remote_id %>",
    html: '<iframe style="width:100%;" height="320" frameborder="0" allowfullscreen></iframe>',
    height: 320,
    width: 580,
    id: ([o3, t2]) => {
      if (!t2 && o3)
        return o3;
      const i2 = {
        start: "start",
        end: "end",
        t: "start",
        // eslint-disable-next-line camelcase
        time_continue: "start",
        list: "list"
      };
      return t2 = t2.slice(1).split("&").map((e2) => {
        const [s4, n3] = e2.split("=");
        return !o3 && s4 === "v" ? (o3 = n3, null) : !i2[s4] || n3 === "LL" || n3.startsWith("RDMM") || n3.startsWith("FL") ? null : `${i2[s4]}=${n3}`;
      }).filter((e2) => !!e2), o3 + "?" + t2.join("&");
    }
  },
  coub: {
    regex: /https?:\/\/coub\.com\/view\/([^\/\?\&]+)/,
    embedUrl: "https://coub.com/embed/<%= remote_id %>",
    html: '<iframe style="width:100%;" height="320" frameborder="0" allowfullscreen></iframe>',
    height: 320,
    width: 580
  },
  vine: {
    regex: /https?:\/\/vine\.co\/v\/([^\/\?\&]+)/,
    embedUrl: "https://vine.co/v/<%= remote_id %>/embed/simple/",
    html: '<iframe style="width:100%;" height="320" frameborder="0" allowfullscreen></iframe>',
    height: 320,
    width: 580
  },
  imgur: {
    regex: /https?:\/\/(?:i\.)?imgur\.com.*\/([a-zA-Z0-9]+)(?:\.gifv)?/,
    embedUrl: "http://imgur.com/<%= remote_id %>/embed",
    html: '<iframe allowfullscreen="true" scrolling="no" id="imgur-embed-iframe-pub-<%= remote_id %>" class="imgur-embed-iframe-pub" style="height: 500px; width: 100%; border: 1px solid #000"></iframe>',
    height: 500,
    width: 540
  },
  gfycat: {
    regex: /https?:\/\/gfycat\.com(?:\/detail)?\/([a-zA-Z]+)/,
    embedUrl: "https://gfycat.com/ifr/<%= remote_id %>",
    html: `<iframe frameborder='0' scrolling='no' style="width:100%;" height='436' allowfullscreen ></iframe>`,
    height: 436,
    width: 580
  },
  "twitch-channel": {
    regex: /https?:\/\/www\.twitch\.tv\/([^\/\?\&]*)\/?$/,
    embedUrl: "https://player.twitch.tv/?channel=<%= remote_id %>",
    html: '<iframe frameborder="0" allowfullscreen="true" scrolling="no" height="366" style="width:100%;"></iframe>',
    height: 366,
    width: 600
  },
  "twitch-video": {
    regex: /https?:\/\/www\.twitch\.tv\/(?:[^\/\?\&]*\/v|videos)\/([0-9]*)/,
    embedUrl: "https://player.twitch.tv/?video=v<%= remote_id %>",
    html: '<iframe frameborder="0" allowfullscreen="true" scrolling="no" height="366" style="width:100%;"></iframe>',
    height: 366,
    width: 600
  },
  "yandex-music-album": {
    regex: /https?:\/\/music\.yandex\.ru\/album\/([0-9]*)\/?$/,
    embedUrl: "https://music.yandex.ru/iframe/#album/<%= remote_id %>/",
    html: '<iframe frameborder="0" style="border:none;width:540px;height:400px;" style="width:100%;" height="400"></iframe>',
    height: 400,
    width: 540
  },
  "yandex-music-track": {
    regex: /https?:\/\/music\.yandex\.ru\/album\/([0-9]*)\/track\/([0-9]*)/,
    embedUrl: "https://music.yandex.ru/iframe/#track/<%= remote_id %>/",
    html: '<iframe frameborder="0" style="border:none;width:540px;height:100px;" style="width:100%;" height="100"></iframe>',
    height: 100,
    width: 540,
    id: (o3) => o3.join("/")
  },
  "yandex-music-playlist": {
    regex: /https?:\/\/music\.yandex\.ru\/users\/([^\/\?\&]*)\/playlists\/([0-9]*)/,
    embedUrl: "https://music.yandex.ru/iframe/#playlist/<%= remote_id %>/show/cover/description/",
    html: '<iframe frameborder="0" style="border:none;width:540px;height:400px;" width="540" height="400"></iframe>',
    height: 400,
    width: 540,
    id: (o3) => o3.join("/")
  },
  codepen: {
    regex: /https?:\/\/codepen\.io\/([^\/\?\&]*)\/pen\/([^\/\?\&]*)/,
    embedUrl: "https://codepen.io/<%= remote_id %>?height=300&theme-id=0&default-tab=css,result&embed-version=2",
    html: "<iframe height='300' scrolling='no' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'></iframe>",
    height: 300,
    width: 600,
    id: (o3) => o3.join("/embed/")
  },
  instagram: {
    regex: /https?:\/\/www\.instagram\.com\/p\/([^\/\?\&]+)\/?.*/,
    embedUrl: "https://www.instagram.com/p/<%= remote_id %>/embed",
    html: '<iframe width="400" height="505" style="margin: 0 auto;" frameborder="0" scrolling="no" allowtransparency="true"></iframe>',
    height: 505,
    width: 400
  },
  twitter: {
    regex: /^https?:\/\/(www\.)?twitter\.com\/.+\/status\/(\d+)/,
    embedUrl: "https://platform.twitter.com/embed/Tweet.html?id=<%= remote_id %>",
    html: '<iframe width="600" height="600" style="margin: 0 auto;" frameborder="0" scrolling="no" allowtransparency="true"></iframe>',
    height: 300,
    width: 600,
    id: (o3) => o3[1]
  },
  pinterest: {
    regex: /https?:\/\/([^\/\?\&]*).pinterest.com\/pin\/([^\/\?\&]*)\/?$/,
    embedUrl: "https://assets.pinterest.com/ext/embed.html?id=<%= remote_id %>",
    html: "<iframe scrolling='no' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%; min-height: 400px; max-height: 1000px;'></iframe>",
    id: (o3) => o3[1]
  },
  facebook: {
    regex: /https?:\/\/www.facebook.com\/([^\/\?\&]*)\/(.*)/,
    embedUrl: "https://www.facebook.com/plugins/post.php?href=https://www.facebook.com/<%= remote_id %>&width=500",
    html: "<iframe scrolling='no' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%; min-height: 500px; max-height: 1000px;'></iframe>",
    id: (o3) => o3.join("/")
  },
  aparat: {
    regex: /(?:http[s]?:\/\/)?(?:www.)?aparat\.com\/v\/([^\/\?\&]+)\/?/,
    embedUrl: "https://www.aparat.com/video/video/embed/videohash/<%= remote_id %>/vt/frame",
    html: '<iframe width="600" height="300" style="margin: 0 auto;" frameborder="0" scrolling="no" allowtransparency="true"></iframe>',
    height: 300,
    width: 600
  },
  miro: {
    regex: /https:\/\/miro.com\/\S+(\S{12})\/(\S+)?/,
    embedUrl: "https://miro.com/app/live-embed/<%= remote_id %>",
    html: '<iframe width="700" height="500" style="margin: 0 auto;" allowFullScreen frameBorder="0" scrolling="no"></iframe>'
  },
  github: {
    regex: /https?:\/\/gist.github.com\/([^\/\?\&]*)\/([^\/\?\&]*)/,
    embedUrl: 'data:text/html;charset=utf-8,<head><base target="_blank" /></head><body><script src="https://gist.github.com/<%= remote_id %>" ><\/script></body>',
    html: '<iframe width="100%" height="350" frameborder="0" style="margin: 0 auto;"></iframe>',
    height: 300,
    width: 600,
    id: (o3) => `${o3.join("/")}.js`
  }
};
function u$2(o3, t2, i2) {
  var e2, s4, n3, r4, a3;
  t2 == null && (t2 = 100);
  function l2() {
    var h2 = Date.now() - r4;
    h2 < t2 && h2 >= 0 ? e2 = setTimeout(l2, t2 - h2) : (e2 = null, i2 || (a3 = o3.apply(n3, s4), n3 = s4 = null));
  }
  var d4 = function() {
    n3 = this, s4 = arguments, r4 = Date.now();
    var h2 = i2 && !e2;
    return e2 || (e2 = setTimeout(l2, t2)), h2 && (a3 = o3.apply(n3, s4), n3 = s4 = null), a3;
  };
  return d4.clear = function() {
    e2 && (clearTimeout(e2), e2 = null);
  }, d4.flush = function() {
    e2 && (a3 = o3.apply(n3, s4), n3 = s4 = null, clearTimeout(e2), e2 = null);
  }, d4;
}
u$2.debounce = u$2;
var w = u$2;
let m$2 = class m {
  /**
   * @param {{data: EmbedData, config: EmbedConfig, api: object}}
   *   data — previously saved data
   *   config - user config for Tool
   *   api - Editor.js API
   *   readOnly - read-only mode flag
   */
  constructor({ data: t2, api: i2, readOnly: e2 }) {
    this.api = i2, this._data = {}, this.element = null, this.readOnly = e2, this.data = t2;
  }
  /**
   * @param {EmbedData} data - embed data
   * @param {RegExp} [data.regex] - pattern of source URLs
   * @param {string} [data.embedUrl] - URL scheme to embedded page. Use '<%= remote_id %>' to define a place to insert resource id
   * @param {string} [data.html] - iframe which contains embedded content
   * @param {number} [data.height] - iframe height
   * @param {number} [data.width] - iframe width
   * @param {string} [data.caption] - caption
   */
  set data(t2) {
    if (!(t2 instanceof Object))
      throw Error("Embed Tool data should be object");
    const { service: i2, source: e2, embed: s4, width: n3, height: r4, caption: a3 = "" } = t2;
    this._data = {
      service: i2 || this.data.service,
      source: e2 || this.data.source,
      embed: s4 || this.data.embed,
      width: n3 || this.data.width,
      height: r4 || this.data.height,
      caption: a3 || this.data.caption || ""
    };
    const l2 = this.element;
    l2 && l2.parentNode.replaceChild(this.render(), l2);
  }
  /**
   * @returns {EmbedData}
   */
  get data() {
    if (this.element) {
      const t2 = this.element.querySelector(`.${this.api.styles.input}`);
      this._data.caption = t2 ? t2.innerHTML : "";
    }
    return this._data;
  }
  /**
   * Get plugin styles
   *
   * @returns {object}
   */
  get CSS() {
    return {
      baseClass: this.api.styles.block,
      input: this.api.styles.input,
      container: "embed-tool",
      containerLoading: "embed-tool--loading",
      preloader: "embed-tool__preloader",
      caption: "embed-tool__caption",
      url: "embed-tool__url",
      content: "embed-tool__content"
    };
  }
  /**
   * Render Embed tool content
   *
   * @returns {HTMLElement}
   */
  render() {
    if (!this.data.service) {
      const a3 = document.createElement("div");
      return this.element = a3, a3;
    }
    const { html: t2 } = m.services[this.data.service], i2 = document.createElement("div"), e2 = document.createElement("div"), s4 = document.createElement("template"), n3 = this.createPreloader();
    i2.classList.add(this.CSS.baseClass, this.CSS.container, this.CSS.containerLoading), e2.classList.add(this.CSS.input, this.CSS.caption), i2.appendChild(n3), e2.contentEditable = !this.readOnly, e2.dataset.placeholder = this.api.i18n.t("Enter a caption"), e2.innerHTML = this.data.caption || "", s4.innerHTML = t2, s4.content.firstChild.setAttribute("src", this.data.embed), s4.content.firstChild.classList.add(this.CSS.content);
    const r4 = this.embedIsReady(i2);
    return i2.appendChild(s4.content.firstChild), i2.appendChild(e2), r4.then(() => {
      i2.classList.remove(this.CSS.containerLoading);
    }), this.element = i2, i2;
  }
  /**
   * Creates preloader to append to container while data is loading
   *
   * @returns {HTMLElement}
   */
  createPreloader() {
    const t2 = document.createElement("preloader"), i2 = document.createElement("div");
    return i2.textContent = this.data.source, t2.classList.add(this.CSS.preloader), i2.classList.add(this.CSS.url), t2.appendChild(i2), t2;
  }
  /**
   * Save current content and return EmbedData object
   *
   * @returns {EmbedData}
   */
  save() {
    return this.data;
  }
  /**
   * Handle pasted url and return Service object
   *
   * @param {PasteEvent} event - event with pasted data
   */
  onPaste(t2) {
    const { key: i2, data: e2 } = t2.detail, { regex: s4, embedUrl: n3, width: r4, height: a3, id: l2 = (c4) => c4.shift() } = m.services[i2], d4 = s4.exec(e2).slice(1), h2 = n3.replace(/<%= remote_id %>/g, l2(d4));
    this.data = {
      service: i2,
      source: e2,
      embed: h2,
      width: r4,
      height: a3
    };
  }
  /**
   * Analyze provided config and make object with services to use
   *
   * @param {EmbedConfig} config - configuration of embed block element
   */
  static prepare({ config: t2 = {} }) {
    const { services: i2 = {} } = t2;
    let e2 = Object.entries(g$2);
    const s4 = Object.entries(i2).filter(([r4, a3]) => typeof a3 == "boolean" && a3 === true).map(([r4]) => r4), n3 = Object.entries(i2).filter(([r4, a3]) => typeof a3 == "object").filter(([r4, a3]) => m.checkServiceConfig(a3)).map(([r4, a3]) => {
      const { regex: l2, embedUrl: d4, html: h2, height: c4, width: p2, id: f2 } = a3;
      return [r4, {
        regex: l2,
        embedUrl: d4,
        html: h2,
        height: c4,
        width: p2,
        id: f2
      }];
    });
    s4.length && (e2 = e2.filter(([r4]) => s4.includes(r4))), e2 = e2.concat(n3), m.services = e2.reduce((r4, [a3, l2]) => a3 in r4 ? (r4[a3] = Object.assign({}, r4[a3], l2), r4) : (r4[a3] = l2, r4), {}), m.patterns = e2.reduce((r4, [a3, l2]) => (r4[a3] = l2.regex, r4), {});
  }
  /**
   * Check if Service config is valid
   *
   * @param {Service} config - configuration of embed block element
   * @returns {boolean}
   */
  static checkServiceConfig(t2) {
    const { regex: i2, embedUrl: e2, html: s4, height: n3, width: r4, id: a3 } = t2;
    let l2 = i2 && i2 instanceof RegExp && e2 && typeof e2 == "string" && s4 && typeof s4 == "string";
    return l2 = l2 && (a3 !== void 0 ? a3 instanceof Function : true), l2 = l2 && (n3 !== void 0 ? Number.isFinite(n3) : true), l2 = l2 && (r4 !== void 0 ? Number.isFinite(r4) : true), l2;
  }
  /**
   * Paste configuration to enable pasted URLs processing by Editor
   *
   * @returns {object} - object of patterns which contain regx for pasteConfig
   */
  static get pasteConfig() {
    return {
      patterns: m.patterns
    };
  }
  /**
   * Notify core that read-only mode is supported
   *
   * @returns {boolean}
   */
  static get isReadOnlySupported() {
    return true;
  }
  /**
   * Checks that mutations in DOM have finished after appending iframe content
   *
   * @param {HTMLElement} targetNode - HTML-element mutations of which to listen
   * @returns {Promise<any>} - result that all mutations have finished
   */
  embedIsReady(t2) {
    let e2 = null;
    return new Promise((s4, n3) => {
      e2 = new MutationObserver(w.debounce(s4, 450)), e2.observe(t2, {
        childList: true,
        subtree: true
      });
    }).then(() => {
      e2.disconnect();
    });
  }
};
(function() {
  try {
    if (typeof document < "u") {
      var o3 = document.createElement("style");
      o3.appendChild(document.createTextNode('.tc-wrap{--color-background:#f9f9fb;--color-text-secondary:#7b7e89;--color-border:#e8e8eb;--cell-size:34px;--toolbox-icon-size:18px;--toolbox-padding:6px;--toolbox-aiming-field-size:calc(var(--toolbox-icon-size) + var(--toolbox-padding)*2);border-left:0;position:relative;height:100%;width:100%;margin-top:var(--toolbox-icon-size);box-sizing:border-box;display:grid;grid-template-columns:calc(100% - var(--cell-size)) var(--cell-size)}.tc-wrap--readonly{grid-template-columns:100% var(--cell-size)}.tc-wrap svg{vertical-align:top}@media print{.tc-wrap{border-left-color:var(--color-border);border-left-style:solid;border-left-width:1px;grid-template-columns:100% var(--cell-size)}}@media print{.tc-wrap .tc-row:after{display:none}}.tc-table{position:relative;width:100%;height:100%;display:grid;font-size:14px;border-top:1px solid var(--color-border);line-height:1.4}.tc-table:after{width:calc(var(--cell-size));height:100%;left:calc(var(--cell-size)*-1);top:0}.tc-table:after,.tc-table:before{position:absolute;content:""}.tc-table:before{width:100%;height:var(--toolbox-aiming-field-size);top:calc(var(--toolbox-aiming-field-size)*-1);left:0}.tc-table--heading .tc-row:first-child{font-weight:600;border-bottom:2px solid var(--color-border)}.tc-table--heading .tc-row:first-child [contenteditable]:empty:before{content:attr(heading);color:var(--color-text-secondary)}.tc-table--heading .tc-row:first-child:after{bottom:-2px;border-bottom:2px solid var(--color-border)}.tc-add-column,.tc-add-row{display:flex;color:var(--color-text-secondary)}@media print{.tc-add{display:none}}.tc-add-column{padding:4px 0;justify-content:center;border-top:1px solid var(--color-border)}@media print{.tc-add-column{display:none}}.tc-add-row{height:var(--cell-size);align-items:center;padding-left:4px;position:relative}.tc-add-row:before{content:"";position:absolute;right:calc(var(--cell-size)*-1);width:var(--cell-size);height:100%}@media print{.tc-add-row{display:none}}.tc-add-column,.tc-add-row{transition:0s;cursor:pointer;will-change:background-color}.tc-add-column:hover,.tc-add-row:hover{transition:background-color .1s ease;background-color:var(--color-background)}.tc-add-row{margin-top:1px}.tc-add-row:hover:before{transition:.1s;background-color:var(--color-background)}.tc-row{display:grid;grid-template-columns:repeat(auto-fit,minmax(10px,1fr));position:relative;border-bottom:1px solid var(--color-border)}.tc-row:after{content:"";pointer-events:none;position:absolute;width:var(--cell-size);height:100%;bottom:-1px;right:calc(var(--cell-size)*-1);border-bottom:1px solid var(--color-border)}.tc-row--selected{background:var(--color-background)}.tc-row--selected:after{background:var(--color-background)}.tc-cell{border-right:1px solid var(--color-border);padding:6px 12px;overflow:hidden;outline:none;line-break:normal}.tc-cell--selected{background:var(--color-background)}.tc-wrap--readonly .tc-row:after{display:none}.tc-toolbox{--toolbox-padding:6px;--popover-margin:30px;--toggler-click-zone-size:30px;--toggler-dots-color:#7b7e89;--toggler-dots-color-hovered:#1d202b;position:absolute;cursor:pointer;z-index:1;opacity:0;transition:opacity .1s;will-change:left,opacity}.tc-toolbox--column{top:calc(var(--toggler-click-zone-size)*-1);transform:translate(calc(var(--toggler-click-zone-size)*-1/2));will-change:left,opacity}.tc-toolbox--row{left:calc(var(--popover-margin)*-1);transform:translateY(calc(var(--toggler-click-zone-size)*-1/2));margin-top:-1px;will-change:top,opacity}.tc-toolbox--showed{opacity:1}.tc-toolbox .tc-popover{position:absolute;top:0;left:var(--popover-margin)}.tc-toolbox__toggler{display:flex;align-items:center;justify-content:center;width:var(--toggler-click-zone-size);height:var(--toggler-click-zone-size);color:var(--toggler-dots-color);opacity:0;transition:opacity .15s ease;will-change:opacity}.tc-toolbox__toggler:hover{color:var(--toggler-dots-color-hovered)}.tc-toolbox__toggler svg{fill:currentColor}.tc-wrap:hover .tc-toolbox__toggler{opacity:1}.tc-settings .cdx-settings-button{width:50%;margin:0}.tc-popover{--color-border:#eaeaea;--color-background:#fff;--color-background-hover:rgba(232,232,235,.49);--color-background-confirm:#e24a4a;--color-background-confirm-hover:#d54040;--color-text-confirm:#fff;background:var(--color-background);border:1px solid var(--color-border);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;padding:6px;display:none;will-change:opacity,transform}.tc-popover--opened{display:block;animation:menuShowing .1s cubic-bezier(.215,.61,.355,1) forwards}.tc-popover__item{display:flex;align-items:center;padding:2px 14px 2px 2px;border-radius:5px;cursor:pointer;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;user-select:none}.tc-popover__item:hover{background:var(--color-background-hover)}.tc-popover__item:not(:last-of-type){margin-bottom:2px}.tc-popover__item-icon{display:inline-flex;width:26px;height:26px;align-items:center;justify-content:center;background:var(--color-background);border-radius:5px;border:1px solid var(--color-border);margin-right:8px}.tc-popover__item-label{line-height:22px;font-size:14px;font-weight:500}.tc-popover__item--confirm{background:var(--color-background-confirm);color:var(--color-text-confirm)}.tc-popover__item--confirm:hover{background-color:var(--color-background-confirm-hover)}.tc-popover__item--confirm .tc-popover__item-icon{background:var(--color-background-confirm);border-color:#0000001a}.tc-popover__item--confirm .tc-popover__item-icon svg{transition:transform .2s ease-in;transform:rotate(90deg) scale(1.2)}.tc-popover__item--hidden{display:none}@keyframes menuShowing{0%{opacity:0;transform:translateY(-8px) scale(.9)}70%{opacity:1;transform:translateY(2px)}to{transform:translateY(0)}}')), document.head.appendChild(o3);
    }
  } catch (r4) {
    console.error("vite-plugin-css-injected-by-js", r4);
  }
})();
function c$3(d4, t2, e2 = {}) {
  const o3 = document.createElement(d4);
  Array.isArray(t2) ? o3.classList.add(...t2) : t2 && o3.classList.add(t2);
  for (const i2 in e2)
    Object.prototype.hasOwnProperty.call(e2, i2) && (o3[i2] = e2[i2]);
  return o3;
}
function f$1(d4) {
  const t2 = d4.getBoundingClientRect();
  return {
    y1: Math.floor(t2.top + window.pageYOffset),
    x1: Math.floor(t2.left + window.pageXOffset),
    x2: Math.floor(t2.right + window.pageXOffset),
    y2: Math.floor(t2.bottom + window.pageYOffset)
  };
}
function g$1(d4, t2) {
  const e2 = f$1(d4), o3 = f$1(t2);
  return {
    fromTopBorder: o3.y1 - e2.y1,
    fromLeftBorder: o3.x1 - e2.x1,
    fromRightBorder: e2.x2 - o3.x2,
    fromBottomBorder: e2.y2 - o3.y2
  };
}
function R$2(d4, t2) {
  const e2 = d4.getBoundingClientRect(), { width: o3, height: i2, x: s4, y: n3 } = e2, { clientX: h2, clientY: l2 } = t2;
  return {
    width: o3,
    height: i2,
    x: h2 - s4,
    y: l2 - n3
  };
}
function C$2(d4, t2) {
  return t2.parentNode.insertBefore(d4, t2);
}
function m$1(d4, t2 = true) {
  const e2 = document.createRange(), o3 = window.getSelection();
  e2.selectNodeContents(d4), e2.collapse(t2), o3.removeAllRanges(), o3.addRange(e2);
}
let a$5 = class a {
  /**
   * @param {object} options - constructor options
   * @param {PopoverItem[]} options.items - constructor options
   */
  constructor({ items: t2 }) {
    this.items = t2, this.wrapper = void 0, this.itemEls = [];
  }
  /**
   * Set of CSS classnames used in popover
   *
   * @returns {object}
   */
  static get CSS() {
    return {
      popover: "tc-popover",
      popoverOpened: "tc-popover--opened",
      item: "tc-popover__item",
      itemHidden: "tc-popover__item--hidden",
      itemConfirmState: "tc-popover__item--confirm",
      itemIcon: "tc-popover__item-icon",
      itemLabel: "tc-popover__item-label"
    };
  }
  /**
   * Returns the popover element
   *
   * @returns {Element}
   */
  render() {
    return this.wrapper = c$3("div", a.CSS.popover), this.items.forEach((t2, e2) => {
      const o3 = c$3("div", a.CSS.item), i2 = c$3("div", a.CSS.itemIcon, {
        innerHTML: t2.icon
      }), s4 = c$3("div", a.CSS.itemLabel, {
        textContent: t2.label
      });
      o3.dataset.index = e2, o3.appendChild(i2), o3.appendChild(s4), this.wrapper.appendChild(o3), this.itemEls.push(o3);
    }), this.wrapper.addEventListener("click", (t2) => {
      this.popoverClicked(t2);
    }), this.wrapper;
  }
  /**
   * Popover wrapper click listener
   * Used to delegate clicks in items
   *
   * @returns {void}
   */
  popoverClicked(t2) {
    const e2 = t2.target.closest(`.${a.CSS.item}`);
    if (!e2)
      return;
    const o3 = e2.dataset.index, i2 = this.items[o3];
    if (i2.confirmationRequired && !this.hasConfirmationState(e2)) {
      this.setConfirmationState(e2);
      return;
    }
    i2.onClick();
  }
  /**
   * Enable the confirmation state on passed item
   *
   * @returns {void}
   */
  setConfirmationState(t2) {
    t2.classList.add(a.CSS.itemConfirmState);
  }
  /**
   * Disable the confirmation state on passed item
   *
   * @returns {void}
   */
  clearConfirmationState(t2) {
    t2.classList.remove(a.CSS.itemConfirmState);
  }
  /**
   * Check if passed item has the confirmation state
   *
   * @returns {boolean}
   */
  hasConfirmationState(t2) {
    return t2.classList.contains(a.CSS.itemConfirmState);
  }
  /**
   * Return an opening state
   *
   * @returns {boolean}
   */
  get opened() {
    return this.wrapper.classList.contains(a.CSS.popoverOpened);
  }
  /**
   * Opens the popover
   *
   * @returns {void}
   */
  open() {
    this.items.forEach((t2, e2) => {
      typeof t2.hideIf == "function" && this.itemEls[e2].classList.toggle(a.CSS.itemHidden, t2.hideIf());
    }), this.wrapper.classList.add(a.CSS.popoverOpened);
  }
  /**
   * Closes the popover
   *
   * @returns {void}
   */
  close() {
    this.wrapper.classList.remove(a.CSS.popoverOpened), this.itemEls.forEach((t2) => {
      this.clearConfirmationState(t2);
    });
  }
};
const b2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8 8L12 12M12 12L16 16M12 12L16 8M12 12L8 16"/></svg>', k$1 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.8833 9.16666L18.2167 12.5M18.2167 12.5L14.8833 15.8333M18.2167 12.5H10.05C9.16594 12.5 8.31809 12.1488 7.69297 11.5237C7.06785 10.8986 6.71666 10.0507 6.71666 9.16666"/></svg>', S = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.9167 14.9167L11.5833 18.25M11.5833 18.25L8.25 14.9167M11.5833 18.25L11.5833 10.0833C11.5833 9.19928 11.9345 8.35143 12.5596 7.72631C13.1848 7.10119 14.0326 6.75 14.9167 6.75"/></svg>', x$1 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.13333 14.9167L12.4667 18.25M12.4667 18.25L15.8 14.9167M12.4667 18.25L12.4667 10.0833C12.4667 9.19928 12.1155 8.35143 11.4904 7.72631C10.8652 7.10119 10.0174 6.75 9.13333 6.75"/></svg>', y2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.8833 15.8333L18.2167 12.5M18.2167 12.5L14.8833 9.16667M18.2167 12.5L10.05 12.5C9.16595 12.5 8.31811 12.8512 7.69299 13.4763C7.06787 14.1014 6.71667 14.9493 6.71667 15.8333"/></svg>', T = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.41 9.66H9.4"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 9.66H14.59"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.31 14.36H9.3"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 14.36H14.59"/></svg>', v = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M12 7V12M12 17V12M17 12H12M12 12H7"/></svg>', L$1 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-width="2" d="M5 10H19"/><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/></svg>', M$1 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-width="2" d="M10 5V18.5"/><path stroke="currentColor" stroke-width="2" d="M14 5V18.5"/><path stroke="currentColor" stroke-width="2" d="M5 10H19"/><path stroke="currentColor" stroke-width="2" d="M5 14H19"/><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/></svg>', O$1 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-width="2" d="M10 5V18.5"/><path stroke="currentColor" stroke-width="2" d="M5 10H19"/><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/></svg>';
let u$1 = class u {
  /**
   * Creates toolbox buttons and toolbox menus
   *
   * @param {object} api - Editor.js api
   * @param {PopoverItem[]} items - Editor.js api
   * @param {function} onOpen - callback fired when the Popover is opening
   * @param {function} onClose - callback fired when the Popover is closing
   * @param {string} [cssModifier] - the modifier for the Toolbox. Allows to add some specific styles.
   */
  constructor({ api: t2, items: e2, onOpen: o3, onClose: i2, cssModifier: s4 = "" }) {
    this.api = t2, this.items = e2, this.onOpen = o3, this.onClose = i2, this.cssModifier = s4, this.popover = null, this.wrapper = this.createToolbox();
  }
  /**
   * Style classes
   */
  static get CSS() {
    return {
      toolbox: "tc-toolbox",
      toolboxShowed: "tc-toolbox--showed",
      toggler: "tc-toolbox__toggler"
    };
  }
  /**
   * Returns rendered Toolbox element
   */
  get element() {
    return this.wrapper;
  }
  /**
   * Creating a toolbox to open menu for a manipulating columns
   *
   * @returns {Element}
   */
  createToolbox() {
    const t2 = c$3("div", [
      u.CSS.toolbox,
      this.cssModifier ? `${u.CSS.toolbox}--${this.cssModifier}` : ""
    ]);
    t2.dataset.mutationFree = "true";
    const e2 = this.createPopover(), o3 = this.createToggler();
    return t2.appendChild(o3), t2.appendChild(e2), t2;
  }
  /**
   * Creates the Toggler
   *
   * @returns {Element}
   */
  createToggler() {
    const t2 = c$3("div", u.CSS.toggler, {
      innerHTML: T
    });
    return t2.addEventListener("click", () => {
      this.togglerClicked();
    }), t2;
  }
  /**
   * Creates the Popover instance and render it
   *
   * @returns {Element}
   */
  createPopover() {
    return this.popover = new a$5({
      items: this.items
    }), this.popover.render();
  }
  /**
   * Toggler click handler. Opens/Closes the popover
   *
   * @returns {void}
   */
  togglerClicked() {
    this.popover.opened ? (this.popover.close(), this.onClose()) : (this.popover.open(), this.onOpen());
  }
  /**
   * Shows the Toolbox
   *
   * @param {function} computePositionMethod - method that returns the position coordinate
   * @returns {void}
   */
  show(t2) {
    const e2 = t2();
    Object.entries(e2).forEach(([o3, i2]) => {
      this.wrapper.style[o3] = i2;
    }), this.wrapper.classList.add(u.CSS.toolboxShowed);
  }
  /**
   * Hides the Toolbox
   *
   * @returns {void}
   */
  hide() {
    this.popover.close(), this.wrapper.classList.remove(u.CSS.toolboxShowed);
  }
};
function H$1(d4, t2) {
  let e2 = 0;
  return function(...o3) {
    const i2 = (/* @__PURE__ */ new Date()).getTime();
    if (!(i2 - e2 < d4))
      return e2 = i2, t2(...o3);
  };
}
const r$3 = {
  wrapper: "tc-wrap",
  wrapperReadOnly: "tc-wrap--readonly",
  table: "tc-table",
  row: "tc-row",
  withHeadings: "tc-table--heading",
  rowSelected: "tc-row--selected",
  cell: "tc-cell",
  cellSelected: "tc-cell--selected",
  addRow: "tc-add-row",
  addColumn: "tc-add-column"
};
class A {
  /**
   * Creates
   *
   * @constructor
   * @param {boolean} readOnly - read-only mode flag
   * @param {object} api - Editor.js API
   * @param {TableData} data - Editor.js API
   * @param {TableConfig} config - Editor.js API
   */
  constructor(t2, e2, o3, i2) {
    this.readOnly = t2, this.api = e2, this.data = o3, this.config = i2, this.wrapper = null, this.table = null, this.toolboxColumn = this.createColumnToolbox(), this.toolboxRow = this.createRowToolbox(), this.createTableWrapper(), this.hoveredRow = 0, this.hoveredColumn = 0, this.selectedRow = 0, this.selectedColumn = 0, this.tunes = {
      withHeadings: false
    }, this.resize(), this.fill(), this.focusedCell = {
      row: 0,
      column: 0
    }, this.documentClicked = (s4) => {
      const n3 = s4.target.closest(`.${r$3.table}`) !== null, h2 = s4.target.closest(`.${r$3.wrapper}`) === null;
      (n3 || h2) && this.hideToolboxes();
      const w2 = s4.target.closest(`.${r$3.addRow}`), p2 = s4.target.closest(`.${r$3.addColumn}`);
      w2 && w2.parentNode === this.wrapper ? (this.addRow(void 0, true), this.hideToolboxes()) : p2 && p2.parentNode === this.wrapper && (this.addColumn(void 0, true), this.hideToolboxes());
    }, this.readOnly || this.bindEvents();
  }
  /**
   * Returns the rendered table wrapper
   *
   * @returns {Element}
   */
  getWrapper() {
    return this.wrapper;
  }
  /**
   * Hangs the necessary handlers to events
   */
  bindEvents() {
    document.addEventListener("click", this.documentClicked), this.table.addEventListener("mousemove", H$1(150, (t2) => this.onMouseMoveInTable(t2)), { passive: true }), this.table.onkeypress = (t2) => this.onKeyPressListener(t2), this.table.addEventListener("keydown", (t2) => this.onKeyDownListener(t2)), this.table.addEventListener("focusin", (t2) => this.focusInTableListener(t2));
  }
  /**
   * Configures and creates the toolbox for manipulating with columns
   *
   * @returns {Toolbox}
   */
  createColumnToolbox() {
    return new u$1({
      api: this.api,
      cssModifier: "column",
      items: [
        {
          label: this.api.i18n.t("Add column to left"),
          icon: S,
          onClick: () => {
            this.addColumn(this.selectedColumn, true), this.hideToolboxes();
          }
        },
        {
          label: this.api.i18n.t("Add column to right"),
          icon: x$1,
          onClick: () => {
            this.addColumn(this.selectedColumn + 1, true), this.hideToolboxes();
          }
        },
        {
          label: this.api.i18n.t("Delete column"),
          icon: b2,
          hideIf: () => this.numberOfColumns === 1,
          confirmationRequired: true,
          onClick: () => {
            this.deleteColumn(this.selectedColumn), this.hideToolboxes();
          }
        }
      ],
      onOpen: () => {
        this.selectColumn(this.hoveredColumn), this.hideRowToolbox();
      },
      onClose: () => {
        this.unselectColumn();
      }
    });
  }
  /**
   * Configures and creates the toolbox for manipulating with rows
   *
   * @returns {Toolbox}
   */
  createRowToolbox() {
    return new u$1({
      api: this.api,
      cssModifier: "row",
      items: [
        {
          label: this.api.i18n.t("Add row above"),
          icon: y2,
          onClick: () => {
            this.addRow(this.selectedRow, true), this.hideToolboxes();
          }
        },
        {
          label: this.api.i18n.t("Add row below"),
          icon: k$1,
          onClick: () => {
            this.addRow(this.selectedRow + 1, true), this.hideToolboxes();
          }
        },
        {
          label: this.api.i18n.t("Delete row"),
          icon: b2,
          hideIf: () => this.numberOfRows === 1,
          confirmationRequired: true,
          onClick: () => {
            this.deleteRow(this.selectedRow), this.hideToolboxes();
          }
        }
      ],
      onOpen: () => {
        this.selectRow(this.hoveredRow), this.hideColumnToolbox();
      },
      onClose: () => {
        this.unselectRow();
      }
    });
  }
  /**
   * When you press enter it moves the cursor down to the next row
   * or creates it if the click occurred on the last one
   */
  moveCursorToNextRow() {
    this.focusedCell.row !== this.numberOfRows ? (this.focusedCell.row += 1, this.focusCell(this.focusedCell)) : (this.addRow(), this.focusedCell.row += 1, this.focusCell(this.focusedCell), this.updateToolboxesPosition(0, 0));
  }
  /**
   * Get table cell by row and col index
   *
   * @param {number} row - cell row coordinate
   * @param {number} column - cell column coordinate
   * @returns {HTMLElement}
   */
  getCell(t2, e2) {
    return this.table.querySelectorAll(`.${r$3.row}:nth-child(${t2}) .${r$3.cell}`)[e2 - 1];
  }
  /**
   * Get table row by index
   *
   * @param {number} row - row coordinate
   * @returns {HTMLElement}
   */
  getRow(t2) {
    return this.table.querySelector(`.${r$3.row}:nth-child(${t2})`);
  }
  /**
   * The parent of the cell which is the row
   *
   * @param {HTMLElement} cell - cell element
   * @returns {HTMLElement}
   */
  getRowByCell(t2) {
    return t2.parentElement;
  }
  /**
   * Ger row's first cell
   *
   * @param {Element} row - row to find its first cell
   * @returns {Element}
   */
  getRowFirstCell(t2) {
    return t2.querySelector(`.${r$3.cell}:first-child`);
  }
  /**
   * Set the sell's content by row and column numbers
   *
   * @param {number} row - cell row coordinate
   * @param {number} column - cell column coordinate
   * @param {string} content - cell HTML content
   */
  setCellContent(t2, e2, o3) {
    const i2 = this.getCell(t2, e2);
    i2.innerHTML = o3;
  }
  /**
   * Add column in table on index place
   * Add cells in each row
   *
   * @param {number} columnIndex - number in the array of columns, where new column to insert, -1 if insert at the end
   * @param {boolean} [setFocus] - pass true to focus the first cell
   */
  addColumn(t2 = -1, e2 = false) {
    let o3 = this.numberOfColumns;
    for (let i2 = 1; i2 <= this.numberOfRows; i2++) {
      let s4;
      const n3 = this.createCell();
      if (t2 > 0 && t2 <= o3 ? (s4 = this.getCell(i2, t2), C$2(n3, s4)) : s4 = this.getRow(i2).appendChild(n3), i2 === 1) {
        const h2 = this.getCell(i2, t2 > 0 ? t2 : o3 + 1);
        h2 && e2 && m$1(h2);
      }
    }
    this.addHeadingAttrToFirstRow();
  }
  /**
   * Add row in table on index place
   *
   * @param {number} index - number in the array of rows, where new column to insert, -1 if insert at the end
   * @param {boolean} [setFocus] - pass true to focus the inserted row
   * @returns {HTMLElement} row
   */
  addRow(t2 = -1, e2 = false) {
    let o3, i2 = c$3("div", r$3.row);
    this.tunes.withHeadings && this.removeHeadingAttrFromFirstRow();
    let s4 = this.numberOfColumns;
    if (t2 > 0 && t2 <= this.numberOfRows) {
      let h2 = this.getRow(t2);
      o3 = C$2(i2, h2);
    } else
      o3 = this.table.appendChild(i2);
    this.fillRow(o3, s4), this.tunes.withHeadings && this.addHeadingAttrToFirstRow();
    const n3 = this.getRowFirstCell(o3);
    return n3 && e2 && m$1(n3), o3;
  }
  /**
   * Delete a column by index
   *
   * @param {number} index
   */
  deleteColumn(t2) {
    for (let e2 = 1; e2 <= this.numberOfRows; e2++) {
      const o3 = this.getCell(e2, t2);
      if (!o3)
        return;
      o3.remove();
    }
  }
  /**
   * Delete a row by index
   *
   * @param {number} index
   */
  deleteRow(t2) {
    this.getRow(t2).remove(), this.addHeadingAttrToFirstRow();
  }
  /**
   * Create a wrapper containing a table, toolboxes
   * and buttons for adding rows and columns
   *
   * @returns {HTMLElement} wrapper - where all buttons for a table and the table itself will be
   */
  createTableWrapper() {
    if (this.wrapper = c$3("div", r$3.wrapper), this.table = c$3("div", r$3.table), this.readOnly && this.wrapper.classList.add(r$3.wrapperReadOnly), this.wrapper.appendChild(this.toolboxRow.element), this.wrapper.appendChild(this.toolboxColumn.element), this.wrapper.appendChild(this.table), !this.readOnly) {
      const t2 = c$3("div", r$3.addColumn, {
        innerHTML: v
      }), e2 = c$3("div", r$3.addRow, {
        innerHTML: v
      });
      this.wrapper.appendChild(t2), this.wrapper.appendChild(e2);
    }
  }
  /**
   * Returns the size of the table based on initial data or config "size" property
   *
   * @return {{rows: number, cols: number}} - number of cols and rows
   */
  computeInitialSize() {
    const t2 = this.data && this.data.content, e2 = Array.isArray(t2), o3 = e2 ? t2.length : false, i2 = e2 ? t2.length : void 0, s4 = o3 ? t2[0].length : void 0, n3 = Number.parseInt(this.config && this.config.rows), h2 = Number.parseInt(this.config && this.config.cols), l2 = !isNaN(n3) && n3 > 0 ? n3 : void 0, w2 = !isNaN(h2) && h2 > 0 ? h2 : void 0;
    return {
      rows: i2 || l2 || 2,
      cols: s4 || w2 || 2
    };
  }
  /**
   * Resize table to match config size or transmitted data size
   *
   * @return {{rows: number, cols: number}} - number of cols and rows
   */
  resize() {
    const { rows: t2, cols: e2 } = this.computeInitialSize();
    for (let o3 = 0; o3 < t2; o3++)
      this.addRow();
    for (let o3 = 0; o3 < e2; o3++)
      this.addColumn();
  }
  /**
   * Fills the table with data passed to the constructor
   *
   * @returns {void}
   */
  fill() {
    const t2 = this.data;
    if (t2 && t2.content)
      for (let e2 = 0; e2 < t2.content.length; e2++)
        for (let o3 = 0; o3 < t2.content[e2].length; o3++)
          this.setCellContent(e2 + 1, o3 + 1, t2.content[e2][o3]);
  }
  /**
   * Fills a row with cells
   *
   * @param {HTMLElement} row - row to fill
   * @param {number} numberOfColumns - how many cells should be in a row
   */
  fillRow(t2, e2) {
    for (let o3 = 1; o3 <= e2; o3++) {
      const i2 = this.createCell();
      t2.appendChild(i2);
    }
  }
  /**
   * Creating a cell element
   *
   * @return {Element}
   */
  createCell() {
    return c$3("div", r$3.cell, {
      contentEditable: !this.readOnly
    });
  }
  /**
   * Get number of rows in the table
   */
  get numberOfRows() {
    return this.table.childElementCount;
  }
  /**
   * Get number of columns in the table
   */
  get numberOfColumns() {
    return this.numberOfRows ? this.table.querySelectorAll(`.${r$3.row}:first-child .${r$3.cell}`).length : 0;
  }
  /**
   * Is the column toolbox menu displayed or not
   *
   * @returns {boolean}
   */
  get isColumnMenuShowing() {
    return this.selectedColumn !== 0;
  }
  /**
   * Is the row toolbox menu displayed or not
   *
   * @returns {boolean}
   */
  get isRowMenuShowing() {
    return this.selectedRow !== 0;
  }
  /**
   * Recalculate position of toolbox icons
   *
   * @param {Event} event - mouse move event
   */
  onMouseMoveInTable(t2) {
    const { row: e2, column: o3 } = this.getHoveredCell(t2);
    this.hoveredColumn = o3, this.hoveredRow = e2, this.updateToolboxesPosition();
  }
  /**
   * Prevents default Enter behaviors
   * Adds Shift+Enter processing
   *
   * @param {KeyboardEvent} event - keypress event
   */
  onKeyPressListener(t2) {
    if (t2.key === "Enter") {
      if (t2.shiftKey)
        return true;
      this.moveCursorToNextRow();
    }
    return t2.key !== "Enter";
  }
  /**
   * Prevents tab keydown event from bubbling
   * so that it only works inside the table
   *
   * @param {KeyboardEvent} event - keydown event
   */
  onKeyDownListener(t2) {
    t2.key === "Tab" && t2.stopPropagation();
  }
  /**
   * Set the coordinates of the cell that the focus has moved to
   *
   * @param {FocusEvent} event - focusin event
   */
  focusInTableListener(t2) {
    const e2 = t2.target, o3 = this.getRowByCell(e2);
    this.focusedCell = {
      row: Array.from(this.table.querySelectorAll(`.${r$3.row}`)).indexOf(o3) + 1,
      column: Array.from(o3.querySelectorAll(`.${r$3.cell}`)).indexOf(e2) + 1
    };
  }
  /**
   * Unselect row/column
   * Close toolbox menu
   * Hide toolboxes
   *
   * @returns {void}
   */
  hideToolboxes() {
    this.hideRowToolbox(), this.hideColumnToolbox(), this.updateToolboxesPosition();
  }
  /**
   * Unselect row, close toolbox
   *
   * @returns {void}
   */
  hideRowToolbox() {
    this.unselectRow(), this.toolboxRow.hide();
  }
  /**
   * Unselect column, close toolbox
   *
   * @returns {void}
   */
  hideColumnToolbox() {
    this.unselectColumn(), this.toolboxColumn.hide();
  }
  /**
   * Set the cursor focus to the focused cell
   *
   * @returns {void}
   */
  focusCell() {
    this.focusedCellElem.focus();
  }
  /**
   * Get current focused element
   *
   * @returns {HTMLElement} - focused cell
   */
  get focusedCellElem() {
    const { row: t2, column: e2 } = this.focusedCell;
    return this.getCell(t2, e2);
  }
  /**
   * Update toolboxes position
   *
   * @param {number} row - hovered row
   * @param {number} column - hovered column
   */
  updateToolboxesPosition(t2 = this.hoveredRow, e2 = this.hoveredColumn) {
    this.isColumnMenuShowing || e2 > 0 && e2 <= this.numberOfColumns && this.toolboxColumn.show(() => ({
      left: `calc((100% - var(--cell-size)) / (${this.numberOfColumns} * 2) * (1 + (${e2} - 1) * 2))`
    })), this.isRowMenuShowing || t2 > 0 && t2 <= this.numberOfRows && this.toolboxRow.show(() => {
      const o3 = this.getRow(t2), { fromTopBorder: i2 } = g$1(this.table, o3), { height: s4 } = o3.getBoundingClientRect();
      return {
        top: `${Math.ceil(i2 + s4 / 2)}px`
      };
    });
  }
  /**
   * Makes the first row headings
   *
   * @param {boolean} withHeadings - use headings row or not
   */
  setHeadingsSetting(t2) {
    this.tunes.withHeadings = t2, t2 ? (this.table.classList.add(r$3.withHeadings), this.addHeadingAttrToFirstRow()) : (this.table.classList.remove(r$3.withHeadings), this.removeHeadingAttrFromFirstRow());
  }
  /**
   * Adds an attribute for displaying the placeholder in the cell
   */
  addHeadingAttrToFirstRow() {
    for (let t2 = 1; t2 <= this.numberOfColumns; t2++) {
      let e2 = this.getCell(1, t2);
      e2 && e2.setAttribute("heading", this.api.i18n.t("Heading"));
    }
  }
  /**
   * Removes an attribute for displaying the placeholder in the cell
   */
  removeHeadingAttrFromFirstRow() {
    for (let t2 = 1; t2 <= this.numberOfColumns; t2++) {
      let e2 = this.getCell(1, t2);
      e2 && e2.removeAttribute("heading");
    }
  }
  /**
   * Add effect of a selected row
   *
   * @param {number} index
   */
  selectRow(t2) {
    const e2 = this.getRow(t2);
    e2 && (this.selectedRow = t2, e2.classList.add(r$3.rowSelected));
  }
  /**
   * Remove effect of a selected row
   */
  unselectRow() {
    if (this.selectedRow <= 0)
      return;
    const t2 = this.table.querySelector(`.${r$3.rowSelected}`);
    t2 && t2.classList.remove(r$3.rowSelected), this.selectedRow = 0;
  }
  /**
   * Add effect of a selected column
   *
   * @param {number} index
   */
  selectColumn(t2) {
    for (let e2 = 1; e2 <= this.numberOfRows; e2++) {
      const o3 = this.getCell(e2, t2);
      o3 && o3.classList.add(r$3.cellSelected);
    }
    this.selectedColumn = t2;
  }
  /**
   * Remove effect of a selected column
   */
  unselectColumn() {
    if (this.selectedColumn <= 0)
      return;
    let t2 = this.table.querySelectorAll(`.${r$3.cellSelected}`);
    Array.from(t2).forEach((e2) => {
      e2.classList.remove(r$3.cellSelected);
    }), this.selectedColumn = 0;
  }
  /**
   * Calculates the row and column that the cursor is currently hovering over
   * The search was optimized from O(n) to O (log n) via bin search to reduce the number of calculations
   *
   * @param {Event} event - mousemove event
   * @returns hovered cell coordinates as an integer row and column
   */
  getHoveredCell(t2) {
    let e2 = this.hoveredRow, o3 = this.hoveredColumn;
    const { width: i2, height: s4, x: n3, y: h2 } = R$2(this.table, t2);
    return n3 >= 0 && (o3 = this.binSearch(
      this.numberOfColumns,
      (l2) => this.getCell(1, l2),
      ({ fromLeftBorder: l2 }) => n3 < l2,
      ({ fromRightBorder: l2 }) => n3 > i2 - l2
    )), h2 >= 0 && (e2 = this.binSearch(
      this.numberOfRows,
      (l2) => this.getCell(l2, 1),
      ({ fromTopBorder: l2 }) => h2 < l2,
      ({ fromBottomBorder: l2 }) => h2 > s4 - l2
    )), {
      row: e2 || this.hoveredRow,
      column: o3 || this.hoveredColumn
    };
  }
  /**
   * Looks for the index of the cell the mouse is hovering over.
   * Cells can be represented as ordered intervals with left and
   * right (upper and lower for rows) borders inside the table, if the mouse enters it, then this is our index
   *
   * @param {number} numberOfCells - upper bound of binary search
   * @param {function} getCell - function to take the currently viewed cell
   * @param {function} beforeTheLeftBorder - determines the cursor position, to the left of the cell or not
   * @param {function} afterTheRightBorder - determines the cursor position, to the right of the cell or not
   * @returns {number}
   */
  binSearch(t2, e2, o3, i2) {
    let s4 = 0, n3 = t2 + 1, h2 = 0, l2;
    for (; s4 < n3 - 1 && h2 < 10; ) {
      l2 = Math.ceil((s4 + n3) / 2);
      const w2 = e2(l2), p2 = g$1(this.table, w2);
      if (o3(p2))
        n3 = l2;
      else if (i2(p2))
        s4 = l2;
      else
        break;
      h2++;
    }
    return l2;
  }
  /**
   * Collects data from cells into a two-dimensional array
   *
   * @returns {string[][]}
   */
  getData() {
    const t2 = [];
    for (let e2 = 1; e2 <= this.numberOfRows; e2++) {
      const o3 = this.table.querySelector(`.${r$3.row}:nth-child(${e2})`), i2 = Array.from(o3.querySelectorAll(`.${r$3.cell}`));
      i2.every((n3) => !n3.textContent.trim()) || t2.push(i2.map((n3) => n3.innerHTML));
    }
    return t2;
  }
  /**
   * Remove listeners on the document
   */
  destroy() {
    document.removeEventListener("click", this.documentClicked);
  }
}
let I$2 = class I {
  /**
   * Notify core that read-only mode is supported
   *
   * @returns {boolean}
   */
  static get isReadOnlySupported() {
    return true;
  }
  /**
   * Allow to press Enter inside the CodeTool textarea
   *
   * @returns {boolean}
   * @public
   */
  static get enableLineBreaks() {
    return true;
  }
  /**
   * Render plugin`s main Element and fill it with saved data
   *
   * @param {TableData} data — previously saved data
   * @param {TableConfig} config - user config for Tool
   * @param {object} api - Editor.js API
   * @param {boolean} readOnly - read-only mode flag
   */
  constructor({ data: t2, config: e2, api: o3, readOnly: i2 }) {
    this.api = o3, this.readOnly = i2, this.config = e2, this.data = {
      withHeadings: this.getConfig("withHeadings", false, t2),
      content: t2 && t2.content ? t2.content : []
    }, this.table = null;
  }
  /**
   * Get Tool toolbox settings
   * icon - Tool icon's SVG
   * title - title to show in toolbox
   *
   * @returns {{icon: string, title: string}}
   */
  static get toolbox() {
    return {
      icon: O$1,
      title: "Table"
    };
  }
  /**
   * Return Tool's view
   *
   * @returns {HTMLDivElement}
   */
  render() {
    return this.table = new A(this.readOnly, this.api, this.data, this.config), this.container = c$3("div", this.api.styles.block), this.container.appendChild(this.table.getWrapper()), this.table.setHeadingsSetting(this.data.withHeadings), this.container;
  }
  /**
   * Returns plugin settings
   *
   * @returns {Array}
   */
  renderSettings() {
    return [
      {
        label: this.api.i18n.t("With headings"),
        icon: L$1,
        isActive: this.data.withHeadings,
        closeOnActivate: true,
        toggle: true,
        onActivate: () => {
          this.data.withHeadings = true, this.table.setHeadingsSetting(this.data.withHeadings);
        }
      },
      {
        label: this.api.i18n.t("Without headings"),
        icon: M$1,
        isActive: !this.data.withHeadings,
        closeOnActivate: true,
        toggle: true,
        onActivate: () => {
          this.data.withHeadings = false, this.table.setHeadingsSetting(this.data.withHeadings);
        }
      }
    ];
  }
  /**
   * Extract table data from the view
   *
   * @returns {TableData} - saved data
   */
  save() {
    const t2 = this.table.getData();
    return {
      withHeadings: this.data.withHeadings,
      content: t2
    };
  }
  /**
   * Plugin destroyer
   *
   * @returns {void}
   */
  destroy() {
    this.table.destroy();
  }
  /**
   * A helper to get config value.
   * 
   * @param {string} configName - the key to get from the config. 
   * @param {any} defaultValue - default value if config doesn't have passed key
   * @param {object} savedData - previously saved data. If passed, the key will be got from there, otherwise from the config
   * @returns {any} - config value.
   */
  getConfig(t2, e2 = void 0, o3 = void 0) {
    const i2 = this.data || o3;
    return i2 ? i2[t2] ? i2[t2] : e2 : this.config && this.config[t2] ? this.config[t2] : e2;
  }
  /**  
   * Table onPaste configuration
   *
   * @public
   */
  static get pasteConfig() {
    return { tags: ["TABLE", "TR", "TH", "TD"] };
  }
  /**
   * On paste callback that is fired from Editor
   *
   * @param {PasteEvent} event - event with pasted data
   */
  onPaste(t2) {
    const e2 = t2.detail.data, o3 = e2.querySelector(":scope > thead, tr:first-of-type th"), s4 = Array.from(e2.querySelectorAll("tr")).map((n3) => Array.from(n3.querySelectorAll("th, td")).map((l2) => l2.innerHTML));
    this.data = {
      withHeadings: o3 !== null,
      content: s4
    }, this.table.wrapper && this.table.wrapper.replaceWith(this.render());
  }
};
(function() {
  try {
    if (typeof document < "u") {
      var e2 = document.createElement("style");
      e2.appendChild(document.createTextNode(".cdx-list{margin:0;padding-left:40px;outline:none}.cdx-list__item{padding:5.5px 0 5.5px 3px;line-height:1.6em}.cdx-list--unordered{list-style:disc}.cdx-list--ordered{list-style:decimal}.cdx-list-settings{display:flex}.cdx-list-settings .cdx-settings-button{width:50%}")), document.head.appendChild(e2);
    }
  } catch (t2) {
    console.error("vite-plugin-css-injected-by-js", t2);
  }
})();
const a$4 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><line x1="9" x2="19" y1="7" y2="7" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="9" x2="19" y1="12" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="9" x2="19" y1="17" y2="17" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M5.00001 17H4.99002"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M5.00001 12H4.99002"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M5.00001 7H4.99002"/></svg>', o$4 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><line x1="12" x2="19" y1="7" y2="7" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="12" x2="19" y1="12" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="12" x2="19" y1="17" y2="17" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7.79999 14L7.79999 7.2135C7.79999 7.12872 7.7011 7.0824 7.63597 7.13668L4.79999 9.5"/></svg>';
let d$4 = class d {
  /**
   * Notify core that read-only mode is supported
   *
   * @returns {boolean}
   */
  static get isReadOnlySupported() {
    return true;
  }
  /**
   * Allow to use native Enter behaviour
   *
   * @returns {boolean}
   * @public
   */
  static get enableLineBreaks() {
    return true;
  }
  /**
   * Get Tool toolbox settings
   * icon - Tool icon's SVG
   * title - title to show in toolbox
   *
   * @returns {{icon: string, title: string}}
   */
  static get toolbox() {
    return {
      icon: a$4,
      title: "List"
    };
  }
  /**
   * Render plugin`s main Element and fill it with saved data
   *
   * @param {object} params - tool constructor options
   * @param {ListData} params.data - previously saved data
   * @param {object} params.config - user config for Tool
   * @param {object} params.api - Editor.js API
   * @param {boolean} params.readOnly - read-only mode flag
   */
  constructor({ data: e2, config: t2, api: r4, readOnly: s4 }) {
    this._elements = {
      wrapper: null
    }, this.api = r4, this.readOnly = s4, this.settings = [
      {
        name: "unordered",
        label: this.api.i18n.t("Unordered"),
        icon: a$4,
        default: t2.defaultStyle === "unordered" || false
      },
      {
        name: "ordered",
        label: this.api.i18n.t("Ordered"),
        icon: o$4,
        default: t2.defaultStyle === "ordered" || true
      }
    ], this._data = {
      style: this.settings.find((i2) => i2.default === true).name,
      items: []
    }, this.data = e2;
  }
  /**
   * Returns list tag with items
   *
   * @returns {Element}
   * @public
   */
  render() {
    return this._elements.wrapper = this.makeMainTag(this._data.style), this._data.items.length ? this._data.items.forEach((e2) => {
      this._elements.wrapper.appendChild(this._make("li", this.CSS.item, {
        innerHTML: e2
      }));
    }) : this._elements.wrapper.appendChild(this._make("li", this.CSS.item)), this.readOnly || this._elements.wrapper.addEventListener("keydown", (e2) => {
      const [t2, r4] = [13, 8];
      switch (e2.keyCode) {
        case t2:
          this.getOutofList(e2);
          break;
        case r4:
          this.backspace(e2);
          break;
      }
    }, false), this._elements.wrapper;
  }
  /**
   * @returns {ListData}
   * @public
   */
  save() {
    return this.data;
  }
  /**
   * Allow List Tool to be converted to/from other block
   *
   * @returns {{export: Function, import: Function}}
   */
  static get conversionConfig() {
    return {
      /**
       * To create exported string from list, concatenate items by dot-symbol.
       *
       * @param {ListData} data - list data to create a string from thats
       * @returns {string}
       */
      export: (e2) => e2.items.join(". "),
      /**
       * To create a list from other block's string, just put it at the first item
       *
       * @param {string} string - string to create list tool data from that
       * @returns {ListData}
       */
      import: (e2) => ({
        items: [e2],
        style: "unordered"
      })
    };
  }
  /**
   * Sanitizer rules
   *
   * @returns {object}
   */
  static get sanitize() {
    return {
      style: {},
      items: {
        br: true
      }
    };
  }
  /**
   * Settings
   *
   * @public
   * @returns {Array}
   */
  renderSettings() {
    return this.settings.map((e2) => ({
      ...e2,
      isActive: this._data.style === e2.name,
      closeOnActivate: true,
      onActivate: () => this.toggleTune(e2.name)
    }));
  }
  /**
   * On paste callback that is fired from Editor
   *
   * @param {PasteEvent} event - event with pasted data
   */
  onPaste(e2) {
    const t2 = e2.detail.data;
    this.data = this.pasteHandler(t2);
  }
  /**
   * List Tool on paste configuration
   *
   * @public
   */
  static get pasteConfig() {
    return {
      tags: ["OL", "UL", "LI"]
    };
  }
  /**
   * Creates main <ul> or <ol> tag depended on style
   *
   * @param {string} style - 'ordered' or 'unordered'
   * @returns {HTMLOListElement|HTMLUListElement}
   */
  makeMainTag(e2) {
    const t2 = e2 === "ordered" ? this.CSS.wrapperOrdered : this.CSS.wrapperUnordered, r4 = e2 === "ordered" ? "ol" : "ul";
    return this._make(r4, [this.CSS.baseBlock, this.CSS.wrapper, t2], {
      contentEditable: !this.readOnly
    });
  }
  /**
   * Toggles List style
   *
   * @param {string} style - 'ordered'|'unordered'
   */
  toggleTune(e2) {
    const t2 = this.makeMainTag(e2);
    for (; this._elements.wrapper.hasChildNodes(); )
      t2.appendChild(this._elements.wrapper.firstChild);
    this._elements.wrapper.replaceWith(t2), this._elements.wrapper = t2, this._data.style = e2;
  }
  /**
   * Styles
   *
   * @private
   */
  get CSS() {
    return {
      baseBlock: this.api.styles.block,
      wrapper: "cdx-list",
      wrapperOrdered: "cdx-list--ordered",
      wrapperUnordered: "cdx-list--unordered",
      item: "cdx-list__item"
    };
  }
  /**
   * List data setter
   *
   * @param {ListData} listData
   */
  set data(e2) {
    e2 || (e2 = {}), this._data.style = e2.style || this.settings.find((r4) => r4.default === true).name, this._data.items = e2.items || [];
    const t2 = this._elements.wrapper;
    t2 && t2.parentNode.replaceChild(this.render(), t2);
  }
  /**
   * Return List data
   *
   * @returns {ListData}
   */
  get data() {
    this._data.items = [];
    const e2 = this._elements.wrapper.querySelectorAll(`.${this.CSS.item}`);
    for (let t2 = 0; t2 < e2.length; t2++)
      e2[t2].innerHTML.replace("<br>", " ").trim() && this._data.items.push(e2[t2].innerHTML);
    return this._data;
  }
  /**
   * Helper for making Elements with attributes
   *
   * @param  {string} tagName           - new Element tag name
   * @param  {Array|string} classNames  - list or name of CSS classname(s)
   * @param  {object} attributes        - any attributes
   * @returns {Element}
   */
  _make(e2, t2 = null, r4 = {}) {
    const s4 = document.createElement(e2);
    Array.isArray(t2) ? s4.classList.add(...t2) : t2 && s4.classList.add(t2);
    for (const i2 in r4)
      s4[i2] = r4[i2];
    return s4;
  }
  /**
   * Returns current List item by the caret position
   *
   * @returns {Element}
   */
  get currentItem() {
    let e2 = window.getSelection().anchorNode;
    return e2.nodeType !== Node.ELEMENT_NODE && (e2 = e2.parentNode), e2.closest(`.${this.CSS.item}`);
  }
  /**
   * Get out from List Tool
   * by Enter on the empty last item
   *
   * @param {KeyboardEvent} event
   */
  getOutofList(e2) {
    const t2 = this._elements.wrapper.querySelectorAll("." + this.CSS.item);
    if (t2.length < 2)
      return;
    const r4 = t2[t2.length - 1], s4 = this.currentItem;
    s4 === r4 && !r4.textContent.trim().length && (s4.parentElement.removeChild(s4), this.api.blocks.insert(), this.api.caret.setToBlock(this.api.blocks.getCurrentBlockIndex()), e2.preventDefault(), e2.stopPropagation());
  }
  /**
   * Handle backspace
   *
   * @param {KeyboardEvent} event
   */
  backspace(e2) {
    const t2 = this._elements.wrapper.querySelectorAll("." + this.CSS.item), r4 = t2[0];
    r4 && t2.length < 2 && !r4.innerHTML.replace("<br>", " ").trim() && e2.preventDefault();
  }
  /**
   * Select LI content by CMD+A
   *
   * @param {KeyboardEvent} event
   */
  selectItem(e2) {
    e2.preventDefault();
    const t2 = window.getSelection(), r4 = t2.anchorNode.parentNode, s4 = r4.closest("." + this.CSS.item), i2 = new Range();
    i2.selectNodeContents(s4), t2.removeAllRanges(), t2.addRange(i2);
  }
  /**
   * Handle UL, OL and LI tags paste and returns List data
   *
   * @param {HTMLUListElement|HTMLOListElement|HTMLLIElement} element
   * @returns {ListData}
   */
  pasteHandler(e2) {
    const { tagName: t2 } = e2;
    let r4;
    switch (t2) {
      case "OL":
        r4 = "ordered";
        break;
      case "UL":
      case "LI":
        r4 = "unordered";
    }
    const s4 = {
      style: r4,
      items: []
    };
    if (t2 === "LI")
      s4.items = [e2.innerHTML];
    else {
      const i2 = Array.from(e2.querySelectorAll("LI"));
      s4.items = i2.map((n3) => n3.innerHTML).filter((n3) => !!n3.trim());
    }
    return s4;
  }
};
(function() {
  try {
    if (typeof document < "u") {
      var e2 = document.createElement("style");
      e2.appendChild(document.createTextNode(`.cdx-warning{position:relative}@media all and (min-width: 736px){.cdx-warning{padding-left:36px}}.cdx-warning [contentEditable=true][data-placeholder]:before{position:absolute;content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.cdx-warning [contentEditable=true][data-placeholder]:empty:before{opacity:1}.cdx-warning [contentEditable=true][data-placeholder]:empty:focus:before{opacity:0}.cdx-warning:before{content:"";background-image:url("data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='5' y='5' width='14' height='14' rx='4' stroke='black' stroke-width='2'/%3E%3Cline x1='12' y1='9' x2='12' y2='12' stroke='black' stroke-width='2' stroke-linecap='round'/%3E%3Cpath d='M12 15.02V15.01' stroke='black' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E");width:24px;height:24px;background-size:24px 24px;position:absolute;margin-top:8px;left:0}@media all and (max-width: 735px){.cdx-warning:before{display:none}}.cdx-warning__message{min-height:85px}.cdx-warning__title{margin-bottom:6px}`)), document.head.appendChild(e2);
    }
  } catch (t2) {
    console.error("vite-plugin-css-injected-by-js", t2);
  }
})();
const n2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/><line x1="12" x2="12" y1="9" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M12 15.02V15.01"/></svg>';
let r$2 = class r {
  /**
   * Notify core that read-only mode is supported
   */
  static get isReadOnlySupported() {
    return true;
  }
  /**
   * Get Toolbox settings
   *
   * @public
   * @returns {string}
   */
  static get toolbox() {
    return {
      icon: n2,
      title: "Warning"
    };
  }
  /**
   * Allow to press Enter inside the Warning
   *
   * @public
   * @returns {boolean}
   */
  static get enableLineBreaks() {
    return true;
  }
  /**
   * Default placeholder for warning title
   *
   * @public
   * @returns {string}
   */
  static get DEFAULT_TITLE_PLACEHOLDER() {
    return "Title";
  }
  /**
   * Default placeholder for warning message
   *
   * @public
   * @returns {string}
   */
  static get DEFAULT_MESSAGE_PLACEHOLDER() {
    return "Message";
  }
  /**
   * Warning Tool`s styles
   *
   * @returns {object}
   */
  get CSS() {
    return {
      baseClass: this.api.styles.block,
      wrapper: "cdx-warning",
      title: "cdx-warning__title",
      input: this.api.styles.input,
      message: "cdx-warning__message"
    };
  }
  /**
   * Render plugin`s main Element and fill it with saved data
   *
   * @param {WarningData} data — previously saved data
   * @param {WarningConfig} config — user config for Tool
   * @param {object} api - Editor.js API
   * @param {boolean} readOnly - read-only mode flag
   */
  constructor({ data: e2, config: t2, api: s4, readOnly: i2 }) {
    this.api = s4, this.readOnly = i2, this.titlePlaceholder = t2.titlePlaceholder || r.DEFAULT_TITLE_PLACEHOLDER, this.messagePlaceholder = t2.messagePlaceholder || r.DEFAULT_MESSAGE_PLACEHOLDER, this.data = {
      title: e2.title || "",
      message: e2.message || ""
    };
  }
  /**
   * Create Warning Tool container with inputs
   *
   * @returns {Element}
   */
  render() {
    const e2 = this._make("div", [this.CSS.baseClass, this.CSS.wrapper]), t2 = this._make("div", [this.CSS.input, this.CSS.title], {
      contentEditable: !this.readOnly,
      innerHTML: this.data.title
    }), s4 = this._make("div", [this.CSS.input, this.CSS.message], {
      contentEditable: !this.readOnly,
      innerHTML: this.data.message
    });
    return t2.dataset.placeholder = this.titlePlaceholder, s4.dataset.placeholder = this.messagePlaceholder, e2.appendChild(t2), e2.appendChild(s4), e2;
  }
  /**
   * Extract Warning data from Warning Tool element
   *
   * @param {HTMLDivElement} warningElement - element to save
   * @returns {WarningData}
   */
  save(e2) {
    const t2 = e2.querySelector(`.${this.CSS.title}`), s4 = e2.querySelector(`.${this.CSS.message}`);
    return Object.assign(this.data, {
      title: t2.innerHTML,
      message: s4.innerHTML
    });
  }
  /**
   * Helper for making Elements with attributes
   *
   * @param  {string} tagName           - new Element tag name
   * @param  {Array|string} classNames  - list or name of CSS classname(s)
   * @param  {object} attributes        - any attributes
   * @returns {Element}
   */
  _make(e2, t2 = null, s4 = {}) {
    const i2 = document.createElement(e2);
    Array.isArray(t2) ? i2.classList.add(...t2) : t2 && i2.classList.add(t2);
    for (const a3 in s4)
      i2[a3] = s4[a3];
    return i2;
  }
  /**
   * Sanitizer config for Warning Tool saved data
   *
   * @returns {object}
   */
  static get sanitize() {
    return {
      title: {},
      message: {}
    };
  }
};
(function() {
  try {
    if (typeof document < "u") {
      var e2 = document.createElement("style");
      e2.appendChild(document.createTextNode(".ce-code__textarea{min-height:200px;font-family:Menlo,Monaco,Consolas,Courier New,monospace;color:#41314e;line-height:1.6em;font-size:12px;background:#f8f7fa;border:1px solid #f1f1f4;box-shadow:none;white-space:pre;word-wrap:normal;overflow-x:auto;resize:vertical}")), document.head.appendChild(e2);
    }
  } catch (o3) {
    console.error("vite-plugin-css-injected-by-js", o3);
  }
})();
function l$2(c4, t2) {
  let r4 = "";
  for (; r4 !== `
` && t2 > 0; )
    t2 = t2 - 1, r4 = c4.substr(t2, 1);
  return r4 === `
` && (t2 += 1), t2;
}
const h$2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 8L5 12L9 16"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 8L19 12L15 16"/></svg>';
/**
 * CodeTool for Editor.js
 *
 * @author CodeX (team@ifmo.su)
 * @copyright CodeX 2018
 * @license MIT
 * @version 2.0.0
 */
let d$3 = class d2 {
  /**
   * Notify core that read-only mode is supported
   *
   * @returns {boolean}
   */
  static get isReadOnlySupported() {
    return true;
  }
  /**
   * Allow to press Enter inside the CodeTool textarea
   *
   * @returns {boolean}
   * @public
   */
  static get enableLineBreaks() {
    return true;
  }
  /**
   * @typedef {object} CodeData — plugin saved data
   * @property {string} code - previously saved plugin code
   */
  /**
   * Render plugin`s main Element and fill it with saved data
   *
   * @param {object} options - tool constricting options
   * @param {CodeData} options.data — previously saved plugin code
   * @param {object} options.config - user config for Tool
   * @param {object} options.api - Editor.js API
   * @param {boolean} options.readOnly - read only mode flag
   */
  constructor({ data: t2, config: e2, api: r4, readOnly: a3 }) {
    this.api = r4, this.readOnly = a3, this.placeholder = this.api.i18n.t(e2.placeholder || d2.DEFAULT_PLACEHOLDER), this.CSS = {
      baseClass: this.api.styles.block,
      input: this.api.styles.input,
      wrapper: "ce-code",
      textarea: "ce-code__textarea"
    }, this.nodes = {
      holder: null,
      textarea: null
    }, this.data = {
      code: t2.code || ""
    }, this.nodes.holder = this.drawView();
  }
  /**
   * Create Tool's view
   *
   * @returns {HTMLElement}
   * @private
   */
  drawView() {
    const t2 = document.createElement("div"), e2 = document.createElement("textarea");
    return t2.classList.add(this.CSS.baseClass, this.CSS.wrapper), e2.classList.add(this.CSS.textarea, this.CSS.input), e2.textContent = this.data.code, e2.placeholder = this.placeholder, this.readOnly && (e2.disabled = true), t2.appendChild(e2), e2.addEventListener("keydown", (r4) => {
      switch (r4.code) {
        case "Tab":
          this.tabHandler(r4);
          break;
      }
    }), this.nodes.textarea = e2, t2;
  }
  /**
   * Return Tool's view
   *
   * @returns {HTMLDivElement} this.nodes.holder - Code's wrapper
   * @public
   */
  render() {
    return this.nodes.holder;
  }
  /**
   * Extract Tool's data from the view
   *
   * @param {HTMLDivElement} codeWrapper - CodeTool's wrapper, containing textarea with code
   * @returns {CodeData} - saved plugin code
   * @public
   */
  save(t2) {
    return {
      code: t2.querySelector("textarea").value
    };
  }
  /**
   * onPaste callback fired from Editor`s core
   *
   * @param {PasteEvent} event - event with pasted content
   */
  onPaste(t2) {
    const e2 = t2.detail.data;
    this.data = {
      code: e2.textContent
    };
  }
  /**
   * Returns Tool`s data from private property
   *
   * @returns {CodeData}
   */
  get data() {
    return this._data;
  }
  /**
   * Set Tool`s data to private property and update view
   *
   * @param {CodeData} data - saved tool data
   */
  set data(t2) {
    this._data = t2, this.nodes.textarea && (this.nodes.textarea.textContent = t2.code);
  }
  /**
   * Get Tool toolbox settings
   * icon - Tool icon's SVG
   * title - title to show in toolbox
   *
   * @returns {{icon: string, title: string}}
   */
  static get toolbox() {
    return {
      icon: h$2,
      title: "Code"
    };
  }
  /**
   * Default placeholder for CodeTool's textarea
   *
   * @public
   * @returns {string}
   */
  static get DEFAULT_PLACEHOLDER() {
    return "Enter a code";
  }
  /**
   *  Used by Editor.js paste handling API.
   *  Provides configuration to handle CODE tag.
   *
   * @static
   * @returns {{tags: string[]}}
   */
  static get pasteConfig() {
    return {
      tags: ["pre"]
    };
  }
  /**
   * Automatic sanitize config
   *
   * @returns {{code: boolean}}
   */
  static get sanitize() {
    return {
      code: true
      // Allow HTML tags
    };
  }
  /**
   * Handles Tab key pressing (adds/removes indentations)
   *
   * @private
   * @param {KeyboardEvent} event - keydown
   * @returns {void}
   */
  tabHandler(t2) {
    t2.stopPropagation(), t2.preventDefault();
    const e2 = t2.target, r4 = t2.shiftKey, a3 = e2.selectionStart, s4 = e2.value, n3 = "  ";
    let i2;
    if (!r4)
      i2 = a3 + n3.length, e2.value = s4.substring(0, a3) + n3 + s4.substring(a3);
    else {
      const o3 = l$2(s4, a3);
      if (s4.substr(o3, n3.length) !== n3)
        return;
      e2.value = s4.substring(0, o3) + s4.substring(o3 + n3.length), i2 = a3 - n3.length;
    }
    e2.setSelectionRange(i2, i2);
  }
};
(function() {
  try {
    if (typeof document < "u") {
      var o3 = document.createElement("style");
      o3.appendChild(document.createTextNode(`.link-tool{position:relative}.link-tool__input{padding-left:38px;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none'%3E%3Cpath stroke='%23707684' stroke-linecap='round' stroke-width='2' d='m7.7 12.6-.021.02a2.795 2.795 0 0 0-.044 4.005v0a2.795 2.795 0 0 0 3.936.006l1.455-1.438a3 3 0 0 0 .34-3.866l-.146-.207'/%3E%3Cpath stroke='%23707684' stroke-linecap='round' stroke-width='2' d='m16.22 11.12.136-.14c.933-.954.992-2.46.135-3.483v0a2.597 2.597 0 0 0-3.664-.32L11.39 8.386a3 3 0 0 0-.301 4.3l.031.034'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:10px;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}.link-tool__input-holder{position:relative}.link-tool__input-holder--error .link-tool__input{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none'%3E%3Cpath stroke='rgb(224, 147, 147)' stroke-linecap='round' stroke-width='2' d='m7.7 12.6-.021.02a2.795 2.795 0 0 0-.044 4.005v0a2.795 2.795 0 0 0 3.936.006l1.455-1.438a3 3 0 0 0 .34-3.866l-.146-.207'/%3E%3Cpath stroke='rgb(224, 147, 147)' stroke-linecap='round' stroke-width='2' d='m16.22 11.12.136-.14c.933-.954.992-2.46.135-3.483v0a2.597 2.597 0 0 0-3.664-.32L11.39 8.386a3 3 0 0 0-.301 4.3l.031.034'/%3E%3C/svg%3E");background-color:#fff3f6;border-color:#f3e0e0;color:#a95a5a;box-shadow:inset 0 1px 3px #923e3e0d}.link-tool__input[contentEditable=true][data-placeholder]:before{position:absolute;content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.link-tool__input[contentEditable=true][data-placeholder]:empty:before{opacity:1}.link-tool__input[contentEditable=true][data-placeholder]:empty:focus:before{opacity:0}.link-tool__progress{position:absolute;box-shadow:inset 0 1px 3px #66556b0a;height:100%;width:0;background-color:#f4f5f7;z-index:-1}.link-tool__progress--loading{-webkit-animation:progress .5s ease-in;-webkit-animation-fill-mode:forwards}.link-tool__progress--loaded{width:100%}.link-tool__content{display:block;padding:25px;border-radius:2px;box-shadow:0 0 0 2px #fff;color:initial!important;text-decoration:none!important}.link-tool__content:after{content:"";clear:both;display:table}.link-tool__content--rendered{background:#fff;border:1px solid rgba(201,201,204,.48);box-shadow:0 1px 3px #0000001a;border-radius:6px;will-change:filter;animation:link-in .45s 1 cubic-bezier(.215,.61,.355,1)}.link-tool__content--rendered:hover{box-shadow:0 0 3px #00000029}.link-tool__image{background-position:center center;background-repeat:no-repeat;background-size:cover;margin:0 0 0 30px;width:65px;height:65px;border-radius:3px;float:right}.link-tool__title{font-size:17px;font-weight:600;line-height:1.5em;margin:0 0 10px}.link-tool__title+.link-tool__anchor{margin-top:25px}.link-tool__description{margin:0 0 20px;font-size:15px;line-height:1.55em;display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden}.link-tool__anchor{display:block;font-size:15px;line-height:1em;color:#888!important;border:0!important;padding:0!important}@keyframes link-in{0%{filter:blur(5px)}to{filter:none}}.codex-editor--narrow .link-tool__image{display:none}@-webkit-keyframes progress{0%{width:0}to{width:85%}}`)), document.head.appendChild(o3);
    }
  } catch (t2) {
    console.error("vite-plugin-css-injected-by-js", t2);
  }
})();
var C$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function O(k2) {
  return k2 && k2.__esModule && Object.prototype.hasOwnProperty.call(k2, "default") ? k2.default : k2;
}
(function(k2) {
  var w2 = function() {
    try {
      return !!Symbol.iterator;
    } catch {
      return false;
    }
  }, d4 = w2(), v2 = function(n3) {
    var o3 = {
      next: function() {
        var e2 = n3.shift();
        return { done: e2 === void 0, value: e2 };
      }
    };
    return d4 && (o3[Symbol.iterator] = function() {
      return o3;
    }), o3;
  }, c4 = function(n3) {
    return encodeURIComponent(n3).replace(/%20/g, "+");
  }, i2 = function(n3) {
    return decodeURIComponent(String(n3).replace(/\+/g, " "));
  }, a3 = function() {
    var n3 = function(e2) {
      Object.defineProperty(this, "_entries", { writable: true, value: {} });
      var s4 = typeof e2;
      if (s4 !== "undefined")
        if (s4 === "string")
          e2 !== "" && this._fromString(e2);
        else if (e2 instanceof n3) {
          var h2 = this;
          e2.forEach(function(u3, f2) {
            h2.append(f2, u3);
          });
        } else if (e2 !== null && s4 === "object")
          if (Object.prototype.toString.call(e2) === "[object Array]")
            for (var t2 = 0; t2 < e2.length; t2++) {
              var y3 = e2[t2];
              if (Object.prototype.toString.call(y3) === "[object Array]" || y3.length !== 2)
                this.append(y3[0], y3[1]);
              else
                throw new TypeError("Expected [string, any] as entry at index " + t2 + " of URLSearchParams's input");
            }
          else
            for (var r4 in e2)
              e2.hasOwnProperty(r4) && this.append(r4, e2[r4]);
        else
          throw new TypeError("Unsupported input's type for URLSearchParams");
    }, o3 = n3.prototype;
    o3.append = function(e2, s4) {
      e2 in this._entries ? this._entries[e2].push(String(s4)) : this._entries[e2] = [String(s4)];
    }, o3.delete = function(e2) {
      delete this._entries[e2];
    }, o3.get = function(e2) {
      return e2 in this._entries ? this._entries[e2][0] : null;
    }, o3.getAll = function(e2) {
      return e2 in this._entries ? this._entries[e2].slice(0) : [];
    }, o3.has = function(e2) {
      return e2 in this._entries;
    }, o3.set = function(e2, s4) {
      this._entries[e2] = [String(s4)];
    }, o3.forEach = function(e2, s4) {
      var h2;
      for (var t2 in this._entries)
        if (this._entries.hasOwnProperty(t2)) {
          h2 = this._entries[t2];
          for (var y3 = 0; y3 < h2.length; y3++)
            e2.call(s4, h2[y3], t2, this);
        }
    }, o3.keys = function() {
      var e2 = [];
      return this.forEach(function(s4, h2) {
        e2.push(h2);
      }), v2(e2);
    }, o3.values = function() {
      var e2 = [];
      return this.forEach(function(s4) {
        e2.push(s4);
      }), v2(e2);
    }, o3.entries = function() {
      var e2 = [];
      return this.forEach(function(s4, h2) {
        e2.push([h2, s4]);
      }), v2(e2);
    }, d4 && (o3[Symbol.iterator] = o3.entries), o3.toString = function() {
      var e2 = [];
      return this.forEach(function(s4, h2) {
        e2.push(c4(h2) + "=" + c4(s4));
      }), e2.join("&");
    }, k2.URLSearchParams = n3;
  }, p2 = function() {
    try {
      var n3 = k2.URLSearchParams;
      return new n3("?a=1").toString() === "a=1" && typeof n3.prototype.set == "function";
    } catch {
      return false;
    }
  };
  p2() || a3();
  var l2 = k2.URLSearchParams.prototype;
  typeof l2.sort != "function" && (l2.sort = function() {
    var n3 = this, o3 = [];
    this.forEach(function(s4, h2) {
      o3.push([h2, s4]), n3._entries || n3.delete(h2);
    }), o3.sort(function(s4, h2) {
      return s4[0] < h2[0] ? -1 : s4[0] > h2[0] ? 1 : 0;
    }), n3._entries && (n3._entries = {});
    for (var e2 = 0; e2 < o3.length; e2++)
      this.append(o3[e2][0], o3[e2][1]);
  }), typeof l2._fromString != "function" && Object.defineProperty(l2, "_fromString", {
    enumerable: false,
    configurable: false,
    writable: false,
    value: function(n3) {
      if (this._entries)
        this._entries = {};
      else {
        var o3 = [];
        this.forEach(function(t2, y3) {
          o3.push(y3);
        });
        for (var e2 = 0; e2 < o3.length; e2++)
          this.delete(o3[e2]);
      }
      n3 = n3.replace(/^\?/, "");
      for (var s4 = n3.split("&"), h2, e2 = 0; e2 < s4.length; e2++)
        h2 = s4[e2].split("="), this.append(
          i2(h2[0]),
          h2.length > 1 ? i2(h2[1]) : ""
        );
    }
  });
})(
  typeof C$1 < "u" ? C$1 : typeof window < "u" ? window : typeof self < "u" ? self : C$1
);
(function(k2) {
  var w2 = function() {
    try {
      var c4 = new k2.URL("b", "http://a");
      return c4.pathname = "c d", c4.href === "http://a/c%20d" && c4.searchParams;
    } catch {
      return false;
    }
  }, d4 = function() {
    var c4 = k2.URL, i2 = function(l2, n3) {
      typeof l2 != "string" && (l2 = String(l2));
      var o3 = document, e2;
      if (n3 && (k2.location === void 0 || n3 !== k2.location.href)) {
        o3 = document.implementation.createHTMLDocument(""), e2 = o3.createElement("base"), e2.href = n3, o3.head.appendChild(e2);
        try {
          if (e2.href.indexOf(n3) !== 0)
            throw new Error(e2.href);
        } catch (m3) {
          throw new Error("URL unable to set base " + n3 + " due to " + m3);
        }
      }
      var s4 = o3.createElement("a");
      s4.href = l2, e2 && (o3.body.appendChild(s4), s4.href = s4.href);
      var h2 = o3.createElement("input");
      if (h2.type = "url", h2.value = l2, s4.protocol === ":" || !/:/.test(s4.href) || !h2.checkValidity() && !n3)
        throw new TypeError("Invalid URL");
      Object.defineProperty(this, "_anchorElement", {
        value: s4
      });
      var t2 = new k2.URLSearchParams(this.search), y3 = true, r4 = true, u3 = this;
      ["append", "delete", "set"].forEach(function(m3) {
        var b3 = t2[m3];
        t2[m3] = function() {
          b3.apply(t2, arguments), y3 && (r4 = false, u3.search = t2.toString(), r4 = true);
        };
      }), Object.defineProperty(this, "searchParams", {
        value: t2,
        enumerable: true
      });
      var f2 = void 0;
      Object.defineProperty(this, "_updateSearchParams", {
        enumerable: false,
        configurable: false,
        writable: false,
        value: function() {
          this.search !== f2 && (f2 = this.search, r4 && (y3 = false, this.searchParams._fromString(this.search), y3 = true));
        }
      });
    }, a3 = i2.prototype, p2 = function(l2) {
      Object.defineProperty(a3, l2, {
        get: function() {
          return this._anchorElement[l2];
        },
        set: function(n3) {
          this._anchorElement[l2] = n3;
        },
        enumerable: true
      });
    };
    ["hash", "host", "hostname", "port", "protocol"].forEach(function(l2) {
      p2(l2);
    }), Object.defineProperty(a3, "search", {
      get: function() {
        return this._anchorElement.search;
      },
      set: function(l2) {
        this._anchorElement.search = l2, this._updateSearchParams();
      },
      enumerable: true
    }), Object.defineProperties(a3, {
      toString: {
        get: function() {
          var l2 = this;
          return function() {
            return l2.href;
          };
        }
      },
      href: {
        get: function() {
          return this._anchorElement.href.replace(/\?$/, "");
        },
        set: function(l2) {
          this._anchorElement.href = l2, this._updateSearchParams();
        },
        enumerable: true
      },
      pathname: {
        get: function() {
          return this._anchorElement.pathname.replace(/(^\/?)/, "/");
        },
        set: function(l2) {
          this._anchorElement.pathname = l2;
        },
        enumerable: true
      },
      origin: {
        get: function() {
          var l2 = { "http:": 80, "https:": 443, "ftp:": 21 }[this._anchorElement.protocol], n3 = this._anchorElement.port != l2 && this._anchorElement.port !== "";
          return this._anchorElement.protocol + "//" + this._anchorElement.hostname + (n3 ? ":" + this._anchorElement.port : "");
        },
        enumerable: true
      },
      password: {
        // TODO
        get: function() {
          return "";
        },
        set: function(l2) {
        },
        enumerable: true
      },
      username: {
        // TODO
        get: function() {
          return "";
        },
        set: function(l2) {
        },
        enumerable: true
      }
    }), i2.createObjectURL = function(l2) {
      return c4.createObjectURL.apply(c4, arguments);
    }, i2.revokeObjectURL = function(l2) {
      return c4.revokeObjectURL.apply(c4, arguments);
    }, k2.URL = i2;
  };
  if (w2() || d4(), k2.location !== void 0 && !("origin" in k2.location)) {
    var v2 = function() {
      return k2.location.protocol + "//" + k2.location.hostname + (k2.location.port ? ":" + k2.location.port : "");
    };
    try {
      Object.defineProperty(k2.location, "origin", {
        get: v2,
        enumerable: true
      });
    } catch {
      setInterval(function() {
        k2.location.origin = v2();
      }, 100);
    }
  }
})(
  typeof C$1 < "u" ? C$1 : typeof window < "u" ? window : typeof self < "u" ? self : C$1
);
var j$1 = { exports: {} };
(function(k2, w2) {
  (function(d4, v2) {
    k2.exports = v2();
  })(window, function() {
    return function(d4) {
      var v2 = {};
      function c4(i2) {
        if (v2[i2])
          return v2[i2].exports;
        var a3 = v2[i2] = { i: i2, l: false, exports: {} };
        return d4[i2].call(a3.exports, a3, a3.exports, c4), a3.l = true, a3.exports;
      }
      return c4.m = d4, c4.c = v2, c4.d = function(i2, a3, p2) {
        c4.o(i2, a3) || Object.defineProperty(i2, a3, { enumerable: true, get: p2 });
      }, c4.r = function(i2) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(i2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i2, "__esModule", { value: true });
      }, c4.t = function(i2, a3) {
        if (1 & a3 && (i2 = c4(i2)), 8 & a3 || 4 & a3 && typeof i2 == "object" && i2 && i2.__esModule)
          return i2;
        var p2 = /* @__PURE__ */ Object.create(null);
        if (c4.r(p2), Object.defineProperty(p2, "default", { enumerable: true, value: i2 }), 2 & a3 && typeof i2 != "string")
          for (var l2 in i2)
            c4.d(p2, l2, (function(n3) {
              return i2[n3];
            }).bind(null, l2));
        return p2;
      }, c4.n = function(i2) {
        var a3 = i2 && i2.__esModule ? function() {
          return i2.default;
        } : function() {
          return i2;
        };
        return c4.d(a3, "a", a3), a3;
      }, c4.o = function(i2, a3) {
        return Object.prototype.hasOwnProperty.call(i2, a3);
      }, c4.p = "", c4(c4.s = 3);
    }([function(d4, v2) {
      var c4;
      c4 = function() {
        return this;
      }();
      try {
        c4 = c4 || new Function("return this")();
      } catch {
        typeof window == "object" && (c4 = window);
      }
      d4.exports = c4;
    }, function(d4, v2, c4) {
      (function(i2) {
        var a3 = c4(2), p2 = setTimeout;
        function l2() {
        }
        function n3(r4) {
          if (!(this instanceof n3))
            throw new TypeError("Promises must be constructed via new");
          if (typeof r4 != "function")
            throw new TypeError("not a function");
          this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], y3(r4, this);
        }
        function o3(r4, u3) {
          for (; r4._state === 3; )
            r4 = r4._value;
          r4._state !== 0 ? (r4._handled = true, n3._immediateFn(function() {
            var f2 = r4._state === 1 ? u3.onFulfilled : u3.onRejected;
            if (f2 !== null) {
              var m3;
              try {
                m3 = f2(r4._value);
              } catch (b3) {
                return void s4(u3.promise, b3);
              }
              e2(u3.promise, m3);
            } else
              (r4._state === 1 ? e2 : s4)(u3.promise, r4._value);
          })) : r4._deferreds.push(u3);
        }
        function e2(r4, u3) {
          try {
            if (u3 === r4)
              throw new TypeError("A promise cannot be resolved with itself.");
            if (u3 && (typeof u3 == "object" || typeof u3 == "function")) {
              var f2 = u3.then;
              if (u3 instanceof n3)
                return r4._state = 3, r4._value = u3, void h2(r4);
              if (typeof f2 == "function")
                return void y3((m3 = f2, b3 = u3, function() {
                  m3.apply(b3, arguments);
                }), r4);
            }
            r4._state = 1, r4._value = u3, h2(r4);
          } catch (g2) {
            s4(r4, g2);
          }
          var m3, b3;
        }
        function s4(r4, u3) {
          r4._state = 2, r4._value = u3, h2(r4);
        }
        function h2(r4) {
          r4._state === 2 && r4._deferreds.length === 0 && n3._immediateFn(function() {
            r4._handled || n3._unhandledRejectionFn(r4._value);
          });
          for (var u3 = 0, f2 = r4._deferreds.length; u3 < f2; u3++)
            o3(r4, r4._deferreds[u3]);
          r4._deferreds = null;
        }
        function t2(r4, u3, f2) {
          this.onFulfilled = typeof r4 == "function" ? r4 : null, this.onRejected = typeof u3 == "function" ? u3 : null, this.promise = f2;
        }
        function y3(r4, u3) {
          var f2 = false;
          try {
            r4(function(m3) {
              f2 || (f2 = true, e2(u3, m3));
            }, function(m3) {
              f2 || (f2 = true, s4(u3, m3));
            });
          } catch (m3) {
            if (f2)
              return;
            f2 = true, s4(u3, m3);
          }
        }
        n3.prototype.catch = function(r4) {
          return this.then(null, r4);
        }, n3.prototype.then = function(r4, u3) {
          var f2 = new this.constructor(l2);
          return o3(this, new t2(r4, u3, f2)), f2;
        }, n3.prototype.finally = a3.a, n3.all = function(r4) {
          return new n3(function(u3, f2) {
            if (!r4 || r4.length === void 0)
              throw new TypeError("Promise.all accepts an array");
            var m3 = Array.prototype.slice.call(r4);
            if (m3.length === 0)
              return u3([]);
            var b3 = m3.length;
            function g2(T2, E2) {
              try {
                if (E2 && (typeof E2 == "object" || typeof E2 == "function")) {
                  var S2 = E2.then;
                  if (typeof S2 == "function")
                    return void S2.call(E2, function(L2) {
                      g2(T2, L2);
                    }, f2);
                }
                m3[T2] = E2, --b3 == 0 && u3(m3);
              } catch (L2) {
                f2(L2);
              }
            }
            for (var _3 = 0; _3 < m3.length; _3++)
              g2(_3, m3[_3]);
          });
        }, n3.resolve = function(r4) {
          return r4 && typeof r4 == "object" && r4.constructor === n3 ? r4 : new n3(function(u3) {
            u3(r4);
          });
        }, n3.reject = function(r4) {
          return new n3(function(u3, f2) {
            f2(r4);
          });
        }, n3.race = function(r4) {
          return new n3(function(u3, f2) {
            for (var m3 = 0, b3 = r4.length; m3 < b3; m3++)
              r4[m3].then(u3, f2);
          });
        }, n3._immediateFn = typeof i2 == "function" && function(r4) {
          i2(r4);
        } || function(r4) {
          p2(r4, 0);
        }, n3._unhandledRejectionFn = function(r4) {
          typeof console < "u" && console && console.warn("Possible Unhandled Promise Rejection:", r4);
        }, v2.a = n3;
      }).call(this, c4(5).setImmediate);
    }, function(d4, v2, c4) {
      v2.a = function(i2) {
        var a3 = this.constructor;
        return this.then(function(p2) {
          return a3.resolve(i2()).then(function() {
            return p2;
          });
        }, function(p2) {
          return a3.resolve(i2()).then(function() {
            return a3.reject(p2);
          });
        });
      };
    }, function(d4, v2, c4) {
      function i2(t2) {
        return (i2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(y3) {
          return typeof y3;
        } : function(y3) {
          return y3 && typeof Symbol == "function" && y3.constructor === Symbol && y3 !== Symbol.prototype ? "symbol" : typeof y3;
        })(t2);
      }
      c4(4);
      var a3, p2, l2, n3, o3, e2, s4 = c4(8), h2 = (p2 = function(t2) {
        return new Promise(function(y3, r4) {
          t2 = n3(t2), t2 = o3(t2);
          var u3 = window.XMLHttpRequest ? new window.XMLHttpRequest() : new window.ActiveXObject("Microsoft.XMLHTTP");
          u3.open(t2.method, t2.url), u3.setRequestHeader("X-Requested-With", "XMLHttpRequest"), Object.keys(t2.headers).forEach(function(m3) {
            var b3 = t2.headers[m3];
            u3.setRequestHeader(m3, b3);
          });
          var f2 = t2.ratio;
          u3.upload.addEventListener("progress", function(m3) {
            var b3 = Math.round(m3.loaded / m3.total * 100), g2 = Math.ceil(b3 * f2 / 100);
            t2.progress(g2);
          }, false), u3.addEventListener("progress", function(m3) {
            var b3 = Math.round(m3.loaded / m3.total * 100), g2 = Math.ceil(b3 * (100 - f2) / 100) + f2;
            t2.progress(g2);
          }, false), u3.onreadystatechange = function() {
            if (u3.readyState === 4) {
              var m3 = u3.response;
              try {
                m3 = JSON.parse(m3);
              } catch {
              }
              var b3 = s4.parseHeaders(u3.getAllResponseHeaders()), g2 = { body: m3, code: u3.status, headers: b3 };
              u3.status === 200 ? y3(g2) : r4(g2);
            }
          }, u3.send(t2.data);
        });
      }, l2 = function(t2) {
        return t2.method = "POST", p2(t2);
      }, n3 = function() {
        var t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (t2.url && typeof t2.url != "string")
          throw new Error("Url must be a string");
        if (t2.url = t2.url || "", t2.method && typeof t2.method != "string")
          throw new Error("`method` must be a string or null");
        if (t2.method = t2.method ? t2.method.toUpperCase() : "GET", t2.headers && i2(t2.headers) !== "object")
          throw new Error("`headers` must be an object or null");
        if (t2.headers = t2.headers || {}, t2.type && (typeof t2.type != "string" || !Object.values(a3).includes(t2.type)))
          throw new Error("`type` must be taken from module's «contentType» library");
        if (t2.progress && typeof t2.progress != "function")
          throw new Error("`progress` must be a function or null");
        if (t2.progress = t2.progress || function(y3) {
        }, t2.beforeSend = t2.beforeSend || function(y3) {
        }, t2.ratio && typeof t2.ratio != "number")
          throw new Error("`ratio` must be a number");
        if (t2.ratio < 0 || t2.ratio > 100)
          throw new Error("`ratio` must be in a 0-100 interval");
        if (t2.ratio = t2.ratio || 90, t2.accept && typeof t2.accept != "string")
          throw new Error("`accept` must be a string with a list of allowed mime-types");
        if (t2.accept = t2.accept || "*/*", t2.multiple && typeof t2.multiple != "boolean")
          throw new Error("`multiple` must be a true or false");
        if (t2.multiple = t2.multiple || false, t2.fieldName && typeof t2.fieldName != "string")
          throw new Error("`fieldName` must be a string");
        return t2.fieldName = t2.fieldName || "files", t2;
      }, o3 = function(t2) {
        switch (t2.method) {
          case "GET":
            var y3 = e2(t2.data, a3.URLENCODED);
            delete t2.data, t2.url = /\?/.test(t2.url) ? t2.url + "&" + y3 : t2.url + "?" + y3;
            break;
          case "POST":
          case "PUT":
          case "DELETE":
          case "UPDATE":
            var r4 = function() {
              return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).type || a3.JSON;
            }(t2);
            (s4.isFormData(t2.data) || s4.isFormElement(t2.data)) && (r4 = a3.FORM), t2.data = e2(t2.data, r4), r4 !== h2.contentType.FORM && (t2.headers["content-type"] = r4);
        }
        return t2;
      }, e2 = function() {
        var t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        switch (arguments.length > 1 ? arguments[1] : void 0) {
          case a3.URLENCODED:
            return s4.urlEncode(t2);
          case a3.JSON:
            return s4.jsonEncode(t2);
          case a3.FORM:
            return s4.formEncode(t2);
          default:
            return t2;
        }
      }, { contentType: a3 = { URLENCODED: "application/x-www-form-urlencoded; charset=utf-8", FORM: "multipart/form-data", JSON: "application/json; charset=utf-8" }, request: p2, get: function(t2) {
        return t2.method = "GET", p2(t2);
      }, post: l2, transport: function(t2) {
        return t2 = n3(t2), s4.selectFiles(t2).then(function(y3) {
          for (var r4 = new FormData(), u3 = 0; u3 < y3.length; u3++)
            r4.append(t2.fieldName, y3[u3], y3[u3].name);
          return s4.isObject(t2.data) && Object.keys(t2.data).forEach(function(f2) {
            var m3 = t2.data[f2];
            r4.append(f2, m3);
          }), t2.beforeSend && t2.beforeSend(y3), t2.data = r4, l2(t2);
        });
      }, selectFiles: function(t2) {
        return delete (t2 = n3(t2)).beforeSend, s4.selectFiles(t2);
      } });
      d4.exports = h2;
    }, function(d4, v2, c4) {
      c4.r(v2);
      var i2 = c4(1);
      window.Promise = window.Promise || i2.a;
    }, function(d4, v2, c4) {
      (function(i2) {
        var a3 = i2 !== void 0 && i2 || typeof self < "u" && self || window, p2 = Function.prototype.apply;
        function l2(n3, o3) {
          this._id = n3, this._clearFn = o3;
        }
        v2.setTimeout = function() {
          return new l2(p2.call(setTimeout, a3, arguments), clearTimeout);
        }, v2.setInterval = function() {
          return new l2(p2.call(setInterval, a3, arguments), clearInterval);
        }, v2.clearTimeout = v2.clearInterval = function(n3) {
          n3 && n3.close();
        }, l2.prototype.unref = l2.prototype.ref = function() {
        }, l2.prototype.close = function() {
          this._clearFn.call(a3, this._id);
        }, v2.enroll = function(n3, o3) {
          clearTimeout(n3._idleTimeoutId), n3._idleTimeout = o3;
        }, v2.unenroll = function(n3) {
          clearTimeout(n3._idleTimeoutId), n3._idleTimeout = -1;
        }, v2._unrefActive = v2.active = function(n3) {
          clearTimeout(n3._idleTimeoutId);
          var o3 = n3._idleTimeout;
          o3 >= 0 && (n3._idleTimeoutId = setTimeout(function() {
            n3._onTimeout && n3._onTimeout();
          }, o3));
        }, c4(6), v2.setImmediate = typeof self < "u" && self.setImmediate || i2 !== void 0 && i2.setImmediate || this && this.setImmediate, v2.clearImmediate = typeof self < "u" && self.clearImmediate || i2 !== void 0 && i2.clearImmediate || this && this.clearImmediate;
      }).call(this, c4(0));
    }, function(d4, v2, c4) {
      (function(i2, a3) {
        (function(p2, l2) {
          if (!p2.setImmediate) {
            var n3, o3, e2, s4, h2, t2 = 1, y3 = {}, r4 = false, u3 = p2.document, f2 = Object.getPrototypeOf && Object.getPrototypeOf(p2);
            f2 = f2 && f2.setTimeout ? f2 : p2, {}.toString.call(p2.process) === "[object process]" ? n3 = function(g2) {
              a3.nextTick(function() {
                b3(g2);
              });
            } : function() {
              if (p2.postMessage && !p2.importScripts) {
                var g2 = true, _3 = p2.onmessage;
                return p2.onmessage = function() {
                  g2 = false;
                }, p2.postMessage("", "*"), p2.onmessage = _3, g2;
              }
            }() ? (s4 = "setImmediate$" + Math.random() + "$", h2 = function(g2) {
              g2.source === p2 && typeof g2.data == "string" && g2.data.indexOf(s4) === 0 && b3(+g2.data.slice(s4.length));
            }, p2.addEventListener ? p2.addEventListener("message", h2, false) : p2.attachEvent("onmessage", h2), n3 = function(g2) {
              p2.postMessage(s4 + g2, "*");
            }) : p2.MessageChannel ? ((e2 = new MessageChannel()).port1.onmessage = function(g2) {
              b3(g2.data);
            }, n3 = function(g2) {
              e2.port2.postMessage(g2);
            }) : u3 && "onreadystatechange" in u3.createElement("script") ? (o3 = u3.documentElement, n3 = function(g2) {
              var _3 = u3.createElement("script");
              _3.onreadystatechange = function() {
                b3(g2), _3.onreadystatechange = null, o3.removeChild(_3), _3 = null;
              }, o3.appendChild(_3);
            }) : n3 = function(g2) {
              setTimeout(b3, 0, g2);
            }, f2.setImmediate = function(g2) {
              typeof g2 != "function" && (g2 = new Function("" + g2));
              for (var _3 = new Array(arguments.length - 1), T2 = 0; T2 < _3.length; T2++)
                _3[T2] = arguments[T2 + 1];
              var E2 = { callback: g2, args: _3 };
              return y3[t2] = E2, n3(t2), t2++;
            }, f2.clearImmediate = m3;
          }
          function m3(g2) {
            delete y3[g2];
          }
          function b3(g2) {
            if (r4)
              setTimeout(b3, 0, g2);
            else {
              var _3 = y3[g2];
              if (_3) {
                r4 = true;
                try {
                  (function(T2) {
                    var E2 = T2.callback, S2 = T2.args;
                    switch (S2.length) {
                      case 0:
                        E2();
                        break;
                      case 1:
                        E2(S2[0]);
                        break;
                      case 2:
                        E2(S2[0], S2[1]);
                        break;
                      case 3:
                        E2(S2[0], S2[1], S2[2]);
                        break;
                      default:
                        E2.apply(l2, S2);
                    }
                  })(_3);
                } finally {
                  m3(g2), r4 = false;
                }
              }
            }
          }
        })(typeof self > "u" ? i2 === void 0 ? this : i2 : self);
      }).call(this, c4(0), c4(7));
    }, function(d4, v2) {
      var c4, i2, a3 = d4.exports = {};
      function p2() {
        throw new Error("setTimeout has not been defined");
      }
      function l2() {
        throw new Error("clearTimeout has not been defined");
      }
      function n3(f2) {
        if (c4 === setTimeout)
          return setTimeout(f2, 0);
        if ((c4 === p2 || !c4) && setTimeout)
          return c4 = setTimeout, setTimeout(f2, 0);
        try {
          return c4(f2, 0);
        } catch {
          try {
            return c4.call(null, f2, 0);
          } catch {
            return c4.call(this, f2, 0);
          }
        }
      }
      (function() {
        try {
          c4 = typeof setTimeout == "function" ? setTimeout : p2;
        } catch {
          c4 = p2;
        }
        try {
          i2 = typeof clearTimeout == "function" ? clearTimeout : l2;
        } catch {
          i2 = l2;
        }
      })();
      var o3, e2 = [], s4 = false, h2 = -1;
      function t2() {
        s4 && o3 && (s4 = false, o3.length ? e2 = o3.concat(e2) : h2 = -1, e2.length && y3());
      }
      function y3() {
        if (!s4) {
          var f2 = n3(t2);
          s4 = true;
          for (var m3 = e2.length; m3; ) {
            for (o3 = e2, e2 = []; ++h2 < m3; )
              o3 && o3[h2].run();
            h2 = -1, m3 = e2.length;
          }
          o3 = null, s4 = false, function(b3) {
            if (i2 === clearTimeout)
              return clearTimeout(b3);
            if ((i2 === l2 || !i2) && clearTimeout)
              return i2 = clearTimeout, clearTimeout(b3);
            try {
              i2(b3);
            } catch {
              try {
                return i2.call(null, b3);
              } catch {
                return i2.call(this, b3);
              }
            }
          }(f2);
        }
      }
      function r4(f2, m3) {
        this.fun = f2, this.array = m3;
      }
      function u3() {
      }
      a3.nextTick = function(f2) {
        var m3 = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var b3 = 1; b3 < arguments.length; b3++)
            m3[b3 - 1] = arguments[b3];
        e2.push(new r4(f2, m3)), e2.length !== 1 || s4 || n3(y3);
      }, r4.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, a3.title = "browser", a3.browser = true, a3.env = {}, a3.argv = [], a3.version = "", a3.versions = {}, a3.on = u3, a3.addListener = u3, a3.once = u3, a3.off = u3, a3.removeListener = u3, a3.removeAllListeners = u3, a3.emit = u3, a3.prependListener = u3, a3.prependOnceListener = u3, a3.listeners = function(f2) {
        return [];
      }, a3.binding = function(f2) {
        throw new Error("process.binding is not supported");
      }, a3.cwd = function() {
        return "/";
      }, a3.chdir = function(f2) {
        throw new Error("process.chdir is not supported");
      }, a3.umask = function() {
        return 0;
      };
    }, function(d4, v2, c4) {
      function i2(p2, l2) {
        for (var n3 = 0; n3 < l2.length; n3++) {
          var o3 = l2[n3];
          o3.enumerable = o3.enumerable || false, o3.configurable = true, "value" in o3 && (o3.writable = true), Object.defineProperty(p2, o3.key, o3);
        }
      }
      var a3 = c4(9);
      d4.exports = function() {
        function p2() {
          (function(e2, s4) {
            if (!(e2 instanceof s4))
              throw new TypeError("Cannot call a class as a function");
          })(this, p2);
        }
        var l2, n3, o3;
        return l2 = p2, o3 = [{ key: "urlEncode", value: function(e2) {
          return a3(e2);
        } }, { key: "jsonEncode", value: function(e2) {
          return JSON.stringify(e2);
        } }, { key: "formEncode", value: function(e2) {
          if (this.isFormData(e2))
            return e2;
          if (this.isFormElement(e2))
            return new FormData(e2);
          if (this.isObject(e2)) {
            var s4 = new FormData();
            return Object.keys(e2).forEach(function(h2) {
              var t2 = e2[h2];
              s4.append(h2, t2);
            }), s4;
          }
          throw new Error("`data` must be an instance of Object, FormData or <FORM> HTMLElement");
        } }, { key: "isObject", value: function(e2) {
          return Object.prototype.toString.call(e2) === "[object Object]";
        } }, { key: "isFormData", value: function(e2) {
          return e2 instanceof FormData;
        } }, { key: "isFormElement", value: function(e2) {
          return e2 instanceof HTMLFormElement;
        } }, { key: "selectFiles", value: function() {
          var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          return new Promise(function(s4, h2) {
            var t2 = document.createElement("INPUT");
            t2.type = "file", e2.multiple && t2.setAttribute("multiple", "multiple"), e2.accept && t2.setAttribute("accept", e2.accept), t2.style.display = "none", document.body.appendChild(t2), t2.addEventListener("change", function(y3) {
              var r4 = y3.target.files;
              s4(r4), document.body.removeChild(t2);
            }, false), t2.click();
          });
        } }, { key: "parseHeaders", value: function(e2) {
          var s4 = e2.trim().split(/[\r\n]+/), h2 = {};
          return s4.forEach(function(t2) {
            var y3 = t2.split(": "), r4 = y3.shift(), u3 = y3.join(": ");
            r4 && (h2[r4] = u3);
          }), h2;
        } }], (n3 = null) && i2(l2.prototype, n3), o3 && i2(l2, o3), p2;
      }();
    }, function(d4, v2) {
      var c4 = function(a3) {
        return encodeURIComponent(a3).replace(/[!'()*]/g, escape).replace(/%20/g, "+");
      }, i2 = function(a3, p2, l2, n3) {
        return p2 = p2 || null, l2 = l2 || "&", n3 = n3 || null, a3 ? function(o3) {
          for (var e2 = new Array(), s4 = 0; s4 < o3.length; s4++)
            o3[s4] && e2.push(o3[s4]);
          return e2;
        }(Object.keys(a3).map(function(o3) {
          var e2, s4, h2 = o3;
          if (n3 && (h2 = n3 + "[" + h2 + "]"), typeof a3[o3] == "object" && a3[o3] !== null)
            e2 = i2(a3[o3], null, l2, h2);
          else {
            p2 && (s4 = h2, h2 = !isNaN(parseFloat(s4)) && isFinite(s4) ? p2 + Number(h2) : h2);
            var t2 = a3[o3];
            t2 = (t2 = (t2 = (t2 = t2 === true ? "1" : t2) === false ? "0" : t2) === 0 ? "0" : t2) || "", e2 = c4(h2) + "=" + c4(t2);
          }
          return e2;
        })).join(l2).replace(/[!'()*]/g, "") : "";
      };
      d4.exports = i2;
    }]);
  });
})(j$1);
var P$1 = j$1.exports;
const R$1 = /* @__PURE__ */ O(P$1), F$1 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7.69998 12.6L7.67896 12.62C6.53993 13.7048 6.52012 15.5155 7.63516 16.625V16.625C8.72293 17.7073 10.4799 17.7102 11.5712 16.6314L13.0263 15.193C14.0703 14.1609 14.2141 12.525 13.3662 11.3266L13.22 11.12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16.22 11.12L16.3564 10.9805C17.2895 10.0265 17.3478 8.5207 16.4914 7.49733V7.49733C15.569 6.39509 13.9269 6.25143 12.8271 7.17675L11.39 8.38588C10.0935 9.47674 9.95704 11.4241 11.0887 12.6852L11.12 12.72"/></svg>';
let I$1 = class I2 {
  /**
   * Notify core that read-only mode supported
   *
   * @returns {boolean}
   */
  static get isReadOnlySupported() {
    return true;
  }
  /**
   * Get Tool toolbox settings
   * icon - Tool icon's SVG
   * title - title to show in toolbox
   *
   * @returns {{icon: string, title: string}}
   */
  static get toolbox() {
    return {
      icon: F$1,
      title: "Link"
    };
  }
  /**
   * Allow to press Enter inside the LinkTool input
   *
   * @returns {boolean}
   * @public
   */
  static get enableLineBreaks() {
    return true;
  }
  /**
   * @param {object} options - Tool constructor options fot from Editor.js
   * @param {LinkToolData} options.data - previously saved data
   * @param {LinkToolConfig} options.config - user config for Tool
   * @param {object} options.api - Editor.js API
   * @param {boolean} options.readOnly - read-only mode flag
   */
  constructor({ data: w2, config: d4, api: v2, readOnly: c4 }) {
    this.api = v2, this.readOnly = c4, this.config = {
      endpoint: d4.endpoint || "",
      headers: d4.headers || {}
    }, this.nodes = {
      wrapper: null,
      container: null,
      progress: null,
      input: null,
      inputHolder: null,
      linkContent: null,
      linkImage: null,
      linkTitle: null,
      linkDescription: null,
      linkText: null
    }, this._data = {
      link: "",
      meta: {}
    }, this.data = w2;
  }
  /**
   * Renders Block content
   *
   * @public
   *
   * @returns {HTMLDivElement}
   */
  render() {
    return this.nodes.wrapper = this.make("div", this.CSS.baseClass), this.nodes.container = this.make("div", this.CSS.container), this.nodes.inputHolder = this.makeInputHolder(), this.nodes.linkContent = this.prepareLinkPreview(), Object.keys(this.data.meta).length ? (this.nodes.container.appendChild(this.nodes.linkContent), this.showLinkPreview(this.data.meta)) : this.nodes.container.appendChild(this.nodes.inputHolder), this.nodes.wrapper.appendChild(this.nodes.container), this.nodes.wrapper;
  }
  /**
   * Return Block data
   *
   * @public
   *
   * @returns {LinkToolData}
   */
  save() {
    return this.data;
  }
  /**
   * Validate Block data
   * - check if given link is an empty string or not.
   *
   * @public
   *
   * @returns {boolean} false if saved data is incorrect, otherwise true
   */
  validate() {
    return this.data.link.trim() !== "";
  }
  /**
   * Stores all Tool's data
   *
   * @param {LinkToolData} data - data to store
   */
  set data(w2) {
    this._data = Object.assign({}, {
      link: w2.link || this._data.link,
      meta: w2.meta || this._data.meta
    });
  }
  /**
   * Return Tool data
   *
   * @returns {LinkToolData}
   */
  get data() {
    return this._data;
  }
  /**
   * @returns {object} - Link Tool styles
   */
  get CSS() {
    return {
      baseClass: this.api.styles.block,
      input: this.api.styles.input,
      /**
       * Tool's classes
       */
      container: "link-tool",
      inputEl: "link-tool__input",
      inputHolder: "link-tool__input-holder",
      inputError: "link-tool__input-holder--error",
      linkContent: "link-tool__content",
      linkContentRendered: "link-tool__content--rendered",
      linkImage: "link-tool__image",
      linkTitle: "link-tool__title",
      linkDescription: "link-tool__description",
      linkText: "link-tool__anchor",
      progress: "link-tool__progress",
      progressLoading: "link-tool__progress--loading",
      progressLoaded: "link-tool__progress--loaded"
    };
  }
  /**
   * Prepare input holder
   *
   * @returns {HTMLElement}
   */
  makeInputHolder() {
    const w2 = this.make("div", this.CSS.inputHolder);
    return this.nodes.progress = this.make("label", this.CSS.progress), this.nodes.input = this.make("div", [this.CSS.input, this.CSS.inputEl], {
      contentEditable: !this.readOnly
    }), this.nodes.input.dataset.placeholder = this.api.i18n.t("Link"), this.readOnly || (this.nodes.input.addEventListener("paste", (d4) => {
      this.startFetching(d4);
    }), this.nodes.input.addEventListener("keydown", (d4) => {
      const [v2, c4] = [13, 65], i2 = d4.ctrlKey || d4.metaKey;
      switch (d4.keyCode) {
        case v2:
          d4.preventDefault(), d4.stopPropagation(), this.startFetching(d4);
          break;
        case c4:
          i2 && this.selectLinkUrl(d4);
          break;
      }
    })), w2.appendChild(this.nodes.progress), w2.appendChild(this.nodes.input), w2;
  }
  /**
   * Activates link data fetching by url
   *
   * @param {PasteEvent|KeyboardEvent} event - fetching could be fired by a pase or keydown events
   */
  startFetching(w2) {
    let d4 = this.nodes.input.textContent;
    w2.type === "paste" && (d4 = (w2.clipboardData || window.clipboardData).getData("text")), this.removeErrorStyle(), this.fetchLinkData(d4);
  }
  /**
   * If previous link data fetching failed, remove error styles
   */
  removeErrorStyle() {
    this.nodes.inputHolder.classList.remove(this.CSS.inputError), this.nodes.inputHolder.insertBefore(this.nodes.progress, this.nodes.input);
  }
  /**
   * Select LinkTool input content by CMD+A
   *
   * @param {KeyboardEvent} event - keydown
   */
  selectLinkUrl(w2) {
    w2.preventDefault(), w2.stopPropagation();
    const d4 = window.getSelection(), v2 = new Range(), a3 = d4.anchorNode.parentNode.closest(`.${this.CSS.inputHolder}`).querySelector(`.${this.CSS.inputEl}`);
    v2.selectNodeContents(a3), d4.removeAllRanges(), d4.addRange(v2);
  }
  /**
   * Prepare link preview holder
   *
   * @returns {HTMLElement}
   */
  prepareLinkPreview() {
    const w2 = this.make("a", this.CSS.linkContent, {
      target: "_blank",
      rel: "nofollow noindex noreferrer"
    });
    return this.nodes.linkImage = this.make("div", this.CSS.linkImage), this.nodes.linkTitle = this.make("div", this.CSS.linkTitle), this.nodes.linkDescription = this.make("p", this.CSS.linkDescription), this.nodes.linkText = this.make("span", this.CSS.linkText), w2;
  }
  /**
   * Compose link preview from fetched data
   *
   * @param {metaData} meta - link meta data
   */
  showLinkPreview({ image: w2, title: d4, description: v2 }) {
    this.nodes.container.appendChild(this.nodes.linkContent), w2 && w2.url && (this.nodes.linkImage.style.backgroundImage = "url(" + w2.url + ")", this.nodes.linkContent.appendChild(this.nodes.linkImage)), d4 && (this.nodes.linkTitle.textContent = d4, this.nodes.linkContent.appendChild(this.nodes.linkTitle)), v2 && (this.nodes.linkDescription.textContent = v2, this.nodes.linkContent.appendChild(this.nodes.linkDescription)), this.nodes.linkContent.classList.add(this.CSS.linkContentRendered), this.nodes.linkContent.setAttribute("href", this.data.link), this.nodes.linkContent.appendChild(this.nodes.linkText);
    try {
      this.nodes.linkText.textContent = new URL(this.data.link).hostname;
    } catch {
      this.nodes.linkText.textContent = this.data.link;
    }
  }
  /**
   * Show loading progress bar
   */
  showProgress() {
    this.nodes.progress.classList.add(this.CSS.progressLoading);
  }
  /**
   * Hide loading progress bar
   *
   * @returns {Promise<void>}
   */
  hideProgress() {
    return new Promise((w2) => {
      this.nodes.progress.classList.remove(this.CSS.progressLoading), this.nodes.progress.classList.add(this.CSS.progressLoaded), setTimeout(w2, 500);
    });
  }
  /**
   * If data fetching failed, set input error style
   */
  applyErrorStyle() {
    this.nodes.inputHolder.classList.add(this.CSS.inputError), this.nodes.progress.remove();
  }
  /**
   * Sends to backend pasted url and receives link data
   *
   * @param {string} url - link source url
   */
  async fetchLinkData(w2) {
    this.showProgress(), this.data = { link: w2 };
    try {
      const { body: d4 } = await R$1.get({
        url: this.config.endpoint,
        headers: this.config.headers,
        data: {
          url: w2
        }
      });
      this.onFetch(d4);
    } catch {
      this.fetchingFailed(this.api.i18n.t("Couldn't fetch the link data"));
    }
  }
  /**
   * Link data fetching callback
   *
   * @param {UploadResponseFormat} response - backend response
   */
  onFetch(w2) {
    if (!w2 || !w2.success) {
      this.fetchingFailed(this.api.i18n.t("Couldn't get this link data, try the other one"));
      return;
    }
    const d4 = w2.meta, v2 = w2.link || this.data.link;
    if (this.data = {
      meta: d4,
      link: v2
    }, !d4) {
      this.fetchingFailed(this.api.i18n.t("Wrong response format from the server"));
      return;
    }
    this.hideProgress().then(() => {
      this.nodes.inputHolder.remove(), this.showLinkPreview(d4);
    });
  }
  /**
   * Handle link fetching errors
   *
   * @private
   *
   * @param {string} errorMessage - message to explain user what he should do
   */
  fetchingFailed(w2) {
    this.api.notifier.show({
      message: w2,
      style: "error"
    }), this.applyErrorStyle();
  }
  /**
   * Helper method for elements creation
   *
   * @param {string} tagName - name of creating element
   * @param {string|string[]} [classNames] - list of CSS classes to add
   * @param {object} [attributes] - object with attributes to add
   * @returns {HTMLElement}
   */
  make(w2, d4 = null, v2 = {}) {
    const c4 = document.createElement(w2);
    Array.isArray(d4) ? c4.classList.add(...d4) : d4 && c4.classList.add(d4);
    for (const i2 in v2)
      c4[i2] = v2[i2];
    return c4;
  }
};
(function() {
  try {
    if (typeof document < "u") {
      var o3 = document.createElement("style");
      o3.appendChild(document.createTextNode('.image-tool{--bg-color: #cdd1e0;--front-color: #388ae5;--border-color: #e8e8eb}.image-tool__image{border-radius:3px;overflow:hidden;margin-bottom:10px}.image-tool__image-picture{max-width:100%;vertical-align:bottom;display:block}.image-tool__image-preloader{width:50px;height:50px;border-radius:50%;background-size:cover;margin:auto;position:relative;background-color:var(--bg-color);background-position:center center}.image-tool__image-preloader:after{content:"";position:absolute;z-index:3;width:60px;height:60px;border-radius:50%;border:2px solid var(--bg-color);border-top-color:var(--front-color);left:50%;top:50%;margin-top:-30px;margin-left:-30px;animation:image-preloader-spin 2s infinite linear;box-sizing:border-box}.image-tool__caption[contentEditable=true][data-placeholder]:before{position:absolute!important;content:attr(data-placeholder);color:#707684;font-weight:400;display:none}.image-tool__caption[contentEditable=true][data-placeholder]:empty:before{display:block}.image-tool__caption[contentEditable=true][data-placeholder]:empty:focus:before{display:none}.image-tool--empty .image-tool__image,.image-tool--empty .image-tool__caption,.image-tool--loading .image-tool__caption{display:none}.image-tool .cdx-button{display:flex;align-items:center;justify-content:center}.image-tool .cdx-button svg{height:auto;margin:0 6px 0 0}.image-tool--filled .cdx-button,.image-tool--filled .image-tool__image-preloader{display:none}.image-tool--loading .image-tool__image{min-height:200px;display:flex;border:1px solid var(--border-color);background-color:#fff}.image-tool--loading .image-tool__image-picture,.image-tool--loading .cdx-button{display:none}.image-tool--withBorder .image-tool__image{border:1px solid var(--border-color)}.image-tool--withBackground .image-tool__image{padding:15px;background:var(--bg-color)}.image-tool--withBackground .image-tool__image-picture{max-width:60%;margin:0 auto}.image-tool--stretched .image-tool__image-picture{width:100%}@keyframes image-preloader-spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}')), document.head.appendChild(o3);
    }
  } catch (e2) {
    console.error("vite-plugin-css-injected-by-js", e2);
  }
})();
const R2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19V19C9.13623 19 8.20435 19 7.46927 18.6955C6.48915 18.2895 5.71046 17.5108 5.30448 16.5307C5 15.7956 5 14.8638 5 13V12C5 9.19108 5 7.78661 5.67412 6.77772C5.96596 6.34096 6.34096 5.96596 6.77772 5.67412C7.78661 5 9.19108 5 12 5H13.5C14.8956 5 15.5933 5 16.1611 5.17224C17.4395 5.56004 18.44 6.56046 18.8278 7.83886C19 8.40666 19 9.10444 19 10.5V10.5"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 13V16M16 19V16M19 16H16M16 16H13"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6.5 17.5L17.5 6.5"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.9919 10.5H19.0015"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.9919 19H11.0015"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13L13 5"/></svg>', H = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.9919 9.5H19.0015"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.5 5H14.5096"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M14.625 5H15C17.2091 5 19 6.79086 19 9V9.375"/><path stroke="currentColor" stroke-width="2" d="M9.375 5L9 5C6.79086 5 5 6.79086 5 9V9.375"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.3725 5H9.38207"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 9.5H5.00957"/><path stroke="currentColor" stroke-width="2" d="M9.375 19H9C6.79086 19 5 17.2091 5 15V14.625"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.3725 19H9.38207"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 14.55H5.00957"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 13V16M16 19V16M19 16H16M16 16H13"/></svg>', L = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.13968 15.32L8.69058 11.5661C9.02934 11.2036 9.48873 11 9.96774 11C10.4467 11 10.9061 11.2036 11.2449 11.5661L15.3871 16M13.5806 14.0664L15.0132 12.533C15.3519 12.1705 15.8113 11.9668 16.2903 11.9668C16.7693 11.9668 17.2287 12.1705 17.5675 12.533L18.841 13.9634"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.7778 9.33331H13.7867"/></svg>', D = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9L20 12L17 15"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 12H20"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 9L4 12L7 15"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 12H10"/></svg>';
function M(E2, a3 = null, i2 = {}) {
  const c4 = document.createElement(E2);
  Array.isArray(a3) ? c4.classList.add(...a3) : a3 && c4.classList.add(a3);
  for (const r4 in i2)
    c4[r4] = i2[r4];
  return c4;
}
class j {
  /**
   * @param {object} ui - image tool Ui module
   * @param {object} ui.api - Editor.js API
   * @param {ImageConfig} ui.config - user config
   * @param {Function} ui.onSelectFile - callback for clicks on Select file button
   * @param {boolean} ui.readOnly - read-only mode flag
   */
  constructor({ api: a3, config: i2, onSelectFile: c4, readOnly: r4 }) {
    this.api = a3, this.config = i2, this.onSelectFile = c4, this.readOnly = r4, this.nodes = {
      wrapper: M("div", [this.CSS.baseClass, this.CSS.wrapper]),
      imageContainer: M("div", [this.CSS.imageContainer]),
      fileButton: this.createFileButton(),
      imageEl: void 0,
      imagePreloader: M("div", this.CSS.imagePreloader),
      caption: M("div", [this.CSS.input, this.CSS.caption], {
        contentEditable: !this.readOnly
      })
    }, this.nodes.caption.dataset.placeholder = this.config.captionPlaceholder, this.nodes.imageContainer.appendChild(this.nodes.imagePreloader), this.nodes.wrapper.appendChild(this.nodes.imageContainer), this.nodes.wrapper.appendChild(this.nodes.caption), this.nodes.wrapper.appendChild(this.nodes.fileButton);
  }
  /**
   * CSS classes
   *
   * @returns {object}
   */
  get CSS() {
    return {
      baseClass: this.api.styles.block,
      loading: this.api.styles.loader,
      input: this.api.styles.input,
      button: this.api.styles.button,
      /**
       * Tool's classes
       */
      wrapper: "image-tool",
      imageContainer: "image-tool__image",
      imagePreloader: "image-tool__image-preloader",
      imageEl: "image-tool__image-picture",
      caption: "image-tool__caption"
    };
  }
  /**
   * Ui statuses:
   * - empty
   * - uploading
   * - filled
   *
   * @returns {{EMPTY: string, UPLOADING: string, FILLED: string}}
   */
  static get status() {
    return {
      EMPTY: "empty",
      UPLOADING: "loading",
      FILLED: "filled"
    };
  }
  /**
   * Renders tool UI
   *
   * @param {ImageToolData} toolData - saved tool data
   * @returns {Element}
   */
  render(a3) {
    return !a3.file || Object.keys(a3.file).length === 0 ? this.toggleStatus(j.status.EMPTY) : this.toggleStatus(j.status.UPLOADING), this.nodes.wrapper;
  }
  /**
   * Creates upload-file button
   *
   * @returns {Element}
   */
  createFileButton() {
    const a3 = M("div", [this.CSS.button]);
    return a3.innerHTML = this.config.buttonContent || `${L} ${this.api.i18n.t("Select an Image")}`, a3.addEventListener("click", () => {
      this.onSelectFile();
    }), a3;
  }
  /**
   * Shows uploading preloader
   *
   * @param {string} src - preview source
   * @returns {void}
   */
  showPreloader(a3) {
    this.nodes.imagePreloader.style.backgroundImage = `url(${a3})`, this.toggleStatus(j.status.UPLOADING);
  }
  /**
   * Hide uploading preloader
   *
   * @returns {void}
   */
  hidePreloader() {
    this.nodes.imagePreloader.style.backgroundImage = "", this.toggleStatus(j.status.EMPTY);
  }
  /**
   * Shows an image
   *
   * @param {string} url - image source
   * @returns {void}
   */
  fillImage(a3) {
    const i2 = /\.mp4$/.test(a3) ? "VIDEO" : "IMG", c4 = {
      src: a3
    };
    let r4 = "load";
    i2 === "VIDEO" && (c4.autoplay = true, c4.loop = true, c4.muted = true, c4.playsinline = true, r4 = "loadeddata"), this.nodes.imageEl = M(i2, this.CSS.imageEl, c4), this.nodes.imageEl.addEventListener(r4, () => {
      this.toggleStatus(j.status.FILLED), this.nodes.imagePreloader && (this.nodes.imagePreloader.style.backgroundImage = "");
    }), this.nodes.imageContainer.appendChild(this.nodes.imageEl);
  }
  /**
   * Shows caption input
   *
   * @param {string} text - caption text
   * @returns {void}
   */
  fillCaption(a3) {
    this.nodes.caption && (this.nodes.caption.innerHTML = a3);
  }
  /**
   * Changes UI status
   *
   * @param {string} status - see {@link Ui.status} constants
   * @returns {void}
   */
  toggleStatus(a3) {
    for (const i2 in j.status)
      Object.prototype.hasOwnProperty.call(j.status, i2) && this.nodes.wrapper.classList.toggle(`${this.CSS.wrapper}--${j.status[i2]}`, a3 === j.status[i2]);
  }
  /**
   * Apply visual representation of activated tune
   *
   * @param {string} tuneName - one of available tunes {@link Tunes.tunes}
   * @param {boolean} status - true for enable, false for disable
   * @returns {void}
   */
  applyTune(a3, i2) {
    this.nodes.wrapper.classList.toggle(`${this.CSS.wrapper}--${a3}`, i2);
  }
}
function x(E2) {
  return E2 && E2.__esModule && Object.prototype.hasOwnProperty.call(E2, "default") ? E2.default : E2;
}
var I3 = { exports: {} };
(function(E2, a3) {
  (function(i2, c4) {
    E2.exports = c4();
  })(window, function() {
    return function(i2) {
      var c4 = {};
      function r4(n3) {
        if (c4[n3])
          return c4[n3].exports;
        var o3 = c4[n3] = { i: n3, l: false, exports: {} };
        return i2[n3].call(o3.exports, o3, o3.exports, r4), o3.l = true, o3.exports;
      }
      return r4.m = i2, r4.c = c4, r4.d = function(n3, o3, d4) {
        r4.o(n3, o3) || Object.defineProperty(n3, o3, { enumerable: true, get: d4 });
      }, r4.r = function(n3) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(n3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n3, "__esModule", { value: true });
      }, r4.t = function(n3, o3) {
        if (1 & o3 && (n3 = r4(n3)), 8 & o3 || 4 & o3 && typeof n3 == "object" && n3 && n3.__esModule)
          return n3;
        var d4 = /* @__PURE__ */ Object.create(null);
        if (r4.r(d4), Object.defineProperty(d4, "default", { enumerable: true, value: n3 }), 2 & o3 && typeof n3 != "string")
          for (var b3 in n3)
            r4.d(d4, b3, (function(u3) {
              return n3[u3];
            }).bind(null, b3));
        return d4;
      }, r4.n = function(n3) {
        var o3 = n3 && n3.__esModule ? function() {
          return n3.default;
        } : function() {
          return n3;
        };
        return r4.d(o3, "a", o3), o3;
      }, r4.o = function(n3, o3) {
        return Object.prototype.hasOwnProperty.call(n3, o3);
      }, r4.p = "", r4(r4.s = 3);
    }([function(i2, c4) {
      var r4;
      r4 = function() {
        return this;
      }();
      try {
        r4 = r4 || new Function("return this")();
      } catch {
        typeof window == "object" && (r4 = window);
      }
      i2.exports = r4;
    }, function(i2, c4, r4) {
      (function(n3) {
        var o3 = r4(2), d4 = setTimeout;
        function b3() {
        }
        function u3(e2) {
          if (!(this instanceof u3))
            throw new TypeError("Promises must be constructed via new");
          if (typeof e2 != "function")
            throw new TypeError("not a function");
          this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], t2(e2, this);
        }
        function f2(e2, l2) {
          for (; e2._state === 3; )
            e2 = e2._value;
          e2._state !== 0 ? (e2._handled = true, u3._immediateFn(function() {
            var s4 = e2._state === 1 ? l2.onFulfilled : l2.onRejected;
            if (s4 !== null) {
              var g2;
              try {
                g2 = s4(e2._value);
              } catch (m3) {
                return void y3(l2.promise, m3);
              }
              p2(l2.promise, g2);
            } else
              (e2._state === 1 ? p2 : y3)(l2.promise, e2._value);
          })) : e2._deferreds.push(l2);
        }
        function p2(e2, l2) {
          try {
            if (l2 === e2)
              throw new TypeError("A promise cannot be resolved with itself.");
            if (l2 && (typeof l2 == "object" || typeof l2 == "function")) {
              var s4 = l2.then;
              if (l2 instanceof u3)
                return e2._state = 3, e2._value = l2, void w2(e2);
              if (typeof s4 == "function")
                return void t2((g2 = s4, m3 = l2, function() {
                  g2.apply(m3, arguments);
                }), e2);
            }
            e2._state = 1, e2._value = l2, w2(e2);
          } catch (h2) {
            y3(e2, h2);
          }
          var g2, m3;
        }
        function y3(e2, l2) {
          e2._state = 2, e2._value = l2, w2(e2);
        }
        function w2(e2) {
          e2._state === 2 && e2._deferreds.length === 0 && u3._immediateFn(function() {
            e2._handled || u3._unhandledRejectionFn(e2._value);
          });
          for (var l2 = 0, s4 = e2._deferreds.length; l2 < s4; l2++)
            f2(e2, e2._deferreds[l2]);
          e2._deferreds = null;
        }
        function v2(e2, l2, s4) {
          this.onFulfilled = typeof e2 == "function" ? e2 : null, this.onRejected = typeof l2 == "function" ? l2 : null, this.promise = s4;
        }
        function t2(e2, l2) {
          var s4 = false;
          try {
            e2(function(g2) {
              s4 || (s4 = true, p2(l2, g2));
            }, function(g2) {
              s4 || (s4 = true, y3(l2, g2));
            });
          } catch (g2) {
            if (s4)
              return;
            s4 = true, y3(l2, g2);
          }
        }
        u3.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, u3.prototype.then = function(e2, l2) {
          var s4 = new this.constructor(b3);
          return f2(this, new v2(e2, l2, s4)), s4;
        }, u3.prototype.finally = o3.a, u3.all = function(e2) {
          return new u3(function(l2, s4) {
            if (!e2 || e2.length === void 0)
              throw new TypeError("Promise.all accepts an array");
            var g2 = Array.prototype.slice.call(e2);
            if (g2.length === 0)
              return l2([]);
            var m3 = g2.length;
            function h2(T2, C2) {
              try {
                if (C2 && (typeof C2 == "object" || typeof C2 == "function")) {
                  var S2 = C2.then;
                  if (typeof S2 == "function")
                    return void S2.call(C2, function(O2) {
                      h2(T2, O2);
                    }, s4);
                }
                g2[T2] = C2, --m3 == 0 && l2(g2);
              } catch (O2) {
                s4(O2);
              }
            }
            for (var k2 = 0; k2 < g2.length; k2++)
              h2(k2, g2[k2]);
          });
        }, u3.resolve = function(e2) {
          return e2 && typeof e2 == "object" && e2.constructor === u3 ? e2 : new u3(function(l2) {
            l2(e2);
          });
        }, u3.reject = function(e2) {
          return new u3(function(l2, s4) {
            s4(e2);
          });
        }, u3.race = function(e2) {
          return new u3(function(l2, s4) {
            for (var g2 = 0, m3 = e2.length; g2 < m3; g2++)
              e2[g2].then(l2, s4);
          });
        }, u3._immediateFn = typeof n3 == "function" && function(e2) {
          n3(e2);
        } || function(e2) {
          d4(e2, 0);
        }, u3._unhandledRejectionFn = function(e2) {
          typeof console < "u" && console && console.warn("Possible Unhandled Promise Rejection:", e2);
        }, c4.a = u3;
      }).call(this, r4(5).setImmediate);
    }, function(i2, c4, r4) {
      c4.a = function(n3) {
        var o3 = this.constructor;
        return this.then(function(d4) {
          return o3.resolve(n3()).then(function() {
            return d4;
          });
        }, function(d4) {
          return o3.resolve(n3()).then(function() {
            return o3.reject(d4);
          });
        });
      };
    }, function(i2, c4, r4) {
      function n3(t2) {
        return (n3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e2) {
          return typeof e2;
        } : function(e2) {
          return e2 && typeof Symbol == "function" && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
        })(t2);
      }
      r4(4);
      var o3, d4, b3, u3, f2, p2, y3, w2 = r4(8), v2 = (d4 = function(t2) {
        return new Promise(function(e2, l2) {
          t2 = u3(t2), (t2 = f2(t2)).beforeSend && t2.beforeSend();
          var s4 = window.XMLHttpRequest ? new window.XMLHttpRequest() : new window.ActiveXObject("Microsoft.XMLHTTP");
          s4.open(t2.method, t2.url), s4.setRequestHeader("X-Requested-With", "XMLHttpRequest"), Object.keys(t2.headers).forEach(function(m3) {
            var h2 = t2.headers[m3];
            s4.setRequestHeader(m3, h2);
          });
          var g2 = t2.ratio;
          s4.upload.addEventListener("progress", function(m3) {
            var h2 = Math.round(m3.loaded / m3.total * 100), k2 = Math.ceil(h2 * g2 / 100);
            t2.progress(Math.min(k2, 100));
          }, false), s4.addEventListener("progress", function(m3) {
            var h2 = Math.round(m3.loaded / m3.total * 100), k2 = Math.ceil(h2 * (100 - g2) / 100) + g2;
            t2.progress(Math.min(k2, 100));
          }, false), s4.onreadystatechange = function() {
            if (s4.readyState === 4) {
              var m3 = s4.response;
              try {
                m3 = JSON.parse(m3);
              } catch {
              }
              var h2 = w2.parseHeaders(s4.getAllResponseHeaders()), k2 = { body: m3, code: s4.status, headers: h2 };
              y3(s4.status) ? e2(k2) : l2(k2);
            }
          }, s4.send(t2.data);
        });
      }, b3 = function(t2) {
        return t2.method = "POST", d4(t2);
      }, u3 = function() {
        var t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (t2.url && typeof t2.url != "string")
          throw new Error("Url must be a string");
        if (t2.url = t2.url || "", t2.method && typeof t2.method != "string")
          throw new Error("`method` must be a string or null");
        if (t2.method = t2.method ? t2.method.toUpperCase() : "GET", t2.headers && n3(t2.headers) !== "object")
          throw new Error("`headers` must be an object or null");
        if (t2.headers = t2.headers || {}, t2.type && (typeof t2.type != "string" || !Object.values(o3).includes(t2.type)))
          throw new Error("`type` must be taken from module's «contentType» library");
        if (t2.progress && typeof t2.progress != "function")
          throw new Error("`progress` must be a function or null");
        if (t2.progress = t2.progress || function(e2) {
        }, t2.beforeSend = t2.beforeSend || function(e2) {
        }, t2.ratio && typeof t2.ratio != "number")
          throw new Error("`ratio` must be a number");
        if (t2.ratio < 0 || t2.ratio > 100)
          throw new Error("`ratio` must be in a 0-100 interval");
        if (t2.ratio = t2.ratio || 90, t2.accept && typeof t2.accept != "string")
          throw new Error("`accept` must be a string with a list of allowed mime-types");
        if (t2.accept = t2.accept || "*/*", t2.multiple && typeof t2.multiple != "boolean")
          throw new Error("`multiple` must be a true or false");
        if (t2.multiple = t2.multiple || false, t2.fieldName && typeof t2.fieldName != "string")
          throw new Error("`fieldName` must be a string");
        return t2.fieldName = t2.fieldName || "files", t2;
      }, f2 = function(t2) {
        switch (t2.method) {
          case "GET":
            var e2 = p2(t2.data, o3.URLENCODED);
            delete t2.data, t2.url = /\?/.test(t2.url) ? t2.url + "&" + e2 : t2.url + "?" + e2;
            break;
          case "POST":
          case "PUT":
          case "DELETE":
          case "UPDATE":
            var l2 = function() {
              return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).type || o3.JSON;
            }(t2);
            (w2.isFormData(t2.data) || w2.isFormElement(t2.data)) && (l2 = o3.FORM), t2.data = p2(t2.data, l2), l2 !== v2.contentType.FORM && (t2.headers["content-type"] = l2);
        }
        return t2;
      }, p2 = function() {
        var t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        switch (arguments.length > 1 ? arguments[1] : void 0) {
          case o3.URLENCODED:
            return w2.urlEncode(t2);
          case o3.JSON:
            return w2.jsonEncode(t2);
          case o3.FORM:
            return w2.formEncode(t2);
          default:
            return t2;
        }
      }, y3 = function(t2) {
        return t2 >= 200 && t2 < 300;
      }, { contentType: o3 = { URLENCODED: "application/x-www-form-urlencoded; charset=utf-8", FORM: "multipart/form-data", JSON: "application/json; charset=utf-8" }, request: d4, get: function(t2) {
        return t2.method = "GET", d4(t2);
      }, post: b3, transport: function(t2) {
        return t2 = u3(t2), w2.selectFiles(t2).then(function(e2) {
          for (var l2 = new FormData(), s4 = 0; s4 < e2.length; s4++)
            l2.append(t2.fieldName, e2[s4], e2[s4].name);
          w2.isObject(t2.data) && Object.keys(t2.data).forEach(function(m3) {
            var h2 = t2.data[m3];
            l2.append(m3, h2);
          });
          var g2 = t2.beforeSend;
          return t2.beforeSend = function() {
            return g2(e2);
          }, t2.data = l2, b3(t2);
        });
      }, selectFiles: function(t2) {
        return delete (t2 = u3(t2)).beforeSend, w2.selectFiles(t2);
      } });
      i2.exports = v2;
    }, function(i2, c4, r4) {
      r4.r(c4);
      var n3 = r4(1);
      window.Promise = window.Promise || n3.a;
    }, function(i2, c4, r4) {
      (function(n3) {
        var o3 = n3 !== void 0 && n3 || typeof self < "u" && self || window, d4 = Function.prototype.apply;
        function b3(u3, f2) {
          this._id = u3, this._clearFn = f2;
        }
        c4.setTimeout = function() {
          return new b3(d4.call(setTimeout, o3, arguments), clearTimeout);
        }, c4.setInterval = function() {
          return new b3(d4.call(setInterval, o3, arguments), clearInterval);
        }, c4.clearTimeout = c4.clearInterval = function(u3) {
          u3 && u3.close();
        }, b3.prototype.unref = b3.prototype.ref = function() {
        }, b3.prototype.close = function() {
          this._clearFn.call(o3, this._id);
        }, c4.enroll = function(u3, f2) {
          clearTimeout(u3._idleTimeoutId), u3._idleTimeout = f2;
        }, c4.unenroll = function(u3) {
          clearTimeout(u3._idleTimeoutId), u3._idleTimeout = -1;
        }, c4._unrefActive = c4.active = function(u3) {
          clearTimeout(u3._idleTimeoutId);
          var f2 = u3._idleTimeout;
          f2 >= 0 && (u3._idleTimeoutId = setTimeout(function() {
            u3._onTimeout && u3._onTimeout();
          }, f2));
        }, r4(6), c4.setImmediate = typeof self < "u" && self.setImmediate || n3 !== void 0 && n3.setImmediate || this && this.setImmediate, c4.clearImmediate = typeof self < "u" && self.clearImmediate || n3 !== void 0 && n3.clearImmediate || this && this.clearImmediate;
      }).call(this, r4(0));
    }, function(i2, c4, r4) {
      (function(n3, o3) {
        (function(d4, b3) {
          if (!d4.setImmediate) {
            var u3, f2, p2, y3, w2, v2 = 1, t2 = {}, e2 = false, l2 = d4.document, s4 = Object.getPrototypeOf && Object.getPrototypeOf(d4);
            s4 = s4 && s4.setTimeout ? s4 : d4, {}.toString.call(d4.process) === "[object process]" ? u3 = function(h2) {
              o3.nextTick(function() {
                m3(h2);
              });
            } : function() {
              if (d4.postMessage && !d4.importScripts) {
                var h2 = true, k2 = d4.onmessage;
                return d4.onmessage = function() {
                  h2 = false;
                }, d4.postMessage("", "*"), d4.onmessage = k2, h2;
              }
            }() ? (y3 = "setImmediate$" + Math.random() + "$", w2 = function(h2) {
              h2.source === d4 && typeof h2.data == "string" && h2.data.indexOf(y3) === 0 && m3(+h2.data.slice(y3.length));
            }, d4.addEventListener ? d4.addEventListener("message", w2, false) : d4.attachEvent("onmessage", w2), u3 = function(h2) {
              d4.postMessage(y3 + h2, "*");
            }) : d4.MessageChannel ? ((p2 = new MessageChannel()).port1.onmessage = function(h2) {
              m3(h2.data);
            }, u3 = function(h2) {
              p2.port2.postMessage(h2);
            }) : l2 && "onreadystatechange" in l2.createElement("script") ? (f2 = l2.documentElement, u3 = function(h2) {
              var k2 = l2.createElement("script");
              k2.onreadystatechange = function() {
                m3(h2), k2.onreadystatechange = null, f2.removeChild(k2), k2 = null;
              }, f2.appendChild(k2);
            }) : u3 = function(h2) {
              setTimeout(m3, 0, h2);
            }, s4.setImmediate = function(h2) {
              typeof h2 != "function" && (h2 = new Function("" + h2));
              for (var k2 = new Array(arguments.length - 1), T2 = 0; T2 < k2.length; T2++)
                k2[T2] = arguments[T2 + 1];
              var C2 = { callback: h2, args: k2 };
              return t2[v2] = C2, u3(v2), v2++;
            }, s4.clearImmediate = g2;
          }
          function g2(h2) {
            delete t2[h2];
          }
          function m3(h2) {
            if (e2)
              setTimeout(m3, 0, h2);
            else {
              var k2 = t2[h2];
              if (k2) {
                e2 = true;
                try {
                  (function(T2) {
                    var C2 = T2.callback, S2 = T2.args;
                    switch (S2.length) {
                      case 0:
                        C2();
                        break;
                      case 1:
                        C2(S2[0]);
                        break;
                      case 2:
                        C2(S2[0], S2[1]);
                        break;
                      case 3:
                        C2(S2[0], S2[1], S2[2]);
                        break;
                      default:
                        C2.apply(b3, S2);
                    }
                  })(k2);
                } finally {
                  g2(h2), e2 = false;
                }
              }
            }
          }
        })(typeof self > "u" ? n3 === void 0 ? this : n3 : self);
      }).call(this, r4(0), r4(7));
    }, function(i2, c4) {
      var r4, n3, o3 = i2.exports = {};
      function d4() {
        throw new Error("setTimeout has not been defined");
      }
      function b3() {
        throw new Error("clearTimeout has not been defined");
      }
      function u3(s4) {
        if (r4 === setTimeout)
          return setTimeout(s4, 0);
        if ((r4 === d4 || !r4) && setTimeout)
          return r4 = setTimeout, setTimeout(s4, 0);
        try {
          return r4(s4, 0);
        } catch {
          try {
            return r4.call(null, s4, 0);
          } catch {
            return r4.call(this, s4, 0);
          }
        }
      }
      (function() {
        try {
          r4 = typeof setTimeout == "function" ? setTimeout : d4;
        } catch {
          r4 = d4;
        }
        try {
          n3 = typeof clearTimeout == "function" ? clearTimeout : b3;
        } catch {
          n3 = b3;
        }
      })();
      var f2, p2 = [], y3 = false, w2 = -1;
      function v2() {
        y3 && f2 && (y3 = false, f2.length ? p2 = f2.concat(p2) : w2 = -1, p2.length && t2());
      }
      function t2() {
        if (!y3) {
          var s4 = u3(v2);
          y3 = true;
          for (var g2 = p2.length; g2; ) {
            for (f2 = p2, p2 = []; ++w2 < g2; )
              f2 && f2[w2].run();
            w2 = -1, g2 = p2.length;
          }
          f2 = null, y3 = false, function(m3) {
            if (n3 === clearTimeout)
              return clearTimeout(m3);
            if ((n3 === b3 || !n3) && clearTimeout)
              return n3 = clearTimeout, clearTimeout(m3);
            try {
              n3(m3);
            } catch {
              try {
                return n3.call(null, m3);
              } catch {
                return n3.call(this, m3);
              }
            }
          }(s4);
        }
      }
      function e2(s4, g2) {
        this.fun = s4, this.array = g2;
      }
      function l2() {
      }
      o3.nextTick = function(s4) {
        var g2 = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var m3 = 1; m3 < arguments.length; m3++)
            g2[m3 - 1] = arguments[m3];
        p2.push(new e2(s4, g2)), p2.length !== 1 || y3 || u3(t2);
      }, e2.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, o3.title = "browser", o3.browser = true, o3.env = {}, o3.argv = [], o3.version = "", o3.versions = {}, o3.on = l2, o3.addListener = l2, o3.once = l2, o3.off = l2, o3.removeListener = l2, o3.removeAllListeners = l2, o3.emit = l2, o3.prependListener = l2, o3.prependOnceListener = l2, o3.listeners = function(s4) {
        return [];
      }, o3.binding = function(s4) {
        throw new Error("process.binding is not supported");
      }, o3.cwd = function() {
        return "/";
      }, o3.chdir = function(s4) {
        throw new Error("process.chdir is not supported");
      }, o3.umask = function() {
        return 0;
      };
    }, function(i2, c4, r4) {
      function n3(d4, b3) {
        for (var u3 = 0; u3 < b3.length; u3++) {
          var f2 = b3[u3];
          f2.enumerable = f2.enumerable || false, f2.configurable = true, "value" in f2 && (f2.writable = true), Object.defineProperty(d4, f2.key, f2);
        }
      }
      var o3 = r4(9);
      i2.exports = function() {
        function d4() {
          (function(p2, y3) {
            if (!(p2 instanceof y3))
              throw new TypeError("Cannot call a class as a function");
          })(this, d4);
        }
        var b3, u3, f2;
        return b3 = d4, f2 = [{ key: "urlEncode", value: function(p2) {
          return o3(p2);
        } }, { key: "jsonEncode", value: function(p2) {
          return JSON.stringify(p2);
        } }, { key: "formEncode", value: function(p2) {
          if (this.isFormData(p2))
            return p2;
          if (this.isFormElement(p2))
            return new FormData(p2);
          if (this.isObject(p2)) {
            var y3 = new FormData();
            return Object.keys(p2).forEach(function(w2) {
              var v2 = p2[w2];
              y3.append(w2, v2);
            }), y3;
          }
          throw new Error("`data` must be an instance of Object, FormData or <FORM> HTMLElement");
        } }, { key: "isObject", value: function(p2) {
          return Object.prototype.toString.call(p2) === "[object Object]";
        } }, { key: "isFormData", value: function(p2) {
          return p2 instanceof FormData;
        } }, { key: "isFormElement", value: function(p2) {
          return p2 instanceof HTMLFormElement;
        } }, { key: "selectFiles", value: function() {
          var p2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          return new Promise(function(y3, w2) {
            var v2 = document.createElement("INPUT");
            v2.type = "file", p2.multiple && v2.setAttribute("multiple", "multiple"), p2.accept && v2.setAttribute("accept", p2.accept), v2.style.display = "none", document.body.appendChild(v2), v2.addEventListener("change", function(t2) {
              var e2 = t2.target.files;
              y3(e2), document.body.removeChild(v2);
            }, false), v2.click();
          });
        } }, { key: "parseHeaders", value: function(p2) {
          var y3 = p2.trim().split(/[\r\n]+/), w2 = {};
          return y3.forEach(function(v2) {
            var t2 = v2.split(": "), e2 = t2.shift(), l2 = t2.join(": ");
            e2 && (w2[e2] = l2);
          }), w2;
        } }], (u3 = null) && n3(b3.prototype, u3), f2 && n3(b3, f2), d4;
      }();
    }, function(i2, c4) {
      var r4 = function(o3) {
        return encodeURIComponent(o3).replace(/[!'()*]/g, escape).replace(/%20/g, "+");
      }, n3 = function(o3, d4, b3, u3) {
        return d4 = d4 || null, b3 = b3 || "&", u3 = u3 || null, o3 ? function(f2) {
          for (var p2 = new Array(), y3 = 0; y3 < f2.length; y3++)
            f2[y3] && p2.push(f2[y3]);
          return p2;
        }(Object.keys(o3).map(function(f2) {
          var p2, y3, w2 = f2;
          if (u3 && (w2 = u3 + "[" + w2 + "]"), typeof o3[f2] == "object" && o3[f2] !== null)
            p2 = n3(o3[f2], null, b3, w2);
          else {
            d4 && (y3 = w2, w2 = !isNaN(parseFloat(y3)) && isFinite(y3) ? d4 + Number(w2) : w2);
            var v2 = o3[f2];
            v2 = (v2 = (v2 = (v2 = v2 === true ? "1" : v2) === false ? "0" : v2) === 0 ? "0" : v2) || "", p2 = r4(w2) + "=" + r4(v2);
          }
          return p2;
        })).join(b3).replace(/[!'()*]/g, "") : "";
      };
      i2.exports = n3;
    }]);
  });
})(I3);
var U = I3.exports;
const F = /* @__PURE__ */ x(U);
function _2(E2) {
  return E2 && typeof E2.then == "function";
}
class B {
  /**
   * @param {object} params - uploader module params
   * @param {ImageConfig} params.config - image tool config
   * @param {Function} params.onUpload - one callback for all uploading (file, url, d-n-d, pasting)
   * @param {Function} params.onError - callback for uploading errors
   */
  constructor({ config: a3, onUpload: i2, onError: c4 }) {
    this.config = a3, this.onUpload = i2, this.onError = c4;
  }
  /**
   * Handle clicks on the upload file button
   * Fires ajax.transport()
   *
   * @param {Function} onPreview - callback fired when preview is ready
   */
  uploadSelectedFile({ onPreview: a3 }) {
    const i2 = function(r4) {
      const n3 = new FileReader();
      n3.readAsDataURL(r4), n3.onload = (o3) => {
        a3(o3.target.result);
      };
    };
    let c4;
    this.config.uploader && typeof this.config.uploader.uploadByFile == "function" ? c4 = F.selectFiles({ accept: this.config.types }).then((r4) => {
      i2(r4[0]);
      const n3 = this.config.uploader.uploadByFile(r4[0]);
      return _2(n3) || console.warn("Custom uploader method uploadByFile should return a Promise"), n3;
    }) : c4 = F.transport({
      url: this.config.endpoints.byFile,
      data: this.config.additionalRequestData,
      accept: this.config.types,
      headers: this.config.additionalRequestHeaders,
      beforeSend: (r4) => {
        i2(r4[0]);
      },
      fieldName: this.config.field
    }).then((r4) => r4.body), c4.then((r4) => {
      this.onUpload(r4);
    }).catch((r4) => {
      this.onError(r4);
    });
  }
  /**
   * Handle clicks on the upload file button
   * Fires ajax.post()
   *
   * @param {string} url - image source url
   */
  uploadByUrl(a3) {
    let i2;
    this.config.uploader && typeof this.config.uploader.uploadByUrl == "function" ? (i2 = this.config.uploader.uploadByUrl(a3), _2(i2) || console.warn("Custom uploader method uploadByUrl should return a Promise")) : i2 = F.post({
      url: this.config.endpoints.byUrl,
      data: Object.assign({
        url: a3
      }, this.config.additionalRequestData),
      type: F.contentType.JSON,
      headers: this.config.additionalRequestHeaders
    }).then((c4) => c4.body), i2.then((c4) => {
      this.onUpload(c4);
    }).catch((c4) => {
      this.onError(c4);
    });
  }
  /**
   * Handle clicks on the upload file button
   * Fires ajax.post()
   *
   * @param {File} file - file pasted by drag-n-drop
   * @param {Function} onPreview - file pasted by drag-n-drop
   */
  uploadByFile(a3, { onPreview: i2 }) {
    const c4 = new FileReader();
    c4.readAsDataURL(a3), c4.onload = (n3) => {
      i2(n3.target.result);
    };
    let r4;
    if (this.config.uploader && typeof this.config.uploader.uploadByFile == "function")
      r4 = this.config.uploader.uploadByFile(a3), _2(r4) || console.warn("Custom uploader method uploadByFile should return a Promise");
    else {
      const n3 = new FormData();
      n3.append(this.config.field, a3), this.config.additionalRequestData && Object.keys(this.config.additionalRequestData).length && Object.entries(this.config.additionalRequestData).forEach(([o3, d4]) => {
        n3.append(o3, d4);
      }), r4 = F.post({
        url: this.config.endpoints.byFile,
        data: n3,
        type: F.contentType.JSON,
        headers: this.config.additionalRequestHeaders
      }).then((o3) => o3.body);
    }
    r4.then((n3) => {
      this.onUpload(n3);
    }).catch((n3) => {
      this.onError(n3);
    });
  }
}
/**
 * Image Tool for the Editor.js
 *
 * @author CodeX <team@codex.so>
 * @license MIT
 * @see {@link https://github.com/editor-js/image}
 *
 * To developers.
 * To simplify Tool structure, we split it to 4 parts:
 *  1) index.js — main Tool's interface, public API and methods for working with data
 *  2) uploader.js — module that has methods for sending files via AJAX: from device, by URL or File pasting
 *  3) ui.js — module for UI manipulations: render, showing preloader, etc
 *  4) tunes.js — working with Block Tunes: render buttons, handle clicks
 *
 * For debug purposes there is a testing server
 * that can save uploaded files and return a Response {@link UploadResponseFormat}
 *
 *       $ node dev/server.js
 *
 * It will expose 8008 port, so you can pass http://localhost:8008 with the Tools config:
 *
 * image: {
 *   class: ImageTool,
 *   config: {
 *     endpoints: {
 *       byFile: 'http://localhost:8008/uploadFile',
 *       byUrl: 'http://localhost:8008/fetchUrl',
 *     }
 *   },
 * },
 */
class P2 {
  /**
   * Notify core that read-only mode is supported
   *
   * @returns {boolean}
   */
  static get isReadOnlySupported() {
    return true;
  }
  /**
   * Get Tool toolbox settings
   * icon - Tool icon's SVG
   * title - title to show in toolbox
   *
   * @returns {{icon: string, title: string}}
   */
  static get toolbox() {
    return {
      icon: L,
      title: "Image"
    };
  }
  /**
   * Available image tools
   *
   * @returns {Array}
   */
  static get tunes() {
    return [
      {
        name: "withBorder",
        icon: H,
        title: "With border",
        toggle: true
      },
      {
        name: "stretched",
        icon: D,
        title: "Stretch image",
        toggle: true
      },
      {
        name: "withBackground",
        icon: R2,
        title: "With background",
        toggle: true
      }
    ];
  }
  /**
   * @param {object} tool - tool properties got from editor.js
   * @param {ImageToolData} tool.data - previously saved data
   * @param {ImageConfig} tool.config - user config for Tool
   * @param {object} tool.api - Editor.js API
   * @param {boolean} tool.readOnly - read-only mode flag
   * @param {BlockAPI|{}} tool.block - current Block API
   */
  constructor({ data: a3, config: i2, api: c4, readOnly: r4, block: n3 }) {
    this.api = c4, this.readOnly = r4, this.block = n3, this.config = {
      endpoints: i2.endpoints || "",
      additionalRequestData: i2.additionalRequestData || {},
      additionalRequestHeaders: i2.additionalRequestHeaders || {},
      field: i2.field || "image",
      types: i2.types || "image/*",
      captionPlaceholder: this.api.i18n.t(i2.captionPlaceholder || "Caption"),
      buttonContent: i2.buttonContent || "",
      uploader: i2.uploader || void 0,
      actions: i2.actions || []
    }, this.uploader = new B({
      config: this.config,
      onUpload: (o3) => this.onUpload(o3),
      onError: (o3) => this.uploadingFailed(o3)
    }), this.ui = new j({
      api: c4,
      config: this.config,
      onSelectFile: () => {
        this.uploader.uploadSelectedFile({
          onPreview: (o3) => {
            this.ui.showPreloader(o3);
          }
        });
      },
      readOnly: r4
    }), this._data = {}, this.data = a3;
  }
  /**
   * Renders Block content
   *
   * @public
   *
   * @returns {HTMLDivElement}
   */
  render() {
    return this.ui.render(this.data);
  }
  /**
   * Validate data: check if Image exists
   *
   * @param {ImageToolData} savedData — data received after saving
   * @returns {boolean} false if saved data is not correct, otherwise true
   * @public
   */
  validate(a3) {
    return a3.file && a3.file.url;
  }
  /**
   * Return Block data
   *
   * @public
   *
   * @returns {ImageToolData}
   */
  save() {
    const a3 = this.ui.nodes.caption;
    return this._data.caption = a3.innerHTML, this.data;
  }
  /**
   * Returns configuration for block tunes: add background, add border, stretch image
   *
   * @public
   *
   * @returns {Array}
   */
  renderSettings() {
    return P2.tunes.concat(this.config.actions).map((i2) => ({
      icon: i2.icon,
      label: this.api.i18n.t(i2.title),
      name: i2.name,
      toggle: i2.toggle,
      isActive: this.data[i2.name],
      onActivate: () => {
        if (typeof i2.action == "function") {
          i2.action(i2.name);
          return;
        }
        this.tuneToggled(i2.name);
      }
    }));
  }
  /**
   * Fires after clicks on the Toolbox Image Icon
   * Initiates click on the Select File button
   *
   * @public
   */
  appendCallback() {
    this.ui.nodes.fileButton.click();
  }
  /**
   * Specify paste substitutes
   *
   * @see {@link https://github.com/codex-team/editor.js/blob/master/docs/tools.md#paste-handling}
   * @returns {{tags: string[], patterns: object<string, RegExp>, files: {extensions: string[], mimeTypes: string[]}}}
   */
  static get pasteConfig() {
    return {
      /**
       * Paste HTML into Editor
       */
      tags: [
        {
          img: { src: true }
        }
      ],
      /**
       * Paste URL of image into the Editor
       */
      patterns: {
        image: /https?:\/\/\S+\.(gif|jpe?g|tiff|png|svg|webp)(\?[a-z0-9=]*)?$/i
      },
      /**
       * Drag n drop file from into the Editor
       */
      files: {
        mimeTypes: ["image/*"]
      }
    };
  }
  /**
   * Specify paste handlers
   *
   * @public
   * @see {@link https://github.com/codex-team/editor.js/blob/master/docs/tools.md#paste-handling}
   * @param {CustomEvent} event - editor.js custom paste event
   *                              {@link https://github.com/codex-team/editor.js/blob/master/types/tools/paste-events.d.ts}
   * @returns {void}
   */
  async onPaste(a3) {
    switch (a3.type) {
      case "tag": {
        const i2 = a3.detail.data;
        if (/^blob:/.test(i2.src)) {
          const r4 = await (await fetch(i2.src)).blob();
          this.uploadFile(r4);
          break;
        }
        this.uploadUrl(i2.src);
        break;
      }
      case "pattern": {
        const i2 = a3.detail.data;
        this.uploadUrl(i2);
        break;
      }
      case "file": {
        const i2 = a3.detail.file;
        this.uploadFile(i2);
        break;
      }
    }
  }
  /**
   * Private methods
   * ̿̿ ̿̿ ̿̿ ̿'̿'\̵͇̿̿\з= ( ▀ ͜͞ʖ▀) =ε/̵͇̿̿/’̿’̿ ̿ ̿̿ ̿̿ ̿̿
   */
  /**
   * Stores all Tool's data
   *
   * @private
   *
   * @param {ImageToolData} data - data in Image Tool format
   */
  set data(a3) {
    this.image = a3.file, this._data.caption = a3.caption || "", this.ui.fillCaption(this._data.caption), P2.tunes.forEach(({ name: i2 }) => {
      const c4 = typeof a3[i2] < "u" ? a3[i2] === true || a3[i2] === "true" : false;
      this.setTune(i2, c4);
    });
  }
  /**
   * Return Tool data
   *
   * @private
   *
   * @returns {ImageToolData}
   */
  get data() {
    return this._data;
  }
  /**
   * Set new image file
   *
   * @private
   *
   * @param {object} file - uploaded file data
   */
  set image(a3) {
    this._data.file = a3 || {}, a3 && a3.url && this.ui.fillImage(a3.url);
  }
  /**
   * File uploading callback
   *
   * @private
   *
   * @param {UploadResponseFormat} response - uploading server response
   * @returns {void}
   */
  onUpload(a3) {
    a3.success && a3.file ? this.image = a3.file : this.uploadingFailed("incorrect response: " + JSON.stringify(a3));
  }
  /**
   * Handle uploader errors
   *
   * @private
   * @param {string} errorText - uploading error text
   * @returns {void}
   */
  uploadingFailed(a3) {
    console.log("Image Tool: uploading failed because of", a3), this.api.notifier.show({
      message: this.api.i18n.t("Couldn’t upload image. Please try another."),
      style: "error"
    }), this.ui.hidePreloader();
  }
  /**
   * Callback fired when Block Tune is activated
   *
   * @private
   *
   * @param {string} tuneName - tune that has been clicked
   * @returns {void}
   */
  tuneToggled(a3) {
    this.setTune(a3, !this._data[a3]);
  }
  /**
   * Set one tune
   *
   * @param {string} tuneName - {@link Tunes.tunes}
   * @param {boolean} value - tune state
   * @returns {void}
   */
  setTune(a3, i2) {
    this._data[a3] = i2, this.ui.applyTune(a3, i2), a3 === "stretched" && Promise.resolve().then(() => {
      this.block.stretched = i2;
    }).catch((c4) => {
      console.error(c4);
    });
  }
  /**
   * Show preloader and upload image file
   *
   * @param {File} file - file that is currently uploading (from paste)
   * @returns {void}
   */
  uploadFile(a3) {
    this.uploader.uploadByFile(a3, {
      onPreview: (i2) => {
        this.ui.showPreloader(i2);
      }
    });
  }
  /**
   * Show preloader and upload image by target url
   *
   * @param {string} url - url pasted
   * @returns {void}
   */
  uploadUrl(a3) {
    this.ui.showPreloader(a3), this.uploader.uploadByUrl(a3);
  }
}
(function() {
  try {
    if (typeof document < "u") {
      var e2 = document.createElement("style");
      e2.appendChild(document.createTextNode(".ce-rawtool__textarea{min-height:200px;resize:vertical;border-radius:8px;border:0;background-color:#1e2128;font-family:Menlo,Monaco,Consolas,Courier New,monospace;font-size:12px;line-height:1.6;letter-spacing:-.2px;color:#a1a7b6;overscroll-behavior:contain}")), document.head.appendChild(e2);
    }
  } catch (o3) {
    console.error("vite-plugin-css-injected-by-js", o3);
  }
})();
const a$3 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16.6954 5C17.912 5 18.8468 6.07716 18.6755 7.28165L17.426 16.0659C17.3183 16.8229 16.7885 17.4522 16.061 17.6873L12.6151 18.8012C12.2152 18.9304 11.7848 18.9304 11.3849 18.8012L7.93898 17.6873C7.21148 17.4522 6.6817 16.8229 6.57403 16.0659L5.32454 7.28165C5.15322 6.07716 6.088 5 7.30461 5H16.6954Z"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 8.4H9L9.42857 11.7939H14.5714L14.3571 13.2788L14.1429 14.7636L12 15.4L9.85714 14.7636L9.77143 14.3394"/></svg>';
/**
 * Raw HTML Tool for CodeX Editor
 *
 * @author CodeX (team@codex.so)
 * @copyright CodeX 2018
 * @license The MIT License (MIT)
 */
let r$1 = class r2 {
  /**
   * Notify core that read-only mode is supported
   *
   * @returns {boolean}
   */
  static get isReadOnlySupported() {
    return true;
  }
  /**
   * Should this tool be displayed at the Editor's Toolbox
   *
   * @returns {boolean}
   * @public
   */
  static get displayInToolbox() {
    return true;
  }
  /**
   * Allow to press Enter inside the RawTool textarea
   *
   * @returns {boolean}
   * @public
   */
  static get enableLineBreaks() {
    return true;
  }
  /**
   * Get Tool toolbox settings
   * icon - Tool icon's SVG
   * title - title to show in toolbox
   *
   * @returns {{icon: string, title: string}}
   */
  static get toolbox() {
    return {
      icon: a$3,
      title: "Raw HTML"
    };
  }
  /**
   * @typedef {object} RawData — plugin saved data
   * @param {string} html - previously saved HTML code
   * @property
   */
  /**
   * Render plugin`s main Element and fill it with saved data
   *
   * @param {RawData} data — previously saved HTML data
   * @param {object} config - user config for Tool
   * @param {object} api - CodeX Editor API
   * @param {boolean} readOnly - read-only mode flag
   */
  constructor({ data: t2, config: e2, api: s4, readOnly: i2 }) {
    this.api = s4, this.readOnly = i2, this.placeholder = e2.placeholder || r2.DEFAULT_PLACEHOLDER, this.CSS = {
      baseClass: this.api.styles.block,
      input: this.api.styles.input,
      wrapper: "ce-rawtool",
      textarea: "ce-rawtool__textarea"
    }, this.data = {
      html: t2.html || ""
    }, this.textarea = null, this.resizeDebounce = null;
  }
  /**
   * Return Tool's view
   *
   * @returns {HTMLDivElement} this.element - RawTool's wrapper
   * @public
   */
  render() {
    const t2 = document.createElement("div"), e2 = 100;
    return this.textarea = document.createElement("textarea"), t2.classList.add(this.CSS.baseClass, this.CSS.wrapper), this.textarea.classList.add(this.CSS.textarea, this.CSS.input), this.textarea.textContent = this.data.html, this.textarea.placeholder = this.placeholder, this.readOnly ? this.textarea.disabled = true : this.textarea.addEventListener("input", () => {
      this.onInput();
    }), t2.appendChild(this.textarea), setTimeout(() => {
      this.resize();
    }, e2), t2;
  }
  /**
   * Extract Tool's data from the view
   *
   * @param {HTMLDivElement} rawToolsWrapper - RawTool's wrapper, containing textarea with raw HTML code
   * @returns {RawData} - raw HTML code
   * @public
   */
  save(t2) {
    return {
      html: t2.querySelector("textarea").value
    };
  }
  /**
   * Default placeholder for RawTool's textarea
   *
   * @public
   * @returns {string}
   */
  static get DEFAULT_PLACEHOLDER() {
    return "Enter HTML code";
  }
  /**
   * Automatic sanitize config
   */
  static get sanitize() {
    return {
      html: true
      // Allow HTML tags
    };
  }
  /**
   * Textarea change event
   *
   * @returns {void}
   */
  onInput() {
    this.resizeDebounce && clearTimeout(this.resizeDebounce), this.resizeDebounce = setTimeout(() => {
      this.resize();
    }, 200);
  }
  /**
   * Resize textarea to fit whole height
   *
   * @returns {void}
   */
  resize() {
    this.textarea.style.height = "auto", this.textarea.style.height = this.textarea.scrollHeight + "px";
  }
};
(function() {
  try {
    if (typeof document < "u") {
      var e2 = document.createElement("style");
      e2.appendChild(document.createTextNode(".ce-header{padding:.6em 0 3px;margin:0;line-height:1.25em;outline:none}.ce-header p,.ce-header div{padding:0!important;margin:0!important}.ce-header[contentEditable=true][data-placeholder]:before{position:absolute;content:attr(data-placeholder);color:#707684;font-weight:400;display:none;cursor:text}.ce-header[contentEditable=true][data-placeholder]:empty:before{display:block}.ce-header[contentEditable=true][data-placeholder]:empty:focus:before{display:none}")), document.head.appendChild(e2);
    }
  } catch (t2) {
    console.error("vite-plugin-css-injected-by-js", t2);
  }
})();
const i$1 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M19 17V10.2135C19 10.1287 18.9011 10.0824 18.836 10.1367L16 12.5"/></svg>', a$2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 11C16 10 19 9.5 19 12C19 13.9771 16.0684 13.9997 16.0012 16.8981C15.9999 16.9533 16.0448 17 16.1 17L19.3 17"/></svg>', l$1 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 11C16 10.5 16.8323 10 17.6 10C18.3677 10 19.5 10.311 19.5 11.5C19.5 12.5315 18.7474 12.9022 18.548 12.9823C18.5378 12.9864 18.5395 13.0047 18.5503 13.0063C18.8115 13.0456 20 13.3065 20 14.8C20 16 19.5 17 17.8 17C17.8 17 16 17 16 16.3"/></svg>', o$3 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M18 10L15.2834 14.8511C15.246 14.9178 15.294 15 15.3704 15C16.8489 15 18.7561 15 20.2 15M19 17C19 15.7187 19 14.8813 19 13.6"/></svg>', h$1 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 15.9C16 15.9 16.3768 17 17.8 17C19.5 17 20 15.6199 20 14.7C20 12.7323 17.6745 12.0486 16.1635 12.9894C16.094 13.0327 16 12.9846 16 12.9027V10.1C16 10.0448 16.0448 10 16.1 10H19.8"/></svg>', d$2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M19.5 10C16.5 10.5 16 13.3285 16 15M16 15V15C16 16.1046 16.8954 17 18 17H18.3246C19.3251 17 20.3191 16.3492 20.2522 15.3509C20.0612 12.4958 16 12.6611 16 15Z"/></svg>', u2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M9 7L9 12M9 17V12M9 12L15 12M15 7V12M15 17L15 12"/></svg>';
/**
 * Header block for the Editor.js.
 *
 * @author CodeX (team@ifmo.su)
 * @copyright CodeX 2018
 * @license MIT
 * @version 2.0.0
 */
let c$2 = class c2 {
  /**
   * Render plugin`s main Element and fill it with saved data
   *
   * @param {{data: HeaderData, config: HeaderConfig, api: object}}
   *   data — previously saved data
   *   config - user config for Tool
   *   api - Editor.js API
   *   readOnly - read only mode flag
   */
  constructor({ data: e2, config: t2, api: s4, readOnly: r4 }) {
    this.api = s4, this.readOnly = r4, this._CSS = {
      block: this.api.styles.block,
      wrapper: "ce-header"
    }, this._settings = t2, this._data = this.normalizeData(e2), this._element = this.getTag();
  }
  /**
   * Normalize input data
   *
   * @param {HeaderData} data - saved data to process
   *
   * @returns {HeaderData}
   * @private
   */
  normalizeData(e2) {
    const t2 = {};
    return typeof e2 != "object" && (e2 = {}), t2.text = e2.text || "", t2.level = parseInt(e2.level) || this.defaultLevel.number, t2;
  }
  /**
   * Return Tool's view
   *
   * @returns {HTMLHeadingElement}
   * @public
   */
  render() {
    return this._element;
  }
  /**
   * Returns header block tunes config
   *
   * @returns {Array}
   */
  renderSettings() {
    return this.levels.map((e2) => ({
      icon: e2.svg,
      label: this.api.i18n.t(`Heading ${e2.number}`),
      onActivate: () => this.setLevel(e2.number),
      closeOnActivate: true,
      isActive: this.currentLevel.number === e2.number
    }));
  }
  /**
   * Callback for Block's settings buttons
   *
   * @param {number} level - level to set
   */
  setLevel(e2) {
    this.data = {
      level: e2,
      text: this.data.text
    };
  }
  /**
   * Method that specified how to merge two Text blocks.
   * Called by Editor.js by backspace at the beginning of the Block
   *
   * @param {HeaderData} data - saved data to merger with current block
   * @public
   */
  merge(e2) {
    const t2 = {
      text: this.data.text + e2.text,
      level: this.data.level
    };
    this.data = t2;
  }
  /**
   * Validate Text block data:
   * - check for emptiness
   *
   * @param {HeaderData} blockData — data received after saving
   * @returns {boolean} false if saved data is not correct, otherwise true
   * @public
   */
  validate(e2) {
    return e2.text.trim() !== "";
  }
  /**
   * Extract Tool's data from the view
   *
   * @param {HTMLHeadingElement} toolsContent - Text tools rendered view
   * @returns {HeaderData} - saved data
   * @public
   */
  save(e2) {
    return {
      text: e2.innerHTML,
      level: this.currentLevel.number
    };
  }
  /**
   * Allow Header to be converted to/from other blocks
   */
  static get conversionConfig() {
    return {
      export: "text",
      // use 'text' property for other blocks
      import: "text"
      // fill 'text' property from other block's export string
    };
  }
  /**
   * Sanitizer Rules
   */
  static get sanitize() {
    return {
      level: false,
      text: {}
    };
  }
  /**
   * Returns true to notify core that read-only is supported
   *
   * @returns {boolean}
   */
  static get isReadOnlySupported() {
    return true;
  }
  /**
   * Get current Tools`s data
   *
   * @returns {HeaderData} Current data
   * @private
   */
  get data() {
    return this._data.text = this._element.innerHTML, this._data.level = this.currentLevel.number, this._data;
  }
  /**
   * Store data in plugin:
   * - at the this._data property
   * - at the HTML
   *
   * @param {HeaderData} data — data to set
   * @private
   */
  set data(e2) {
    if (this._data = this.normalizeData(e2), e2.level !== void 0 && this._element.parentNode) {
      const t2 = this.getTag();
      t2.innerHTML = this._element.innerHTML, this._element.parentNode.replaceChild(t2, this._element), this._element = t2;
    }
    e2.text !== void 0 && (this._element.innerHTML = this._data.text || "");
  }
  /**
   * Get tag for target level
   * By default returns second-leveled header
   *
   * @returns {HTMLElement}
   */
  getTag() {
    const e2 = document.createElement(this.currentLevel.tag);
    return e2.innerHTML = this._data.text || "", e2.classList.add(this._CSS.wrapper), e2.contentEditable = this.readOnly ? "false" : "true", e2.dataset.placeholder = this.api.i18n.t(this._settings.placeholder || ""), e2;
  }
  /**
   * Get current level
   *
   * @returns {level}
   */
  get currentLevel() {
    let e2 = this.levels.find((t2) => t2.number === this._data.level);
    return e2 || (e2 = this.defaultLevel), e2;
  }
  /**
   * Return default level
   *
   * @returns {level}
   */
  get defaultLevel() {
    if (this._settings.defaultLevel) {
      const e2 = this.levels.find((t2) => t2.number === this._settings.defaultLevel);
      if (e2)
        return e2;
      console.warn("(ง'̀-'́)ง Heading Tool: the default level specified was not found in available levels");
    }
    return this.levels[1];
  }
  /**
   * @typedef {object} level
   * @property {number} number - level number
   * @property {string} tag - tag corresponds with level number
   * @property {string} svg - icon
   */
  /**
   * Available header levels
   *
   * @returns {level[]}
   */
  get levels() {
    const e2 = [
      {
        number: 1,
        tag: "H1",
        svg: i$1
      },
      {
        number: 2,
        tag: "H2",
        svg: a$2
      },
      {
        number: 3,
        tag: "H3",
        svg: l$1
      },
      {
        number: 4,
        tag: "H4",
        svg: o$3
      },
      {
        number: 5,
        tag: "H5",
        svg: h$1
      },
      {
        number: 6,
        tag: "H6",
        svg: d$2
      }
    ];
    return this._settings.levels ? e2.filter(
      (t2) => this._settings.levels.includes(t2.number)
    ) : e2;
  }
  /**
   * Handle H1-H6 tags on paste to substitute it with header Tool
   *
   * @param {PasteEvent} event - event with pasted content
   */
  onPaste(e2) {
    const t2 = e2.detail.data;
    let s4 = this.defaultLevel.number;
    switch (t2.tagName) {
      case "H1":
        s4 = 1;
        break;
      case "H2":
        s4 = 2;
        break;
      case "H3":
        s4 = 3;
        break;
      case "H4":
        s4 = 4;
        break;
      case "H5":
        s4 = 5;
        break;
      case "H6":
        s4 = 6;
        break;
    }
    this._settings.levels && (s4 = this._settings.levels.reduce((r4, n3) => Math.abs(n3 - s4) < Math.abs(r4 - s4) ? n3 : r4)), this.data = {
      level: s4,
      text: t2.innerHTML
    };
  }
  /**
   * Used by Editor.js paste handling API.
   * Provides configuration to handle H1-H6 tags.
   *
   * @returns {{handler: (function(HTMLElement): {text: string}), tags: string[]}}
   */
  static get pasteConfig() {
    return {
      tags: ["H1", "H2", "H3", "H4", "H5", "H6"]
    };
  }
  /**
   * Get Tool toolbox settings
   * icon - Tool icon's SVG
   * title - title to show in toolbox
   *
   * @returns {{icon: string, title: string}}
   */
  static get toolbox() {
    return {
      icon: u2,
      title: "Heading"
    };
  }
};
(function() {
  try {
    if (typeof document < "u") {
      var t2 = document.createElement("style");
      t2.appendChild(document.createTextNode(".cdx-quote-icon svg{transform:rotate(180deg)}.cdx-quote{margin:0}.cdx-quote__text{min-height:158px;margin-bottom:10px}.cdx-quote [contentEditable=true][data-placeholder]:before{position:absolute;content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.cdx-quote [contentEditable=true][data-placeholder]:empty:before{opacity:1}.cdx-quote [contentEditable=true][data-placeholder]:empty:focus:before{opacity:0}.cdx-quote-settings{display:flex}.cdx-quote-settings .cdx-settings-button{width:50%}")), document.head.appendChild(t2);
    }
  } catch (e2) {
    console.error("vite-plugin-css-injected-by-js", e2);
  }
})();
const a$1 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M18 7L6 7"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M18 17H6"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 12L8 12"/></svg>', c$1 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M17 7L5 7"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M17 17H5"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M13 12L5 12"/></svg>', l = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 10.8182L9 10.8182C8.80222 10.8182 8.60888 10.7649 8.44443 10.665C8.27998 10.5651 8.15181 10.4231 8.07612 10.257C8.00043 10.0909 7.98063 9.90808 8.01922 9.73174C8.0578 9.55539 8.15304 9.39341 8.29289 9.26627C8.43275 9.13913 8.61093 9.05255 8.80491 9.01747C8.99889 8.98239 9.19996 9.00039 9.38268 9.0692C9.56541 9.13801 9.72159 9.25453 9.83147 9.40403C9.94135 9.55353 10 9.72929 10 9.90909L10 12.1818C10 12.664 9.78929 13.1265 9.41421 13.4675C9.03914 13.8084 8.53043 14 8 14"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 10.8182L15 10.8182C14.8022 10.8182 14.6089 10.7649 14.4444 10.665C14.28 10.5651 14.1518 10.4231 14.0761 10.257C14.0004 10.0909 13.9806 9.90808 14.0192 9.73174C14.0578 9.55539 14.153 9.39341 14.2929 9.26627C14.4327 9.13913 14.6109 9.05255 14.8049 9.01747C14.9989 8.98239 15.2 9.00039 15.3827 9.0692C15.5654 9.13801 15.7216 9.25453 15.8315 9.40403C15.9414 9.55353 16 9.72929 16 9.90909L16 12.1818C16 12.664 15.7893 13.1265 15.4142 13.4675C15.0391 13.8084 14.5304 14 14 14"/></svg>';
class i {
  /**
   * Notify core that read-only mode is supported
   *
   * @returns {boolean}
   */
  static get isReadOnlySupported() {
    return true;
  }
  /**
   * Get Tool toolbox settings
   * icon - Tool icon's SVG
   * title - title to show in toolbox
   *
   * @returns {{icon: string, title: string}}
   */
  static get toolbox() {
    return {
      icon: l,
      title: "Quote"
    };
  }
  /**
   * Empty Quote is not empty Block
   *
   * @public
   * @returns {boolean}
   */
  static get contentless() {
    return true;
  }
  /**
   * Allow to press Enter inside the Quote
   *
   * @public
   * @returns {boolean}
   */
  static get enableLineBreaks() {
    return true;
  }
  /**
   * Default placeholder for quote text
   *
   * @public
   * @returns {string}
   */
  static get DEFAULT_QUOTE_PLACEHOLDER() {
    return "Enter a quote";
  }
  /**
   * Default placeholder for quote caption
   *
   * @public
   * @returns {string}
   */
  static get DEFAULT_CAPTION_PLACEHOLDER() {
    return "Enter a caption";
  }
  /**
   * Allowed quote alignments
   *
   * @public
   * @returns {{left: string, center: string}}
   */
  static get ALIGNMENTS() {
    return {
      left: "left",
      center: "center"
    };
  }
  /**
   * Default quote alignment
   *
   * @public
   * @returns {string}
   */
  static get DEFAULT_ALIGNMENT() {
    return i.ALIGNMENTS.left;
  }
  /**
   * Allow Quote to be converted to/from other blocks
   */
  static get conversionConfig() {
    return {
      /**
       * To create Quote data from string, simple fill 'text' property
       */
      import: "text",
      /**
       * To create string from Quote data, concatenate text and caption
       *
       * @param {QuoteData} quoteData
       * @returns {string}
       */
      export: function(t2) {
        return t2.caption ? `${t2.text} — ${t2.caption}` : t2.text;
      }
    };
  }
  /**
   * Tool`s styles
   *
   * @returns {{baseClass: string, wrapper: string, quote: string, input: string, caption: string}}
   */
  get CSS() {
    return {
      baseClass: this.api.styles.block,
      wrapper: "cdx-quote",
      text: "cdx-quote__text",
      input: this.api.styles.input,
      caption: "cdx-quote__caption"
    };
  }
  /**
   * Tool`s settings properties
   *
   * @returns {*[]}
   */
  get settings() {
    return [
      {
        name: "left",
        icon: c$1
      },
      {
        name: "center",
        icon: a$1
      }
    ];
  }
  /**
   * Render plugin`s main Element and fill it with saved data
   *
   * @param {{data: QuoteData, config: QuoteConfig, api: object}}
   *   data — previously saved data
   *   config - user config for Tool
   *   api - Editor.js API
   *   readOnly - read-only mode flag
   */
  constructor({ data: t2, config: e2, api: n3, readOnly: r4 }) {
    const { ALIGNMENTS: o3, DEFAULT_ALIGNMENT: s4 } = i;
    this.api = n3, this.readOnly = r4, this.quotePlaceholder = e2.quotePlaceholder || i.DEFAULT_QUOTE_PLACEHOLDER, this.captionPlaceholder = e2.captionPlaceholder || i.DEFAULT_CAPTION_PLACEHOLDER, this.data = {
      text: t2.text || "",
      caption: t2.caption || "",
      alignment: Object.values(o3).includes(t2.alignment) && t2.alignment || e2.defaultAlignment || s4
    };
  }
  /**
   * Create Quote Tool container with inputs
   *
   * @returns {Element}
   */
  render() {
    const t2 = this._make("blockquote", [this.CSS.baseClass, this.CSS.wrapper]), e2 = this._make("div", [this.CSS.input, this.CSS.text], {
      contentEditable: !this.readOnly,
      innerHTML: this.data.text
    }), n3 = this._make("div", [this.CSS.input, this.CSS.caption], {
      contentEditable: !this.readOnly,
      innerHTML: this.data.caption
    });
    return e2.dataset.placeholder = this.quotePlaceholder, n3.dataset.placeholder = this.captionPlaceholder, t2.appendChild(e2), t2.appendChild(n3), t2;
  }
  /**
   * Extract Quote data from Quote Tool element
   *
   * @param {HTMLDivElement} quoteElement - element to save
   * @returns {QuoteData}
   */
  save(t2) {
    const e2 = t2.querySelector(`.${this.CSS.text}`), n3 = t2.querySelector(`.${this.CSS.caption}`);
    return Object.assign(this.data, {
      text: e2.innerHTML,
      caption: n3.innerHTML
    });
  }
  /**
   * Sanitizer rules
   */
  static get sanitize() {
    return {
      text: {
        br: true
      },
      caption: {
        br: true
      },
      alignment: {}
    };
  }
  /**
   * Create wrapper for Tool`s settings buttons:
   * 1. Left alignment
   * 2. Center alignment
   *
   * @returns {TunesMenuConfig}
   *
   */
  renderSettings() {
    const t2 = (e2) => e2[0].toUpperCase() + e2.substr(1);
    return this.settings.map((e2) => ({
      icon: e2.icon,
      label: this.api.i18n.t(`Align ${t2(e2.name)}`),
      onActivate: () => this._toggleTune(e2.name),
      isActive: this.data.alignment === e2.name,
      closeOnActivate: true
    }));
  }
  /**
   * Toggle quote`s alignment
   *
   * @param {string} tune - alignment
   * @private
   */
  _toggleTune(t2) {
    this.data.alignment = t2;
  }
  /**
   * Helper for making Elements with attributes
   *
   * @param  {string} tagName           - new Element tag name
   * @param  {Array|string} classNames  - list or name of CSS classname(s)
   * @param  {object} attributes        - any attributes
   * @returns {Element}
   */
  _make(t2, e2 = null, n3 = {}) {
    const r4 = document.createElement(t2);
    Array.isArray(e2) ? r4.classList.add(...e2) : e2 && r4.classList.add(e2);
    for (const o3 in n3)
      r4[o3] = n3[o3];
    return r4;
  }
}
(function() {
  try {
    if (typeof document < "u") {
      var e2 = document.createElement("style");
      e2.appendChild(document.createTextNode(".cdx-marker{background:rgba(245,235,111,.29);padding:3px 0}")), document.head.appendChild(e2);
    }
  } catch (d4) {
    console.error("vite-plugin-css-injected-by-js", d4);
  }
})();
const o$2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-width="2" d="M11.3536 9.31802L12.7678 7.90381C13.5488 7.12276 14.8151 7.12276 15.5962 7.90381C16.3772 8.68486 16.3772 9.95119 15.5962 10.7322L14.182 12.1464M11.3536 9.31802L7.96729 12.7043C7.40889 13.2627 7.02827 13.9739 6.8734 14.7482L6.69798 15.6253C6.55804 16.325 7.17496 16.942 7.87468 16.802L8.75176 16.6266C9.52612 16.4717 10.2373 16.0911 10.7957 15.5327L14.182 12.1464M11.3536 9.31802L14.182 12.1464"/><line x1="15" x2="19" y1="17" y2="17" stroke="currentColor" stroke-linecap="round" stroke-width="2"/></svg>';
let s$2 = class s {
  /**
   * Class name for term-tag
   *
   * @type {string}
   */
  static get CSS() {
    return "cdx-marker";
  }
  /**
   * @param {{api: object}}  - Editor.js API
   */
  constructor({ api: t2 }) {
    this.api = t2, this.button = null, this.tag = "MARK", this.iconClasses = {
      base: this.api.styles.inlineToolButton,
      active: this.api.styles.inlineToolButtonActive
    };
  }
  /**
   * Specifies Tool as Inline Toolbar Tool
   *
   * @return {boolean}
   */
  static get isInline() {
    return true;
  }
  /**
   * Create button element for Toolbar
   *
   * @return {HTMLElement}
   */
  render() {
    return this.button = document.createElement("button"), this.button.type = "button", this.button.classList.add(this.iconClasses.base), this.button.innerHTML = this.toolboxIcon, this.button;
  }
  /**
   * Wrap/Unwrap selected fragment
   *
   * @param {Range} range - selected fragment
   */
  surround(t2) {
    if (!t2)
      return;
    let e2 = this.api.selection.findParentTag(this.tag, s.CSS);
    e2 ? this.unwrap(e2) : this.wrap(t2);
  }
  /**
   * Wrap selection with term-tag
   *
   * @param {Range} range - selected fragment
   */
  wrap(t2) {
    let e2 = document.createElement(this.tag);
    e2.classList.add(s.CSS), e2.appendChild(t2.extractContents()), t2.insertNode(e2), this.api.selection.expandToTag(e2);
  }
  /**
   * Unwrap term-tag
   *
   * @param {HTMLElement} termWrapper - term wrapper tag
   */
  unwrap(t2) {
    this.api.selection.expandToTag(t2);
    let e2 = window.getSelection(), n3 = e2.getRangeAt(0), i2 = n3.extractContents();
    t2.parentNode.removeChild(t2), n3.insertNode(i2), e2.removeAllRanges(), e2.addRange(n3);
  }
  /**
   * Check and change Term's state for current selection
   */
  checkState() {
    const t2 = this.api.selection.findParentTag(this.tag, s.CSS);
    this.button.classList.toggle(this.iconClasses.active, !!t2);
  }
  /**
   * Get Tool icon's SVG
   * @return {string}
   */
  get toolboxIcon() {
    return o$2;
  }
  /**
   * Sanitizer rule
   * @return {{mark: {class: string}}}
   */
  static get sanitize() {
    return {
      mark: {
        class: s.CSS
      }
    };
  }
};
(function() {
  try {
    if (typeof document < "u") {
      var e2 = document.createElement("style");
      e2.appendChild(document.createTextNode('.cdx-checklist{gap:6px;display:flex;flex-direction:column}.cdx-checklist__item{display:flex;box-sizing:content-box;align-items:flex-start}.cdx-checklist__item-text{outline:none;flex-grow:1;line-height:1.57em}.cdx-checklist__item-checkbox{width:22px;height:22px;display:flex;align-items:center;margin-right:8px;margin-top:calc(.785em - 11px);cursor:pointer}.cdx-checklist__item-checkbox svg{opacity:0;height:20px;width:20px;position:absolute;left:-1px;top:-1px;max-height:20px}@media (hover: hover){.cdx-checklist__item-checkbox:not(.cdx-checklist__item-checkbox--no-hover):hover .cdx-checklist__item-checkbox-check svg{opacity:1}}.cdx-checklist__item-checkbox-check{cursor:pointer;display:inline-block;flex-shrink:0;position:relative;width:20px;height:20px;box-sizing:border-box;margin-left:0;border-radius:5px;border:1px solid #C9C9C9;background:#fff}.cdx-checklist__item-checkbox-check:before{content:"";position:absolute;top:0;right:0;bottom:0;left:0;border-radius:100%;background-color:#369fff;visibility:hidden;pointer-events:none;transform:scale(1);transition:transform .4s ease-out,opacity .4s}@media (hover: hover){.cdx-checklist__item--checked .cdx-checklist__item-checkbox:not(.cdx-checklist__item--checked .cdx-checklist__item-checkbox--no-hover):hover .cdx-checklist__item-checkbox-check{background:#0059AB;border-color:#0059ab}}.cdx-checklist__item--checked .cdx-checklist__item-checkbox-check{background:#369FFF;border-color:#369fff}.cdx-checklist__item--checked .cdx-checklist__item-checkbox-check svg{opacity:1}.cdx-checklist__item--checked .cdx-checklist__item-checkbox-check svg path{stroke:#fff}.cdx-checklist__item--checked .cdx-checklist__item-checkbox-check:before{opacity:0;visibility:visible;transform:scale(2.5)}')), document.head.appendChild(e2);
    }
  } catch (c4) {
    console.error("vite-plugin-css-injected-by-js", c4);
  }
})();
const k = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7 12L10.4884 15.8372C10.5677 15.9245 10.705 15.9245 10.7844 15.8372L17 9"/></svg>', g = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M9.2 12L11.0586 13.8586C11.1367 13.9367 11.2633 13.9367 11.3414 13.8586L14.7 10.5"/><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/></svg>';
function d$1() {
  const s4 = document.activeElement, t2 = window.getSelection().getRangeAt(0), n3 = t2.cloneRange();
  return n3.selectNodeContents(s4), n3.setStart(t2.endContainer, t2.endOffset), n3.extractContents();
}
function C(s4) {
  const e2 = document.createElement("div");
  return e2.appendChild(s4), e2.innerHTML;
}
function c3(s4, e2 = null, t2 = {}) {
  const n3 = document.createElement(s4);
  Array.isArray(e2) ? n3.classList.add(...e2) : e2 && n3.classList.add(e2);
  for (const i2 in t2)
    n3[i2] = t2[i2];
  return n3;
}
function m2(s4) {
  return s4.innerHTML.replace("<br>", " ").trim();
}
function p(s4, e2 = false, t2 = void 0) {
  const n3 = document.createRange(), i2 = window.getSelection();
  n3.selectNodeContents(s4), t2 !== void 0 && (n3.setStart(s4, t2), n3.setEnd(s4, t2)), n3.collapse(e2), i2.removeAllRanges(), i2.addRange(n3);
}
Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
Element.prototype.closest || (Element.prototype.closest = function(s4) {
  let e2 = this;
  if (!document.documentElement.contains(e2))
    return null;
  do {
    if (e2.matches(s4))
      return e2;
    e2 = e2.parentElement || e2.parentNode;
  } while (e2 !== null && e2.nodeType === 1);
  return null;
});
class f {
  /**
   * Notify core that read-only mode is supported
   *
   * @returns {boolean}
   */
  static get isReadOnlySupported() {
    return true;
  }
  /**
   * Allow to use native Enter behaviour
   *
   * @returns {boolean}
   * @public
   */
  static get enableLineBreaks() {
    return true;
  }
  /**
   * Get Tool toolbox settings
   * icon - Tool icon's SVG
   * title - title to show in toolbox
   *
   * @returns {{icon: string, title: string}}
   */
  static get toolbox() {
    return {
      icon: g,
      title: "Checklist"
    };
  }
  /**
   * Allow Checkbox Tool to be converted to/from other block
   *
   * @returns {{export: Function, import: Function}}
   */
  static get conversionConfig() {
    return {
      /**
       * To create exported string from the checkbox, concatenate items by dot-symbol.
       *
       * @param {ChecklistData} data - checklist data to create a string from that
       * @returns {string}
       */
      export: (e2) => e2.items.map(({ text: t2 }) => t2).join(". "),
      /**
       * To create a checklist from other block's string, just put it at the first item
       *
       * @param {string} string - string to create list tool data from that
       * @returns {ChecklistData}
       */
      import: (e2) => ({
        items: [
          {
            text: e2,
            checked: false
          }
        ]
      })
    };
  }
  /**
   * Render plugin`s main Element and fill it with saved data
   *
   * @param {object} options - block constructor options
   * @param {ChecklistData} options.data - previously saved data
   * @param {object} options.config - user config for Tool
   * @param {object} options.api - Editor.js API
   * @param {boolean} options.readOnly - read only mode flag
   */
  constructor({ data: e2, config: t2, api: n3, readOnly: i2 }) {
    this._elements = {
      wrapper: null,
      items: []
    }, this.readOnly = i2, this.api = n3, this.data = e2 || {};
  }
  /**
   * Returns checklist tag with items
   *
   * @returns {Element}
   */
  render() {
    return this._elements.wrapper = c3("div", [this.CSS.baseBlock, this.CSS.wrapper]), this.data.items || (this.data.items = [
      {
        text: "",
        checked: false
      }
    ]), this.data.items.forEach((e2) => {
      const t2 = this.createChecklistItem(e2);
      this._elements.wrapper.appendChild(t2);
    }), this.readOnly ? this._elements.wrapper : (this._elements.wrapper.addEventListener("keydown", (e2) => {
      const [t2, n3] = [13, 8];
      switch (e2.keyCode) {
        case t2:
          this.enterPressed(e2);
          break;
        case n3:
          this.backspace(e2);
          break;
      }
    }, false), this._elements.wrapper.addEventListener("click", (e2) => {
      this.toggleCheckbox(e2);
    }), this._elements.wrapper);
  }
  /**
   * Return Checklist data
   *
   * @returns {ChecklistData}
   */
  save() {
    let e2 = this.items.map((t2) => {
      const n3 = this.getItemInput(t2);
      return {
        text: m2(n3),
        checked: t2.classList.contains(this.CSS.itemChecked)
      };
    });
    return e2 = e2.filter((t2) => t2.text.trim().length !== 0), {
      items: e2
    };
  }
  /**
   * Validate data: check if Checklist has items
   *
   * @param {ChecklistData} savedData — data received after saving
   * @returns {boolean} false if saved data is not correct, otherwise true
   * @public
   */
  validate(e2) {
    return !!e2.items.length;
  }
  /**
   * Toggle checklist item state
   *
   * @param {MouseEvent} event - click
   * @returns {void}
   */
  toggleCheckbox(e2) {
    const t2 = e2.target.closest(`.${this.CSS.item}`), n3 = t2.querySelector(`.${this.CSS.checkboxContainer}`);
    n3.contains(e2.target) && (t2.classList.toggle(this.CSS.itemChecked), n3.classList.add(this.CSS.noHover), n3.addEventListener("mouseleave", () => this.removeSpecialHoverBehavior(n3), { once: true }));
  }
  /**
   * Create Checklist items
   *
   * @param {ChecklistItem} item - data.item
   * @returns {Element} checkListItem - new element of checklist
   */
  createChecklistItem(e2 = {}) {
    const t2 = c3("div", this.CSS.item), n3 = c3("span", this.CSS.checkbox), i2 = c3("div", this.CSS.checkboxContainer), o3 = c3("div", this.CSS.textField, {
      innerHTML: e2.text ? e2.text : "",
      contentEditable: !this.readOnly
    });
    return e2.checked && t2.classList.add(this.CSS.itemChecked), n3.innerHTML = k, i2.appendChild(n3), t2.appendChild(i2), t2.appendChild(o3), t2;
  }
  /**
   * Append new elements to the list by pressing Enter
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  enterPressed(e2) {
    e2.preventDefault();
    const t2 = this.items, n3 = document.activeElement.closest(`.${this.CSS.item}`);
    if (t2.indexOf(n3) === t2.length - 1 && m2(this.getItemInput(n3)).length === 0) {
      const u3 = this.api.blocks.getCurrentBlockIndex();
      n3.remove(), this.api.blocks.insert(), this.api.caret.setToBlock(u3 + 1);
      return;
    }
    const a3 = d$1(), l2 = C(a3), r4 = this.createChecklistItem({
      text: l2,
      checked: false
    });
    this._elements.wrapper.insertBefore(r4, n3.nextSibling), p(this.getItemInput(r4), true);
  }
  /**
   * Handle backspace
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  backspace(e2) {
    const t2 = e2.target.closest(`.${this.CSS.item}`), n3 = this.items.indexOf(t2), i2 = this.items[n3 - 1];
    if (!i2 || !(window.getSelection().focusOffset === 0))
      return;
    e2.preventDefault();
    const l2 = d$1(), r4 = this.getItemInput(i2), h2 = r4.childNodes.length;
    r4.appendChild(l2), p(r4, void 0, h2), t2.remove();
  }
  /**
   * Styles
   *
   * @private
   * @returns {object<string>}
   */
  get CSS() {
    return {
      baseBlock: this.api.styles.block,
      wrapper: "cdx-checklist",
      item: "cdx-checklist__item",
      itemChecked: "cdx-checklist__item--checked",
      noHover: "cdx-checklist__item-checkbox--no-hover",
      checkbox: "cdx-checklist__item-checkbox-check",
      textField: "cdx-checklist__item-text",
      checkboxContainer: "cdx-checklist__item-checkbox"
    };
  }
  /**
   * Return all items elements
   *
   * @returns {Element[]}
   */
  get items() {
    return Array.from(this._elements.wrapper.querySelectorAll(`.${this.CSS.item}`));
  }
  /**
   * Removes class responsible for special hover behavior on an item
   * 
   * @private
   * @param {Element} el - item wrapper
   * @returns {Element}
   */
  removeSpecialHoverBehavior(e2) {
    e2.classList.remove(this.CSS.noHover);
  }
  /**
   * Find and return item's content editable element
   *
   * @private
   * @param {Element} el - item wrapper
   * @returns {Element}
   */
  getItemInput(e2) {
    return e2.querySelector(`.${this.CSS.textField}`);
  }
}
(function() {
  try {
    if (typeof document < "u") {
      var e2 = document.createElement("style");
      e2.appendChild(document.createTextNode('.ce-delimiter{line-height:1.6em;width:100%;text-align:center}.ce-delimiter:before{display:inline-block;content:"***";font-size:30px;line-height:65px;height:30px;letter-spacing:.2em}')), document.head.appendChild(e2);
    }
  } catch (t2) {
    console.error("vite-plugin-css-injected-by-js", t2);
  }
})();
const r3 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><line x1="6" x2="10" y1="12" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="14" x2="18" y1="12" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/></svg>';
/**
 * Delimiter Block for the Editor.js.
 *
 * @author CodeX (team@ifmo.su)
 * @copyright CodeX 2018
 * @license The MIT License (MIT)
 * @version 2.0.0
 */
let o$1 = class o {
  /**
   * Notify core that read-only mode is supported
   * @return {boolean}
   */
  static get isReadOnlySupported() {
    return true;
  }
  /**
   * Allow Tool to have no content
   * @return {boolean}
   */
  static get contentless() {
    return true;
  }
  /**
   * Render plugin`s main Element and fill it with saved data
   *
   * @param {{data: DelimiterData, config: object, api: object}}
   *   data — previously saved data
   *   config - user config for Tool
   *   api - Editor.js API
   */
  constructor({ data: t2, config: s4, api: e2 }) {
    this.api = e2, this._CSS = {
      block: this.api.styles.block,
      wrapper: "ce-delimiter"
    }, this._data = {}, this._element = this.drawView(), this.data = t2;
  }
  /**
   * Create Tool's view
   * @return {HTMLElement}
   * @private
   */
  drawView() {
    let t2 = document.createElement("DIV");
    return t2.classList.add(this._CSS.wrapper, this._CSS.block), t2;
  }
  /**
   * Return Tool's view
   * @returns {HTMLDivElement}
   * @public
   */
  render() {
    return this._element;
  }
  /**
   * Extract Tool's data from the view
   * @param {HTMLDivElement} toolsContent - Paragraph tools rendered view
   * @returns {DelimiterData} - saved data
   * @public
   */
  save(t2) {
    return {};
  }
  /**
   * Get Tool toolbox settings
   * icon - Tool icon's SVG
   * title - title to show in toolbox
   *
   * @return {{icon: string, title: string}}
   */
  static get toolbox() {
    return {
      icon: r3,
      title: "Delimiter"
    };
  }
};
(function() {
  try {
    if (typeof document < "u") {
      var e2 = document.createElement("style");
      e2.appendChild(document.createTextNode(".inline-code{background:rgba(250,239,240,.78);color:#b44437;padding:3px 4px;border-radius:5px;margin:0 1px;font-family:inherit;font-size:.86em;font-weight:500;letter-spacing:.3px}")), document.head.appendChild(e2);
    }
  } catch (n3) {
    console.error("vite-plugin-css-injected-by-js", n3);
  }
})();
const o2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M9.5 8L6.11524 11.8683C6.04926 11.9437 6.04926 12.0563 6.11524 12.1317L9.5 16"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M15 8L18.3848 11.8683C18.4507 11.9437 18.4507 12.0563 18.3848 12.1317L15 16"/></svg>';
let s$1 = class s2 {
  /**
   * Class name for term-tag
   *
   * @type {string}
   */
  static get CSS() {
    return "inline-code";
  }
  /**
   */
  constructor({ api: t2 }) {
    this.api = t2, this.button = null, this.tag = "CODE", this.iconClasses = {
      base: this.api.styles.inlineToolButton,
      active: this.api.styles.inlineToolButtonActive
    };
  }
  /**
   * Specifies Tool as Inline Toolbar Tool
   *
   * @return {boolean}
   */
  static get isInline() {
    return true;
  }
  /**
   * Create button element for Toolbar
   *
   * @return {HTMLElement}
   */
  render() {
    return this.button = document.createElement("button"), this.button.type = "button", this.button.classList.add(this.iconClasses.base), this.button.innerHTML = this.toolboxIcon, this.button;
  }
  /**
   * Wrap/Unwrap selected fragment
   *
   * @param {Range} range - selected fragment
   */
  surround(t2) {
    if (!t2)
      return;
    let e2 = this.api.selection.findParentTag(this.tag, s2.CSS);
    e2 ? this.unwrap(e2) : this.wrap(t2);
  }
  /**
   * Wrap selection with term-tag
   *
   * @param {Range} range - selected fragment
   */
  wrap(t2) {
    let e2 = document.createElement(this.tag);
    e2.classList.add(s2.CSS), e2.appendChild(t2.extractContents()), t2.insertNode(e2), this.api.selection.expandToTag(e2);
  }
  /**
   * Unwrap term-tag
   *
   * @param {HTMLElement} termWrapper - term wrapper tag
   */
  unwrap(t2) {
    this.api.selection.expandToTag(t2);
    let e2 = window.getSelection(), n3 = e2.getRangeAt(0), i2 = n3.extractContents();
    t2.parentNode.removeChild(t2), n3.insertNode(i2), e2.removeAllRanges(), e2.addRange(n3);
  }
  /**
   * Check and change Term's state for current selection
   */
  checkState() {
    const t2 = this.api.selection.findParentTag(this.tag, s2.CSS);
    this.button.classList.toggle(this.iconClasses.active, !!t2);
  }
  /**
   * Get Tool icon's SVG
   * @return {string}
   */
  get toolboxIcon() {
    return o2;
  }
  /**
   * Sanitizer rule
   * @return {{span: {class: string}}}
   */
  static get sanitize() {
    return {
      code: {
        class: s2.CSS
      }
    };
  }
};
(function() {
  try {
    if (typeof document < "u") {
      var e2 = document.createElement("style");
      e2.appendChild(document.createTextNode(".cdx-simple-image .cdx-loader{min-height:200px}.cdx-simple-image .cdx-input{margin-top:10px}.cdx-simple-image img{max-width:100%;vertical-align:bottom}.cdx-simple-image__caption[contentEditable=true][data-placeholder]:empty:before{position:absolute;content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.cdx-simple-image__caption[contentEditable=true][data-placeholder]:empty:before{opacity:1}.cdx-simple-image__caption[contentEditable=true][data-placeholder]:empty:focus:before{opacity:0}.cdx-simple-image__picture--with-background{background:#eff2f5;padding:10px}.cdx-simple-image__picture--with-background img{display:block;max-width:60%;margin:0 auto}.cdx-simple-image__picture--with-border{border:1px solid #e8e8eb;padding:1px}.cdx-simple-image__picture--stretched img{max-width:none;width:100%}")), document.head.appendChild(e2);
    }
  } catch (t2) {
    console.error("vite-plugin-css-injected-by-js", t2);
  }
})();
const s3 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19V19C9.13623 19 8.20435 19 7.46927 18.6955C6.48915 18.2895 5.71046 17.5108 5.30448 16.5307C5 15.7956 5 14.8638 5 13V12C5 9.19108 5 7.78661 5.67412 6.77772C5.96596 6.34096 6.34096 5.96596 6.77772 5.67412C7.78661 5 9.19108 5 12 5H13.5C14.8956 5 15.5933 5 16.1611 5.17224C17.4395 5.56004 18.44 6.56046 18.8278 7.83886C19 8.40666 19 9.10444 19 10.5V10.5"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 13V16M16 19V16M19 16H16M16 16H13"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6.5 17.5L17.5 6.5"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.9919 10.5H19.0015"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.9919 19H11.0015"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13L13 5"/></svg>', a2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.9919 9.5H19.0015"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.5 5H14.5096"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M14.625 5H15C17.2091 5 19 6.79086 19 9V9.375"/><path stroke="currentColor" stroke-width="2" d="M9.375 5L9 5C6.79086 5 5 6.79086 5 9V9.375"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.3725 5H9.38207"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 9.5H5.00957"/><path stroke="currentColor" stroke-width="2" d="M9.375 19H9C6.79086 19 5 17.2091 5 15V14.625"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.3725 19H9.38207"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 14.55H5.00957"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 13V16M16 19V16M19 16H16M16 16H13"/></svg>', d3 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9L20 12L17 15"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 12H20"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 9L4 12L7 15"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 12H10"/></svg>';
class h {
  /**
   * Render plugin`s main Element and fill it with saved data
   *
   * @param {{data: SimpleImageData, config: object, api: object}}
   *   data — previously saved data
   *   config - user config for Tool
   *   api - Editor.js API
   *   readOnly - read-only mode flag
   */
  constructor({ data: t2, config: e2, api: r4, readOnly: o3 }) {
    this.api = r4, this.readOnly = o3, this.blockIndex = this.api.blocks.getCurrentBlockIndex() + 1, this.CSS = {
      baseClass: this.api.styles.block,
      loading: this.api.styles.loader,
      input: this.api.styles.input,
      /**
       * Tool's classes
       */
      wrapper: "cdx-simple-image",
      imageHolder: "cdx-simple-image__picture",
      caption: "cdx-simple-image__caption"
    }, this.nodes = {
      wrapper: null,
      imageHolder: null,
      image: null,
      caption: null
    }, this.data = {
      url: t2.url || "",
      caption: t2.caption || "",
      withBorder: t2.withBorder !== void 0 ? t2.withBorder : false,
      withBackground: t2.withBackground !== void 0 ? t2.withBackground : false,
      stretched: t2.stretched !== void 0 ? t2.stretched : false
    }, this.tunes = [
      {
        name: "withBorder",
        label: "Add Border",
        icon: a2
      },
      {
        name: "stretched",
        label: "Stretch Image",
        icon: d3
      },
      {
        name: "withBackground",
        label: "Add Background",
        icon: s3
      }
    ];
  }
  /**
   * Creates a Block:
   *  1) Show preloader
   *  2) Start to load an image
   *  3) After loading, append image and caption input
   *
   * @public
   */
  render() {
    const t2 = this._make("div", [this.CSS.baseClass, this.CSS.wrapper]), e2 = this._make("div", this.CSS.loading), r4 = this._make("div", this.CSS.imageHolder), o3 = this._make("img"), i2 = this._make("div", [this.CSS.input, this.CSS.caption], {
      contentEditable: !this.readOnly,
      innerHTML: this.data.caption || ""
    });
    return i2.dataset.placeholder = "Enter a caption", t2.appendChild(e2), this.data.url && (o3.src = this.data.url), o3.onload = () => {
      t2.classList.remove(this.CSS.loading), r4.appendChild(o3), t2.appendChild(r4), t2.appendChild(i2), e2.remove(), this._acceptTuneView();
    }, o3.onerror = (n3) => {
      console.log("Failed to load an image", n3);
    }, this.nodes.imageHolder = r4, this.nodes.wrapper = t2, this.nodes.image = o3, this.nodes.caption = i2, t2;
  }
  /**
   * @public
   * @param {Element} blockContent - Tool's wrapper
   * @returns {SimpleImageData}
   */
  save(t2) {
    const e2 = t2.querySelector("img"), r4 = t2.querySelector("." + this.CSS.input);
    return e2 ? Object.assign(this.data, {
      url: e2.src,
      caption: r4.innerHTML
    }) : this.data;
  }
  /**
   * Sanitizer rules
   */
  static get sanitize() {
    return {
      url: {},
      withBorder: {},
      withBackground: {},
      stretched: {},
      caption: {
        br: true
      }
    };
  }
  /**
   * Notify core that read-only mode is suppoorted
   *
   * @returns {boolean}
   */
  static get isReadOnlySupported() {
    return true;
  }
  /**
   * Read pasted image and convert it to base64
   *
   * @static
   * @param {File} file
   * @returns {Promise<SimpleImageData>}
   */
  onDropHandler(t2) {
    const e2 = new FileReader();
    return e2.readAsDataURL(t2), new Promise((r4) => {
      e2.onload = (o3) => {
        r4({
          url: o3.target.result,
          caption: t2.name
        });
      };
    });
  }
  /**
   * On paste callback that is fired from Editor.
   *
   * @param {PasteEvent} event - event with pasted config
   */
  onPaste(t2) {
    switch (t2.type) {
      case "tag": {
        const e2 = t2.detail.data;
        this.data = {
          url: e2.src
        };
        break;
      }
      case "pattern": {
        const { data: e2 } = t2.detail;
        this.data = {
          url: e2
        };
        break;
      }
      case "file": {
        const { file: e2 } = t2.detail;
        this.onDropHandler(e2).then((r4) => {
          this.data = r4;
        });
        break;
      }
    }
  }
  /**
   * Returns image data
   *
   * @returns {SimpleImageData}
   */
  get data() {
    return this._data;
  }
  /**
   * Set image data and update the view
   *
   * @param {SimpleImageData} data
   */
  set data(t2) {
    this._data = Object.assign({}, this.data, t2), this.nodes.image && (this.nodes.image.src = this.data.url), this.nodes.caption && (this.nodes.caption.innerHTML = this.data.caption);
  }
  /**
   * Specify paste substitutes
   *
   * @see {@link ../../../docs/tools.md#paste-handling}
   * @public
   */
  static get pasteConfig() {
    return {
      patterns: {
        image: /https?:\/\/\S+\.(gif|jpe?g|tiff|png|webp)$/i
      },
      tags: [
        {
          img: { src: true }
        }
      ],
      files: {
        mimeTypes: ["image/*"]
      }
    };
  }
  /**
   * Returns image tunes config
   *
   * @returns {Array}
   */
  renderSettings() {
    return this.tunes.map((t2) => ({
      ...t2,
      label: this.api.i18n.t(t2.label),
      toggle: true,
      onActivate: () => this._toggleTune(t2.name),
      isActive: !!this.data[t2.name]
    }));
  }
  /**
   * Helper for making Elements with attributes
   *
   * @param  {string} tagName           - new Element tag name
   * @param  {Array|string} classNames  - list or name of CSS classname(s)
   * @param  {object} attributes        - any attributes
   * @returns {Element}
   */
  _make(t2, e2 = null, r4 = {}) {
    const o3 = document.createElement(t2);
    Array.isArray(e2) ? o3.classList.add(...e2) : e2 && o3.classList.add(e2);
    for (const i2 in r4)
      o3[i2] = r4[i2];
    return o3;
  }
  /**
   * Click on the Settings Button
   *
   * @private
   * @param tune
   */
  _toggleTune(t2) {
    this.data[t2] = !this.data[t2], this._acceptTuneView();
  }
  /**
   * Add specified class corresponds with activated tunes
   *
   * @private
   */
  _acceptTuneView() {
    this.tunes.forEach((t2) => {
      this.nodes.imageHolder.classList.toggle(this.CSS.imageHolder + "--" + t2.name.replace(/([A-Z])/g, (e2) => `-${e2[0].toLowerCase()}`), !!this.data[t2.name]), t2.name === "stretched" && this.api.blocks.stretchBlock(this.blockIndex, !!this.data.stretched);
    });
  }
}
const EDITOR_JS_TOOLS = {
  paragraph: {
    class: n$1,
    inlineToolbar: false
  },
  embed: m$2,
  table: I$2,
  marker: s$2,
  list: d$4,
  warning: r$2,
  code: d$3,
  linkTool: I$1,
  image: P2,
  raw: r$1,
  header: c$2,
  quote: i,
  delimiter: o$1,
  inlineCode: s$1,
  simpleImage: h,
  checkList: f,
  link: I$1
};
const RichTextEditor = ({ data, onChange: onChange2, editorblock }) => {
  const ref = reactExports.useRef();
  reactExports.useEffect(() => {
    if (!ref.current) {
      const editor = new Bi({
        holder: editorblock,
        placeholder: "Begin writing your amazing piece of art here ✨",
        tools: EDITOR_JS_TOOLS,
        data: {
          time: (/* @__PURE__ */ new Date()).getTime(),
          blocks: data
        },
        async onChange(api) {
          const data2 = await api.saver.save();
          onChange2(data2);
        }
      });
      ref.current = editor;
    }
    return () => {
      if (ref.current && ref.current.destroy) {
        ref.current.destroy();
      }
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: editorblock });
};
const RichTextEditor$1 = reactExports.memo(RichTextEditor);
function RichTextInput({ map, className = "", isFocused = false, value, onChange: onChange2 }, ref) {
  const input = ref ? ref : reactExports.useRef(null);
  reactExports.useEffect(() => {
    var _a;
    if (isFocused) {
      (_a = input.current) == null ? void 0 : _a.focus();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classNames("bg-white border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5 mt-1 block w-full px-2", className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(RichTextEditor$1, { data: value, onChange: onChange2, editorblock: "editorjs-container" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "hidden", name: map, value })
  ] });
}
function FormViewer({ data, onChange: onChange2 }) {
  const [convertedData, setConvertedData] = reactExports.useState(data);
  reactExports.useEffect(() => {
    setConvertedData(data);
  }, [data]);
  reactExports.useEffect(() => {
    onChange2(convertedData);
  }, [convertedData]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5 block w-full px-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormBody, { form: convertedData, data, errors: [], addRelationData: (d4) => console.log(d4), setData: (d4) => console.log(d4), setRelationData: (d4) => console.log(d4) }) });
}
const draggableChild = "";
class DraggableChildComponent extends React.Component {
  render() {
    return /* @__PURE__ */ React.createElement("div", {
      draggable: true,
      onDragStart: this.props.dragStart,
      onDragEnter: this.props.dragEnter,
      onDragEnd: this.props.dragEnd,
      className: "grabbable"
    }, this.props.children);
  }
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
class DraggableComponent extends reactExports.Component {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", {
      divs: [],
      currentDiv: null,
      toDiv: null
    });
    _defineProperty(this, "componentDidMount", () => {
      this.setState({
        divs: this.props.children
      });
    });
    _defineProperty(this, "insertElementBefore", () => {
      var _a;
      let divs = [...this.state.divs];
      let currentDiv = this.state.currentDiv;
      let toDiv = this.state.toDiv;
      let currentEle;
      if (currentDiv !== toDiv) {
        currentEle = {
          ...divs[currentDiv]
        };
        divs = divs.filter((val, idx) => {
          return idx !== currentDiv;
        });
        divs.splice(toDiv, 0, currentEle);
        this.setState({
          divs: [],
          currentDiv: null,
          toDiv: null
        }, () => {
          this.setState({
            divs
          });
        });
      }
      if ((_a = this.props) == null ? void 0 : _a.onPosChange)
        this.props.onPosChange(currentDiv, toDiv, currentEle);
    });
    _defineProperty(this, "dragStart", (idx) => {
      this.setState({
        currentDiv: idx
      });
    });
    _defineProperty(this, "dragEnter", (idx) => {
      this.setState({
        toDiv: idx
      });
    });
    _defineProperty(this, "dragDrop", () => {
      this.insertElementBefore();
    });
  }
  render() {
    let ele = [];
    for (let i2 = 0; i2 < this.state.divs.length; i2++) {
      ele.push(/* @__PURE__ */ React.createElement(DraggableChildComponent, {
        dragStart: () => this.dragStart(i2),
        dragEnter: () => this.dragEnter(i2),
        dragEnd: this.dragDrop,
        key: i2
      }, this.state.divs[i2]));
    }
    return /* @__PURE__ */ React.createElement(React.Fragment, null, ele);
  }
}
function FormEditor({ isFocused = false, value, onChange: onChange2 }, ref) {
  const input = ref ? ref : reactExports.useRef(null);
  reactExports.useEffect(() => {
    var _a;
    if (isFocused) {
      (_a = input.current) == null ? void 0 : _a.focus();
    }
  }, []);
  const [formStructure, setFormStructure] = reactExports.useState(value ? value : {
    "rows": [
      {
        "width": "full",
        "elements": []
      }
    ]
  });
  const addRow = () => {
    let newFormStructure = Object.assign({}, formStructure);
    newFormStructure.rows.push({
      width: {
        xxxl: 12,
        xxl: 12,
        xl: 12,
        lg: 12,
        md: 12,
        sm: 12,
        xs: 12,
        xxs: 12,
        xxxs: 12
      },
      "elements": [
        {
          width: {
            xxxl: 12,
            xxl: 12,
            xl: 12,
            lg: 12,
            md: 12,
            sm: 12,
            xs: 12,
            xxs: 12,
            xxxs: 12
          },
          type: WidgetFormElementType.TEXT,
          label: "First Name",
          map: "first_name",
          value: "",
          info: ""
        },
        {
          width: {
            xxxl: 12,
            xxl: 12,
            xl: 12,
            lg: 12,
            md: 12,
            sm: 12,
            xs: 12,
            xxs: 12,
            xxxs: 12
          },
          type: WidgetFormElementType.TEXT,
          label: "Last Name",
          map: "last_name",
          value: "",
          info: ""
        }
      ]
    });
    setFormStructure(newFormStructure);
  };
  const addRowElement = (index2) => {
    let newFormStructure = Object.assign({}, formStructure);
    newFormStructure.rows[index2].elements.push({
      width: {
        xxxl: 12,
        xxl: 12,
        xl: 12,
        lg: 12,
        md: 12,
        sm: 12,
        xs: 12,
        xxs: 12,
        xxxs: 12
      },
      label: "Click to edit",
      type: WidgetFormElementType.NATIVE,
      map: "",
      value: "",
      info: ""
    });
    setFormStructure(newFormStructure);
  };
  const changeValue = (index2, elementIndex, data) => {
    let newFormStructure = Object.assign({}, formStructure);
    newFormStructure.rows[index2].elements[elementIndex] = data;
    setFormStructure(newFormStructure);
  };
  const changeGroupValue = (index2, data) => {
    let newFormStructure = Object.assign({}, formStructure);
    newFormStructure.rows[index2] = {
      ...newFormStructure.rows[index2],
      ...data
    };
    setFormStructure(newFormStructure);
  };
  const array_move = (arr, old_index, new_index) => {
    if (new_index >= arr.length) {
      var k2 = new_index - arr.length + 1;
      while (k2--) {
        arr.push(void 0);
      }
    }
    arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);
    return arr;
  };
  const getRowPos = (currentPos, newPos) => {
    let newFormStructure = Object.assign({}, formStructure);
    newFormStructure.rows = array_move(newFormStructure.rows, currentPos, newPos);
    setFormStructure(newFormStructure);
  };
  reactExports.useEffect(() => {
    onChange2(formStructure);
  }, [formStructure]);
  const DraggableRender = reactExports.useCallback(() => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableComponent, { onPosChange: getRowPos, children: formStructure.rows.map((row, index2) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-l-6 rounded-sm flex flex-col gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(RowConfig, { element: row, setData: (data) => changeGroupValue(index2, data) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "px-4 bg-white h-80 relative overflow-y-scroll", children: [
          row.elements.map((element, elementIndex) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(RowInput, { element, setData: (data) => changeValue(index2, elementIndex, data) }, elementIndex);
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-50 text-center border border-dotted py-4 text-slate-700 mb-4", onClick: () => addRowElement(index2), children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppIcon, { icon: "plus", className: "inline-block mr-2 h-6 w-6" }) })
        ] })
      ] }) }, index2) });
    }) });
  }, [formStructure]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5 mt-1 block w-full px-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "gap-4 w-full grid grid-cols-12", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableRender, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ActionButton, { type: "button", onClick: () => addRow(), children: "Add Row" }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "py-4 col-span-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormViewer, { data: formStructure, onChange: (value2) => console.log(value2) }) })
  ] }) });
}
function RowConfig({ element, setData }) {
  const [groupLabel, setGroupLabel] = reactExports.useState(element.group_label);
  const [groupDescription, setGroupDescription] = reactExports.useState(element.group_description);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-12 gap-4 bg-gray-50 p-4 border-b", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { htmlFor: "groupLabel", label: "Label", required: false }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          map: "groupLabel",
          className: "w-full",
          value: groupLabel,
          onChange: (e2) => setGroupLabel(e2.target.value),
          onBlur: () => setData({
            "group_label": groupLabel,
            "group_description": groupDescription
          })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { htmlFor: "groupDescription", label: "Description", required: false }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextareaInput,
        {
          map: "groupDescription",
          className: "w-full",
          value: groupDescription,
          onChange: (e2) => setGroupDescription(e2.target.value),
          onBlur: () => setData({
            "group_label": groupLabel,
            "group_description": groupDescription
          })
        }
      )
    ] })
  ] });
}
function RowInput({ element, setData }) {
  const [showForm, setShowForm] = reactExports.useState(false);
  const [label, setLabel] = reactExports.useState(element.label);
  const [name, setName] = reactExports.useState(element.name);
  const [mapField, setMapField] = reactExports.useState(element.map);
  const [width, setWidth] = reactExports.useState(element.width);
  const [type, setType] = reactExports.useState(element.type);
  const [optionsList, setOptionsList] = reactExports.useState(element.options ? element.options : []);
  const [info, setInfo] = reactExports.useState(element.info ? element.info : "");
  const [placeholder, setPlaceHolder] = reactExports.useState(element.placeholder ? element.placeholder : "");
  const getOptions = (options) => {
    let optionString = "";
    options.map((option, index2) => {
      if (index2 == 0) {
        optionString = option.key + ":" + option.value;
      } else {
        optionString = optionString + ";" + option.key + ":" + option.value;
      }
    });
    return optionString;
  };
  const setOptions = (value) => {
    let options = value.split(";");
    let optionsArray = [];
    options.map((option, index2) => {
      let optionData = option.split(":");
      if (optionData.length == 1) {
        optionsArray.push({ key: index2, value: optionData[0] });
      } else {
        optionsArray.push({ key: optionData[0], value: optionData[1] });
      }
    });
    console.log(options);
    setOptionsList(optionsArray);
  };
  const upDateElement = () => {
    setData({
      "label": label,
      "name": name,
      "map": mapField,
      "info": info,
      "placeholder": placeholder,
      "width": width,
      "options": optionsList,
      "type": type
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-l-3 rounded-sm bg-gray-50", children: [
    showForm && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-right", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppIcon, { icon: "close", onClick: () => setShowForm(!showForm) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 grid grid-cols-12 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { htmlFor: "label", label: "Label", required: false }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              map: "label",
              className: "w-full",
              value: label,
              onChange: (e2) => setLabel(e2.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { htmlFor: "placeholder", label: "Placeholder", required: false }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              map: "placeholder",
              className: "w-full",
              value: placeholder,
              onChange: (e2) => setPlaceHolder(e2.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { htmlFor: "info", label: "Info text", required: false }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              map: "info",
              className: "w-full",
              value: info,
              onChange: (e2) => setInfo(e2.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { htmlFor: "name", label: "Name", required: true }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              map: "name",
              className: "w-full",
              value: name,
              onChange: (e2) => setName(e2.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { htmlFor: "label", label: "Map", required: true }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              map: "map",
              className: "w-full",
              value: mapField,
              onChange: (e2) => setMapField(e2.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { htmlFor: "width", label: "Width", required: true }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              name: "width",
              className: "w-full border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5",
              value: width,
              onChange: (e2) => setWidth(e2.target.value),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "full", children: "Full" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "w-1/2", children: "1/12" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "w-2/2", children: "2/12" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "w-3/2", children: "3/12" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "w-4/2", children: "4/12" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "w-5/2", children: "5/12" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "w-6/2", children: "6/12" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "w-7/2", children: "7/12" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "w-8/2", children: "8/12" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "w-9/2", children: "9/12" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "w-10/2", children: "10/12" })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { htmlFor: "type", label: "Type", required: true }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              name: "type",
              className: "w-full border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5",
              value: type,
              onChange: (e2) => setType(e2.target.value),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "native", children: "Native" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "email", children: "Email" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "simple_select", children: "Select" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "textarea", children: "Textarea" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "number", children: "Number" })
              ]
            }
          )
        ] }),
        type === "simple_select" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { htmlFor: "label", label: "Options", required: true }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextareaInput,
            {
              map: "options",
              className: "w-full border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5",
              value: getOptions(optionsList),
              onChange: (e2) => setOptions(e2.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ActionButton, { type: "button", onClick: () => {
          upDateElement();
        }, children: "Save" }) })
      ] })
    ] }),
    !showForm && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 cursor-pointer", onClick: () => setShowForm(!showForm), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AppIcon, { icon: "edit", className: "inline-block mr-2 h-6 w-6" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "inline-block text-lg font-semibold pt-1", children: element.label })
    ] })
  ] });
}
const NumberInput = reactExports.forwardRef(function NumberInput2({ map, className = "", isFocused = false, ...props }, ref) {
  const input = ref ? ref : reactExports.useRef(null);
  reactExports.useEffect(() => {
    var _a;
    if (isFocused) {
      (_a = input.current) == null ? void 0 : _a.focus();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "number",
      onChange: (e2) => props.onChange && props.onChange(e2),
      onBlur: (e2) => props.onBlur && props.onBlur(e2),
      name: map,
      className: "border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5 " + className,
      ref: input
    }
  );
});
const DecimalInput = reactExports.forwardRef(function DecimalInput2({ map, className = "", isFocused = false, ...props }, ref) {
  var _a, _b;
  const input = ref ? ref : reactExports.useRef(null);
  reactExports.useEffect(() => {
    var _a2;
    if (isFocused) {
      (_a2 = input.current) == null ? void 0 : _a2.focus();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "number",
      name: map,
      onChange: (e2) => props.onChange && props.onChange(e2),
      onBlur: (e2) => props.onBlur && props.onBlur(e2),
      className: "border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5 " + className,
      step: ((_a = props == null ? void 0 : props.config) == null ? void 0 : _a.step) ? (_b = props == null ? void 0 : props.config) == null ? void 0 : _b.step : "0.01",
      ref: input
    }
  );
});
const PasswordInput = reactExports.forwardRef(function PasswordInput2({ map, className = "", isFocused = false, ...props }, ref) {
  const input = ref ? ref : reactExports.useRef(null);
  reactExports.useEffect(() => {
    var _a;
    if (isFocused) {
      (_a = input.current) == null ? void 0 : _a.focus();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "password",
      name: map,
      onChange: (e2) => props.onChange && props.onChange(e2),
      onBlur: (e2) => props.onBlur && props.onBlur(e2),
      className: "border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5 " + className,
      ref: input
    }
  );
});
const HiddenInput = reactExports.forwardRef(function HiddenInput2({ map, className = "", isFocused = false, ...props }, ref) {
  const input = ref ? ref : reactExports.useRef(null);
  reactExports.useEffect(() => {
    var _a;
    if (isFocused) {
      (_a = input.current) == null ? void 0 : _a.focus();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "hidden",
      name: map,
      onChange: (e2) => props.onChange && props.onChange(e2),
      onBlur: (e2) => props.onBlur && props.onBlur(e2),
      className: "border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm py-1.5 " + className,
      ref: input
    }
  );
});
const DateOfBirthInput = reactExports.forwardRef(function DateOfBirthInputProps({ value, className = "", isFocused = false, ...props }, ref) {
  const input = ref ? ref : reactExports.useRef(null);
  const [date2, setDate] = reactExports.useState(value == null ? void 0 : value.date);
  const [month, setMonth] = reactExports.useState(value == null ? void 0 : value.month);
  const [year, setYear] = reactExports.useState(value == null ? void 0 : value.year);
  const updateDate = (dataType, e2) => {
    dataType === "year" && setDate(e2.target.value);
    dataType === "month" && setMonth(e2.target.value);
    dataType === "date" && setYear(Number(e2.target.value));
    const dOB = {
      date: date2,
      month,
      year
    };
    props.onChange(dOB);
  };
  reactExports.useEffect(() => {
    var _a;
    if (isFocused) {
      (_a = input.current) == null ? void 0 : _a.focus();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-0", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1 block w-1/3 flex-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "select",
      {
        onSelect: (e2) => updateDate("date", e2),
        className: "w-full flex bg-white border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm ",
        children: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30].map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: option, selected: option === date2, children: option }))
      },
      props.map + `_date`
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1 block w-1/3 flex-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "select",
      {
        onSelect: (e2) => updateDate("month", e2),
        className: "w-full flex bg-white border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm ",
        children: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"].map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: option, selected: option === String(month), children: option }))
      },
      props.map + `_month`
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1 block w-1/3 flex-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "select",
      {
        onSelect: (e2) => updateDate("year", e2),
        className: "w-full flex bg-white border border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-sm shadow-sm ",
        children: Array.from({ length: 122 }, (_3, i2) => 1900 + i2).map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: option, selected: option === year, children: option }))
      },
      props.map + `_year`
    ) })
  ] });
});
const InputField = reactExports.forwardRef(function InputField2({ element, setData, data }, ref) {
  const input = ref ? ref : reactExports.useRef(null);
  const [value, setValue] = reactExports.useState();
  reactExports.useEffect(() => {
    const match = element.map.match(/(.+)\[(.+)\]/);
    if (match) {
      setValue(data[match[1]][match[2]]);
    } else {
      setValue(data[element.map]);
    }
  }, [data]);
  const changeValue = (key, val) => {
    console.log(key, val);
    const match = key.match(/(.+)\[(.+)\]/);
    if (match) {
      setData(match[1], { ...data[match[1]], [match[2]]: val });
    } else {
      setData(key, val);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    (element.type === WidgetFormElementType.NATIVE || element.type === WidgetFormElementType.STRING || element.type === WidgetFormElementType.TEXT) && /* @__PURE__ */ reactExports.createElement(
      TextInput,
      {
        ...element,
        key: element.map,
        ref: input,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        autoComplete: element.map,
        disabled: element == null ? void 0 : element.disabled,
        onChange: (e2) => changeValue(element.map, e2.target.value)
      }
    ),
    element.type === WidgetFormElementType.NUMBER && /* @__PURE__ */ reactExports.createElement(
      NumberInput,
      {
        ...element,
        key: element.map,
        ref: input,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        autoComplete: element.map,
        onChange: (e2) => changeValue(element.map, e2.target.value)
      }
    ),
    element.type === WidgetFormElementType.DECIMAL && /* @__PURE__ */ reactExports.createElement(
      DecimalInput,
      {
        ...element,
        key: element.map,
        ref: input,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        autoComplete: element.map,
        onChange: (e2) => changeValue(element.map, e2.target.value)
      }
    ),
    (element.type === WidgetFormElementType.AMOUNT || element.type === WidgetFormElementType.MONEY) && /* @__PURE__ */ reactExports.createElement(
      AmountInput,
      {
        ...element,
        key: element.map,
        ref: input,
        value: data[element.map],
        className: "mt-1 block w-full",
        autoComplete: element.map,
        onValueChange: (value2) => changeValue(element.map, value2)
      }
    ),
    element.type === WidgetFormElementType.TEXT_AREA && /* @__PURE__ */ reactExports.createElement(
      TextareaInput,
      {
        ...element,
        key: element.map,
        ref: input,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        autoComplete: element.map,
        onChange: (e2) => changeValue(element.map, e2.target.value)
      }
    ),
    element.type === WidgetFormElementType.PASSWORD && /* @__PURE__ */ reactExports.createElement(
      PasswordInput,
      {
        ...element,
        key: element.map,
        ref: input,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        autoComplete: element.map,
        onChange: (e2) => changeValue(element.map, e2.target.value)
      }
    ),
    element.type === WidgetFormElementType.HIDDEN && /* @__PURE__ */ reactExports.createElement(
      HiddenInput,
      {
        ...element,
        key: element.map,
        ref: input,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        autoComplete: element.map,
        onChange: (e2) => changeValue(element.map, e2.target.value)
      }
    ),
    element.type === WidgetFormElementType.DATE && /* @__PURE__ */ reactExports.createElement(
      DateInput,
      {
        ...element,
        key: element.map,
        ref: input,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        autoComplete: element.map,
        onChange: (e2) => changeValue(element.map, e2)
      }
    ),
    (element.type === WidgetFormElementType.AGE || element.type === WidgetFormElementType.DOB) && /* @__PURE__ */ reactExports.createElement(
      AgeInput,
      {
        ...element,
        key: element.map,
        ref: input,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        autoComplete: element.map,
        onChange: (e2) => changeValue(element.map, e2)
      }
    ),
    element.type === WidgetFormElementType.AGE && /* @__PURE__ */ reactExports.createElement(
      DateOfBirthInput,
      {
        ...element,
        key: element.map,
        ref: input,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        autoComplete: element.map,
        onChange: (e2) => changeValue(element.map, e2)
      }
    ),
    element.type === WidgetFormElementType.PHONE && /* @__PURE__ */ jsxRuntimeExports.jsx(
      PhoneInput,
      {
        map: element.map,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        autoComplete: element.map,
        onChange: (e2) => changeValue(element.map, e2)
      },
      element.map
    ),
    element.type === WidgetFormElementType.TAGS && /* @__PURE__ */ reactExports.createElement(
      TagsInput,
      {
        ...element,
        key: element.map,
        ref: input,
        label: element.label,
        options: element.options,
        value: data[element.map],
        className: "mt-1 block w-full",
        handleInputChange: (e2) => changeValue(element.map, e2)
      }
    ),
    element.type === WidgetFormElementType.SIMPLE_SELECT && /* @__PURE__ */ reactExports.createElement(
      SelectInput$1,
      {
        ...element,
        key: element.map,
        ref: input,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        options: element.options,
        autoComplete: element.map,
        onChange: (e2) => changeValue(element.map, e2)
      }
    ),
    element.type === WidgetFormElementType.SELECT && /* @__PURE__ */ reactExports.createElement(
      SelectInput,
      {
        ...element,
        key: element.map,
        ref: input,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        options: element.options,
        autoComplete: element.map,
        onChange: (e2) => changeValue(element.map, e2)
      }
    ),
    element.type === WidgetFormElementType.URL_SELECT && /* @__PURE__ */ reactExports.createElement(
      SelectUrlInput,
      {
        ...element,
        key: element.map,
        ref: input,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        url: element.url,
        onChange: (e2) => changeValue(element.map, e2)
      }
    ),
    element.type === WidgetFormElementType.ADDRESS && /* @__PURE__ */ reactExports.createElement(
      AddressInput,
      {
        ...element,
        key: element.map,
        ref: input,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        options: element.options,
        onChange: (e2) => changeValue(element.map, e2)
      }
    ),
    element.type === WidgetFormElementType.EMAIL_EDITOR && /* @__PURE__ */ reactExports.createElement(
      EmailInput,
      {
        ...element,
        key: element.map,
        ref: input,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        onChange: (e2) => changeValue(element.map, e2)
      }
    ),
    element.type === WidgetFormElementType.RICH_TEXT_EDITOR && /* @__PURE__ */ reactExports.createElement(
      RichTextInput,
      {
        ...element,
        key: element.map,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        onChange: (e2) => changeValue(element.map, e2)
      }
    ),
    element.type === WidgetFormElementType.FORM_EDITOR && /* @__PURE__ */ reactExports.createElement(
      FormEditor,
      {
        ...element,
        key: element.map,
        value: data[element.map],
        placeholder: element.label,
        className: "mt-1 block w-full",
        onChange: (e2) => changeValue(element.map, e2)
      }
    ),
    element.type === WidgetFormElementType.CHECKBOX && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "block mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        name: element.map,
        label: element.label,
        value,
        onChange: (value2) => {
          changeValue(element.map, value2);
        }
      }
    ) }),
    element.info && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-sm text-gray-500", children: element.info })
  ] });
});
function FormBuilder({ form, submitAt, values = {} }) {
  console.log(form, values);
  const formElements = form.rows.reduce((result2, row) => {
    let elements = [];
    if (row.type) {
      if (row.type === WidgetFormRowType.ACCORDION || row.type === WidgetFormRowType.TABS) {
        row.tabs && row.tabs.forEach((tab) => {
          tab.rows.forEach((trow) => {
            trow.elements.forEach((element) => {
              elements.push(element);
            });
          });
        });
      } else if (row.type === WidgetFormRowType.SECTIONS) {
        row.sections && row.sections.forEach((tab) => {
          tab.rows.forEach((trow) => {
            trow.elements.forEach((element) => {
              elements.push(element);
            });
          });
        });
      } else if (row.type === WidgetFormRowType.ROW) {
        row.elements && row.elements.forEach((element) => {
          elements.push(element);
        });
      }
    } else {
      elements = row.elements;
    }
    elements.forEach((element) => {
      if (element.type === WidgetFormElementType.AGE || element.type === WidgetFormElementType.DOB) {
        result2[element.map] = values[element.map] ? values[element.map] : "|years";
      } else if (element.type === WidgetFormElementType.SIMPLE_SELECT) {
        result2[element.map] = element.options.find((option) => {
          let exploded = element.map.split(".");
          if (exploded.length == 1) {
            return option.value == values[element.map];
          } else if (exploded.length == 2 && values[exploded[0]] && values[exploded[0]][exploded[1]]) {
            return option.value == values[exploded[0]][exploded[1]];
          } else if (exploded.length == 3 && values[exploded[0]] && values[exploded[0]][exploded[1]] && values[exploded[0]][exploded[1]][exploded[2]]) {
            return option.value == values[exploded[0]][exploded[1]][exploded[2]];
          }
        });
      } else if (element.type === WidgetFormElementType.ONE_TO_MANY) {
        if (values[element.map]) {
          let relationalArray = [];
          element.config.elements.forEach((el) => {
            values[element.map].forEach((vl, recordIndex) => {
              if (!relationalArray[recordIndex]) {
                relationalArray[recordIndex] = {};
              }
              if (vl[el.map] !== void 0) {
                if (el.type === WidgetFormElementType.SIMPLE_SELECT) {
                  relationalArray[recordIndex][el.map] = vl[el.map] ? el.options.find((option) => {
                    return option.value == vl[el.map];
                  }) : "";
                } else if (el.type === WidgetFormElementType.CHECKBOX) {
                  relationalArray[recordIndex][el.map] = vl[el.map] === 1 ? true : false;
                } else {
                  relationalArray[recordIndex][el.map] = vl[el.map];
                }
              } else {
                console.log(el, " EL Not found");
              }
            });
            if (element.config.attachments) {
              Object.keys(element.config.attachments).forEach((key) => {
                values[element.map].forEach((vl, recordIndex) => {
                  if (vl[key]) {
                    relationalArray[recordIndex][element.config.attachments[key]] = vl[key];
                  } else {
                    console.log(el, " Attachment Not found");
                  }
                });
              });
            }
          });
          result2[element.map] = relationalArray;
        }
      } else {
        const match = element.map.match(/(.+)\[(.+)\]/);
        if (match) {
          if (!result2[match[1]]) {
            result2[match[1]] = {};
          }
          result2[match[1]][match[2]] = values[match[1]] && values[match[1]][match[2]] ? values[match[1]][match[2]] : "";
        } else {
          let exploded = element.map.split(".");
          if (exploded.length === 1) {
            result2[element.map] = values[element.map] ? values[element.map] : "";
          } else if (exploded.length === 2) {
            result2[element.map] = values[exploded[0]] && values[exploded[0]][exploded[1]] ? values[exploded[0]][exploded[1]] : "";
          } else if (exploded.length === 3) {
            result2[element.map] = values[exploded[0]] && values[exploded[0]][exploded[1]] && values[exploded[0]][exploded[1]][exploded[2]] ? values[exploded[0]][exploded[1]][exploded[2]] : "";
          }
        }
      }
    });
    return result2;
  }, {});
  const [processing, setProcessing] = reactExports.useState(false);
  const [errors, setErrors] = reactExports.useState({});
  const { data, setData, reset } = W$2(formElements);
  reactExports.useEffect(() => {
    return () => {
      resetForm();
    };
  }, []);
  const resetForm = () => {
    reset();
  };
  const setRelationData = (key, value) => {
    let splited = key.split(".");
    let tempObj = data[splited[0]];
    if (splited.length === 1) {
      tempObj = value;
    }
    if (splited.length === 2) {
      tempObj[splited[1]] = value;
    }
    if (splited.length === 3) {
      tempObj[splited[1]][splited[2]] = value;
    }
    setData(splited[0], tempObj);
  };
  const addRelationData = (key, elemants) => {
    let newObject = {};
    elemants.forEach((element) => {
      newObject[element.map] = "";
    });
    let tempObj = data[key] ? data[key] : [];
    tempObj.push(newObject);
    console.log(tempObj);
    setData(key, tempObj);
    postHeight();
  };
  const submit = (e2) => {
    e2.preventDefault();
    setProcessing(true);
    setErrors({});
    const ToastNotification = Q$1.loading(
      form.type == "create" ? "Ceating" : form.type == "edit" ? "Updating" : form.type == "delete" ? "Deleting" : form.type == "confirm" ? "Confirming" : form.type == "block" ? "Blocking" : "Submiting"
    );
    axios.post(submitAt, data, {
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    }).then((resp) => {
      var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m;
      if ((_a = resp == null ? void 0 : resp.data) == null ? void 0 : _a.next) {
        if ((_c = (_b = resp == null ? void 0 : resp.data) == null ? void 0 : _b.next) == null ? void 0 : _c.type) {
          if ((_d = resp == null ? void 0 : resp.data) == null ? void 0 : _d.message) {
            Q$1.update(ToastNotification, {
              render: (_e2 = resp == null ? void 0 : resp.data) == null ? void 0 : _e2.message,
              type: "success",
              isLoading: false,
              autoClose: 5e3
            });
          }
          if (((_g = (_f = resp == null ? void 0 : resp.data) == null ? void 0 : _f.next) == null ? void 0 : _g.type) === "reload") {
            yt$1 && yt$1.reload();
          } else if (((_i = (_h = resp == null ? void 0 : resp.data) == null ? void 0 : _h.next) == null ? void 0 : _i.type) === "redirect" && ((_k = (_j = resp == null ? void 0 : resp.data) == null ? void 0 : _j.next) == null ? void 0 : _k.action)) {
            yt$1 && yt$1.visit((_m = (_l = resp == null ? void 0 : resp.data) == null ? void 0 : _l.next) == null ? void 0 : _m.action);
          }
        }
      }
    }).catch(({ response }) => {
      if (response.status == 422) {
        let errorstrings = {};
        Object.keys(response.data.errors).forEach((index2) => {
          console.log(index2, response.data.errors[index2]);
          errorstrings[index2] = response.data.errors[index2].join(", ");
        });
        setErrors(errorstrings);
      }
      Q$1.update(ToastNotification, {
        render: "Something went wrong 🤯",
        type: "error",
        isLoading: false,
        autoClose: 5e3
      });
    }).finally(() => {
      setProcessing(false);
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 shadow-md rounded-sm pt-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 bg-clip-border", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 text-gray-900", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "font-semibold text-xl text-gray-800 leading-tight", children: form.name }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: submit, className: "pt-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FormBody, { form, data, errors, addRelationData, setData, setRelationData }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-right justify-end space-x-3 p-4 bg-gray-100", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ActionButton, { colorType: "secondary", variant: "md", type: "button", disabled: processing, onClick: () => resetForm(), children: "Reset" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ActionButton, { colorType: "primary", variant: "md", type: "submit", disabled: processing, children: [
          processing && /* @__PURE__ */ jsxRuntimeExports.jsx(AppIcon, { className: "animate-spin text-white", icon: "loader" }),
          form.type == "create" ? processing ? "Ceating" : "Create" : form.type == "edit" ? processing ? "Updating" : "Update" : form.type == "delete" ? processing ? "Deleting" : "Delete" : form.type == "confirm" ? processing ? "Confirming" : "Confirm" : form.type == "block" ? processing ? "Blocking" : "Block" : processing ? "Submiting" : "Submit"
        ] })
      ] })
    ] })
  ] });
}
function FormBody({ form, data = [], errors = {}, addRelationData, setData, setRelationData }) {
  console.log(form, data);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: form.rows.map((row, row_index) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: validateShowWhen(row == null ? void 0 : row.show_when, data) === true && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: row.type ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      row.type === WidgetFormRowType.ACCORDION && row.tabs.map((tab) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(we$1, { children: ({ open }) => (
          /* Use the `open` state to conditionally change the direction of an icon. */
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(we$1.Button, { className: "flex w-full justify-between rounded-lg bg-blue-100 px-4 mb-4 py-2 text-left text-sm font-medium text-blue-900 hover:bg-blue-200 focus:outline-none focus-visible:ring focus-visible:ring-purple-500/75", children: [
              tab.title,
              /* @__PURE__ */ jsxRuntimeExports.jsx(AppIcon, { icon: "chevron-right", className: `${open ? "rotate-90 transform" : ""} h-5 w-5 text-blue-500 ` })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Ke$1,
              {
                show: open,
                enter: "transition duration-100 ease-out",
                enterFrom: "transform scale-95 opacity-0",
                enterTo: "transform scale-100 opacity-100",
                leave: "transition duration-75 ease-out",
                leaveFrom: "transform scale-100 opacity-100",
                leaveTo: "transform scale-95 opacity-0",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(we$1.Panel, { className: "px-4 pb-2 text-sm text-gray-500 mb-2", static: true, children: tab.rows.map((trow) => {
                  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormElements, { row: trow, data, errors, setData, addRelationData, setRelationData });
                }) })
              }
            )
          ] })
        ) });
      }),
      row.type === WidgetFormRowType.SECTIONS && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "gap-4 w-full grid grid-cols-12", children: row.sections.map((section) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: section.rows.map((srow) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(RowElement, { element: srow, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormElements, { row: srow, data, errors, setData, inside: true, addRelationData, setRelationData }) });
        }) });
      }) }),
      row.type === WidgetFormRowType.TABS && /* @__PURE__ */ jsxRuntimeExports.jsxs(st$1.Group, { onChange: () => postHeight(), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(st$1.List, { className: "flex space-x-1 rounded-md p-1 border bg-white", children: row.tabs.map((tab) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            st$1,
            {
              className: ({ selected }) => classNames(
                "flex-0 px-12 rounded-sm py-2.5 text-sm font-medium leading-5",
                "ring-white/60 ring-offset-2 ring-offset-blue-400 focus:outline-none focus:ring-2",
                selected ? "bg-gray-100 text-slate-800 shadow" : "text-slate-500 hover:bg-gray-50"
              ),
              children: tab.title
            }
          );
        }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(st$1.Panels, { className: "mt-2", children: row.tabs.map((tab) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            st$1.Panel,
            {
              className: classNames(
                "p-3 grid grid-cols-12 gap-4 rounded-sm shadow-md bg-white text-gray-500 text-sm"
              ),
              children: tab.rows.map((trow) => {
                return /* @__PURE__ */ jsxRuntimeExports.jsx(RowElement, { element: trow, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormElements, { row: trow, data, errors, setData, inside: true, addRelationData, setRelationData }) });
              })
            }
          );
        }) })
      ] }),
      row.type === WidgetFormRowType.ROW && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: row.group_label ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classNames("flex flex-col md:flex-row my-4 py-4", {
        "border-t": row_index != 0
      }), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full md:w-2/12", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "px-4 pb-3 md:px-6 md:pb-0 text-md font-semibold", children: row.group_label }),
          row.group_description && /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "px-4 text-gray-500 pb-3 md:px-6 md:pb-0 text-sm", children: row.group_description })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full md:w-10/12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormElements, { row, data, errors, setData, addRelationData, setRelationData }) })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(FormElements, { row, data, errors, setData, addRelationData, setRelationData }) })
    ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: row.group_label ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classNames("flex flex-col md:flex-row my-4 py-4", {
      "border-t": row_index != 0
    }), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full md:w-2/12", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "px-4 pb-3 md:px-6 md:pb-0 text-md font-semibold", children: row.group_label }),
        row.group_description && /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "px-4 text-gray-500 pb-3 md:px-6 md:pb-0 text-sm", children: row.group_description })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full md:w-10/12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormElements, { row, data, errors, setData, addRelationData, setRelationData }) })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(FormElements, { row, data, errors, setData, addRelationData, setRelationData }) }) }) });
  }) });
}
const validateShowWhen = (conditions, data) => {
  if (conditions === void 0 || data === void 0)
    return true;
  if (conditions.length <= 0)
    return true;
  if (Array.isArray(data)) {
    if (data.length <= 0)
      return true;
  } else if (typeof data === "object") {
    if (Object.keys(data).length <= 0)
      return true;
  }
  let retVal = [];
  conditions.forEach((condition) => {
    let explodedIndexes = condition.key.split(".");
    let valueToCompare;
    if (explodedIndexes.length === 1)
      valueToCompare = data[explodedIndexes[0]];
    if (explodedIndexes.length === 2)
      valueToCompare = data[explodedIndexes[0]][explodedIndexes[1]];
    if (explodedIndexes.length === 3)
      valueToCompare = data[explodedIndexes[0]][explodedIndexes[1]][explodedIndexes[2]];
    if (explodedIndexes.length === 4)
      valueToCompare = data[explodedIndexes[0]][explodedIndexes[1]][explodedIndexes[2]][explodedIndexes[3]];
    if (condition.operator === "EQUAL" || condition.operator === "EQUALS") {
      retVal.push(valueToCompare == condition.value);
    }
    if (condition.operator === "NOT_EQUAL" || condition.operator === "NOT_EQUALS") {
      retVal.push(valueToCompare != condition.value);
    }
    if (condition.operator === "IN") {
      retVal.push(condition.value.includes(valueToCompare));
    }
  });
  return retVal.includes(true);
};
function FormElements({ row, data, errors, setData, inside = false, addRelationData, setRelationData }) {
  const deleteElement = (key, index2) => {
    let tempData = data[key];
    tempData.splice(index2, 1);
    console.log(key, tempData);
    setData(key, tempData);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classNames({
    "mb-4 px-4 w-full": inside === false,
    "mb-4 w-full": inside === true
  }), children: [
    row.title && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 w-full text-left text-sm font-medium text-blue-900", children: row.title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("gap-4 w-full grid grid-cols-12", {
      // "flex flex-col md:flex-row justify-between mt-4" : inside === false,
      // "flex flex-col mt-2" : inside === true
    }), children: row.elements.map((element) => {
      if (validateShowWhen(element == null ? void 0 : element.show_when, data)) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(RowElement, { element, children: [
          element.type != WidgetFormElementType.ONE_TO_MANY && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            element.type != WidgetFormElementType.HIDDEN && element.type != WidgetFormElementType.CHECKBOX && /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { htmlFor: element.map, label: element.label, required: element == null ? void 0 : element.required }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              InputField,
              {
                element,
                data,
                setData: (map, value) => setData(map, value)
              }
            )
          ] }),
          element.type === "one-to-many" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border rounded-sm relative p-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { htmlFor: element.map, label: element.label, required: element == null ? void 0 : element.required, className: "absolute -top-3 left-0.5" }),
            data[element.map] && data[element.map].map((dat, index2) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classNames("flex flex-row w-full my-1 border divide-x divide-double", {
                "bg-gray-100": index2 % 2 == 0,
                "bg-gray-200": index2 % 2 != 0
              }), children: [
                element.config.elements_label && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classNames("flex-0 justify-center items-center h-full"), children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(ActionButton, { colorType: "dangerous", type: "button", variant: "xs", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppIcon, { icon: "trash", className: "h-4 w-4", onClick: () => deleteElement(element.map, index2) }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "[writing-mode:vertical-lr] text-center text-sm p-1 py-2", children: dat[element.config.elements_label] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 grid grid-cols-12 gap-4 p-3", children: element.config.elements.map((el) => {
                  if (validateShowWhen(el == null ? void 0 : el.show_when, dat)) {
                    return /* @__PURE__ */ jsxRuntimeExports.jsxs(RowElement, { element: el, wrapperClassName: "gap-4", children: [
                      el.type != WidgetFormElementType.HIDDEN && el.type != WidgetFormElementType.CHECKBOX && /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { htmlFor: el.map, label: el.label }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        InputField,
                        {
                          element: el,
                          data: dat,
                          setData: (map, value) => setRelationData(element.map + "." + index2 + "." + map, value)
                        }
                      )
                    ] });
                  }
                }) })
              ] });
            }),
            element.config.allow_new && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row-reverse mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ActionButton, { colorType: "primary", type: "button", onClick: () => addRelationData(element.map, element.config.elements), variant: "xs", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(AppIcon, { icon: "plus", className: "h-3 w-3" }),
              " Add"
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(InputError, { message: errors[element.map], className: "mt-2" })
        ] });
      }
    }) })
  ] });
}
export {
  FormBody,
  FormElements,
  FormBuilder as default
};
